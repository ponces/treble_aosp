From 5e5041a5107d159d1b481665a1872447028cbd66 Mon Sep 17 00:00:00 2001
From: Daniel Zhang <danielzhang130@gmail.com>
Date: Sat, 30 Mar 2024 14:44:57 -0400
Subject: [PATCH 06/16] Revert "Remove deprecated HAL versions for IRadio"

This reverts commit 50fc709cc1d87e5d1e6d75c856bc4b6894070a39.

Change-Id: Ia3aa57286fb5cce42065f7db8133fa3caf1fcd61
---
 Android.bp                                    |    1 +
 .../telephony/CellularNetworkService.java     |  105 +-
 .../internal/telephony/NetworkIndication.java |    5 +-
 .../internal/telephony/NetworkResponse.java   |   19 +
 .../com/android/internal/telephony/RIL.java   | 2377 +++++++++++------
 .../android/internal/telephony/RILUtils.java  |  399 ++-
 .../internal/telephony/RadioConfig.java       |    9 +-
 .../internal/telephony/RadioConfigProxy.java  |   22 +-
 .../internal/telephony/RadioDataProxy.java    |   88 +-
 .../internal/telephony/RadioIndication.java   |  103 +-
 .../telephony/RadioMessagingProxy.java        |    4 +-
 .../internal/telephony/RadioModemProxy.java   |   12 +-
 .../internal/telephony/RadioNetworkProxy.java |   92 +-
 .../internal/telephony/RadioResponse.java     |  327 ++-
 .../internal/telephony/RadioServiceProxy.java |   10 +-
 .../internal/telephony/RadioSimProxy.java     |   80 +-
 .../internal/telephony/RadioVoiceProxy.java   |    8 +-
 .../android/internal/telephony/RILTest.java   | 1382 +++++-----
 .../internal/telephony/SimulatedCommands.java |   31 +-
 19 files changed, 3397 insertions(+), 1677 deletions(-)

diff --git a/Android.bp b/Android.bp
index c3b43735f1..331b722ace 100644
--- a/Android.bp
+++ b/Android.bp
@@ -99,6 +99,7 @@ java_library {
         "android.hardware.radio.config-V1.1-java-shallow",
         "android.hardware.radio.config-V1.2-java-shallow",
         "android.hardware.radio.config-V1.3-java-shallow",
+        "android.hardware.radio.deprecated-V1.0-java-shallow",
         "ecc-protos-lite",
         "libphonenumber-nogeocoder",
         "PlatformProperties",
diff --git a/src/java/com/android/internal/telephony/CellularNetworkService.java b/src/java/com/android/internal/telephony/CellularNetworkService.java
index bff1d41327..41cbb662e4 100644
--- a/src/java/com/android/internal/telephony/CellularNetworkService.java
+++ b/src/java/com/android/internal/telephony/CellularNetworkService.java
@@ -286,6 +286,27 @@ public class CellularNetworkService extends NetworkService {
             } else if (result instanceof android.hardware.radio.V1_5.RegStateResult) {
                 return getNetworkRegistrationInfo(domain, transportType,
                         (android.hardware.radio.V1_5.RegStateResult) result);
+            } else if (result instanceof android.hardware.radio.V1_0.VoiceRegStateResult) {
+                android.hardware.radio.V1_0.VoiceRegStateResult voiceRegState =
+                        (android.hardware.radio.V1_0.VoiceRegStateResult) result;
+                int regState = getRegStateFromHalRegState(voiceRegState.regState);
+                int networkType = ServiceState.rilRadioTechnologyToNetworkType(voiceRegState.rat);
+                int reasonForDenial = voiceRegState.reasonForDenial;
+                boolean emergencyOnly = isEmergencyOnly(voiceRegState.regState);
+                boolean cssSupported = voiceRegState.cssSupported;
+                int roamingIndicator = voiceRegState.roamingIndicator;
+                int systemIsInPrl = voiceRegState.systemIsInPrl;
+                int defaultRoamingIndicator = voiceRegState.defaultRoamingIndicator;
+                List<Integer> availableServices = getAvailableServices(
+                        regState, domain, emergencyOnly);
+                CellIdentity cellIdentity =
+                        RILUtils.convertHalCellIdentity(voiceRegState.cellIdentity);
+                final String rplmn = getPlmnFromCellIdentity(cellIdentity);
+
+                return new NetworkRegistrationInfo(domain, transportType, regState,
+                        networkType, reasonForDenial, emergencyOnly, availableServices,
+                        cellIdentity, rplmn, cssSupported, roamingIndicator, systemIsInPrl,
+                        defaultRoamingIndicator);
             } else if (result instanceof android.hardware.radio.V1_2.VoiceRegStateResult) {
                 android.hardware.radio.V1_2.VoiceRegStateResult voiceRegState =
                         (android.hardware.radio.V1_2.VoiceRegStateResult) result;
@@ -316,6 +337,20 @@ public class CellularNetworkService extends NetworkService {
             final int domain = NetworkRegistrationInfo.DOMAIN_PS;
             final int transportType = AccessNetworkConstants.TRANSPORT_TYPE_WWAN;
 
+            int regState = NetworkRegistrationInfo.REGISTRATION_STATE_UNKNOWN;
+            int networkType = TelephonyManager.NETWORK_TYPE_UNKNOWN;
+            int reasonForDenial = 0;
+            boolean emergencyOnly = false;
+            int maxDataCalls = 0;
+            CellIdentity cellIdentity;
+            boolean isEndcAvailable = false;
+            boolean isNrAvailable = false;
+            boolean isDcNrRestricted = false;
+
+            LteVopsSupportInfo lteVopsSupportInfo =
+                    new LteVopsSupportInfo(LteVopsSupportInfo.LTE_STATUS_NOT_AVAILABLE,
+                            LteVopsSupportInfo.LTE_STATUS_NOT_AVAILABLE);
+
             if (result instanceof android.hardware.radio.network.RegStateResult) {
                 return getNetworkRegistrationInfoAidl(domain, transportType,
                         (android.hardware.radio.network.RegStateResult) result);
@@ -325,46 +360,66 @@ public class CellularNetworkService extends NetworkService {
             } else if (result instanceof android.hardware.radio.V1_5.RegStateResult) {
                 return getNetworkRegistrationInfo(domain, transportType,
                         (android.hardware.radio.V1_5.RegStateResult) result);
+            } else if (result instanceof android.hardware.radio.V1_0.DataRegStateResult) {
+                android.hardware.radio.V1_0.DataRegStateResult dataRegState =
+                        (android.hardware.radio.V1_0.DataRegStateResult) result;
+                regState = getRegStateFromHalRegState(dataRegState.regState);
+                networkType = ServiceState.rilRadioTechnologyToNetworkType(dataRegState.rat);
+                reasonForDenial = dataRegState.reasonDataDenied;
+                emergencyOnly = isEmergencyOnly(dataRegState.regState);
+                maxDataCalls = dataRegState.maxDataCalls;
+                cellIdentity = RILUtils.convertHalCellIdentity(dataRegState.cellIdentity);
+            } else if (result instanceof android.hardware.radio.V1_2.DataRegStateResult) {
+                android.hardware.radio.V1_2.DataRegStateResult dataRegState =
+                        (android.hardware.radio.V1_2.DataRegStateResult) result;
+                regState = getRegStateFromHalRegState(dataRegState.regState);
+                networkType = ServiceState.rilRadioTechnologyToNetworkType(dataRegState.rat);
+                reasonForDenial = dataRegState.reasonDataDenied;
+                emergencyOnly = isEmergencyOnly(dataRegState.regState);
+                maxDataCalls = dataRegState.maxDataCalls;
+                cellIdentity = RILUtils.convertHalCellIdentity(dataRegState.cellIdentity);
             } else if (result instanceof android.hardware.radio.V1_4.DataRegStateResult) {
                 android.hardware.radio.V1_4.DataRegStateResult dataRegState =
                         (android.hardware.radio.V1_4.DataRegStateResult) result;
-                LteVopsSupportInfo lteVopsSupportInfo;
+                regState = getRegStateFromHalRegState(dataRegState.base.regState);
+                networkType = ServiceState.rilRadioTechnologyToNetworkType(dataRegState.base.rat);
+
+                reasonForDenial = dataRegState.base.reasonDataDenied;
+                emergencyOnly = isEmergencyOnly(dataRegState.base.regState);
+                maxDataCalls = dataRegState.base.maxDataCalls;
+                cellIdentity = RILUtils.convertHalCellIdentity(dataRegState.base.cellIdentity);
+                android.hardware.radio.V1_4.NrIndicators nrIndicators = dataRegState.nrIndicators;
+
                 // Check for lteVopsInfo only if its initialized and RAT is EUTRAN
                 if (dataRegState.vopsInfo.getDiscriminator() == hidl_discriminator.lteVopsInfo
                         && ServiceState.rilRadioTechnologyToAccessNetworkType(dataRegState.base.rat)
                             == AccessNetworkType.EUTRAN) {
                     android.hardware.radio.V1_4.LteVopsInfo vopsSupport =
                             dataRegState.vopsInfo.lteVopsInfo();
-                    lteVopsSupportInfo = convertHalLteVopsSupportInfo(
-                            vopsSupport.isVopsSupported, vopsSupport.isEmcBearerSupported);
+                    lteVopsSupportInfo = convertHalLteVopsSupportInfo(vopsSupport.isVopsSupported,
+                        vopsSupport.isEmcBearerSupported);
                 } else {
-                    lteVopsSupportInfo = new LteVopsSupportInfo(
-                            LteVopsSupportInfo.LTE_STATUS_NOT_AVAILABLE,
-                            LteVopsSupportInfo.LTE_STATUS_NOT_AVAILABLE);
+                    lteVopsSupportInfo =
+                        new LteVopsSupportInfo(LteVopsSupportInfo.LTE_STATUS_NOT_AVAILABLE,
+                        LteVopsSupportInfo.LTE_STATUS_NOT_AVAILABLE);
                 }
-                int regState = getRegStateFromHalRegState(dataRegState.base.regState);
-                int networkType =
-                        ServiceState.rilRadioTechnologyToNetworkType(dataRegState.base.rat);
-                int reasonForDenial = dataRegState.base.reasonDataDenied;
-                boolean emergencyOnly = isEmergencyOnly(dataRegState.base.regState);
-                int maxDataCalls = dataRegState.base.maxDataCalls;
-                CellIdentity cellIdentity =
-                        RILUtils.convertHalCellIdentity(dataRegState.base.cellIdentity);
-                android.hardware.radio.V1_4.NrIndicators nrIndicators = dataRegState.nrIndicators;
-                boolean isEndcAvailable = nrIndicators.isEndcAvailable;
-                boolean isNrAvailable = nrIndicators.isNrAvailable;
-                boolean isDcNrRestricted = nrIndicators.isDcNrRestricted;
-                String rplmn = getPlmnFromCellIdentity(cellIdentity);
-                List<Integer> availableServices = getAvailableServices(
-                        regState, domain, emergencyOnly);
-                return new NetworkRegistrationInfo(domain, transportType, regState, networkType,
-                        reasonForDenial, emergencyOnly, availableServices, cellIdentity, rplmn,
-                        maxDataCalls, isDcNrRestricted, isNrAvailable, isEndcAvailable,
-                        lteVopsSupportInfo);
+
+                isEndcAvailable = nrIndicators.isEndcAvailable;
+                isNrAvailable = nrIndicators.isNrAvailable;
+                isDcNrRestricted = nrIndicators.isDcNrRestricted;
             } else {
                 loge("Unknown type of DataRegStateResult " + result);
                 return null;
             }
+
+            String rplmn = getPlmnFromCellIdentity(cellIdentity);
+            List<Integer> availableServices = getAvailableServices(
+                    regState, domain, emergencyOnly);
+
+            return new NetworkRegistrationInfo(domain, transportType, regState, networkType,
+                    reasonForDenial, emergencyOnly, availableServices, cellIdentity, rplmn,
+                    maxDataCalls, isDcNrRestricted, isNrAvailable, isEndcAvailable,
+                    lteVopsSupportInfo);
         }
 
         private @NonNull NetworkRegistrationInfo getNetworkRegistrationInfo(
diff --git a/src/java/com/android/internal/telephony/NetworkIndication.java b/src/java/com/android/internal/telephony/NetworkIndication.java
index 5c492349cd..0d5d871020 100644
--- a/src/java/com/android/internal/telephony/NetworkIndication.java
+++ b/src/java/com/android/internal/telephony/NetworkIndication.java
@@ -132,7 +132,7 @@ public class NetworkIndication extends IRadioNetworkIndication.Stub {
             android.hardware.radio.network.LinkCapacityEstimate lce) {
         mRil.processIndication(HAL_SERVICE_NETWORK, indicationType);
 
-        List<LinkCapacityEstimate> response = RILUtils.convertHalLinkCapacityEstimate(lce);
+        List<LinkCapacityEstimate> response = RILUtils.convertHalLceData(lce);
 
         if (mRil.isLogOrTrace()) mRil.unsljLogRet(RIL_UNSOL_LCEDATA_RECV, response);
 
@@ -211,8 +211,9 @@ public class NetworkIndication extends IRadioNetworkIndication.Stub {
             android.hardware.radio.network.SignalStrength signalStrength) {
         mRil.processIndication(HAL_SERVICE_NETWORK, indicationType);
 
-        SignalStrength ss = RILUtils.convertHalSignalStrength(signalStrength);
+        SignalStrength ssInitial = RILUtils.convertHalSignalStrength(signalStrength);
 
+        SignalStrength ss = mRil.fixupSignalStrength10(ssInitial);
         // Note this is set to "verbose" because it happens frequently
         if (mRil.isLogvOrTrace()) mRil.unsljLogvRet(RIL_UNSOL_SIGNAL_STRENGTH, ss);
 
diff --git a/src/java/com/android/internal/telephony/NetworkResponse.java b/src/java/com/android/internal/telephony/NetworkResponse.java
index b4a37b3d60..b2571d981a 100644
--- a/src/java/com/android/internal/telephony/NetworkResponse.java
+++ b/src/java/com/android/internal/telephony/NetworkResponse.java
@@ -25,10 +25,12 @@ import android.os.AsyncResult;
 import android.telephony.BarringInfo;
 import android.telephony.CellInfo;
 import android.telephony.EmergencyRegistrationResult;
+import android.telephony.LinkCapacityEstimate;
 import android.telephony.RadioAccessSpecifier;
 import android.telephony.SignalStrength;
 
 import java.util.ArrayList;
+import java.util.List;
 
 /**
  * Interface declaring response functions to solicited radio requests for network APIs.
@@ -265,6 +267,23 @@ public class NetworkResponse extends IRadioNetworkResponse.Stub {
         }
     }
 
+    /**
+     * @param responseInfo Response info struct containing response type, serial no. and error
+     * @param lceInfo LceDataInfo indicating LCE data
+     */
+    public void pullLceDataResponse(RadioResponseInfo responseInfo,
+            android.hardware.radio.network.LceDataInfo lceInfo) {
+        RILRequest rr = mRil.processResponse(HAL_SERVICE_NETWORK, responseInfo);
+
+        if (rr != null) {
+            List<LinkCapacityEstimate> ret = RILUtils.convertHalLceData(lceInfo);
+            if (responseInfo.error == RadioError.NONE) {
+                RadioResponse.sendMessageResponse(rr.mResult, ret);
+            }
+            mRil.processResponseDone(rr, responseInfo, ret);
+        }
+    }
+
     /**
      * @param responseInfo Response info struct containing response type, serial no. and error
      */
diff --git a/src/java/com/android/internal/telephony/RIL.java b/src/java/com/android/internal/telephony/RIL.java
index 53e288f321..b44fb0f119 100644
--- a/src/java/com/android/internal/telephony/RIL.java
+++ b/src/java/com/android/internal/telephony/RIL.java
@@ -60,6 +60,13 @@ import android.telephony.AccessNetworkConstants;
 import android.telephony.AccessNetworkConstants.AccessNetworkType;
 import android.telephony.BarringInfo;
 import android.telephony.CarrierRestrictionRules;
+import android.telephony.CellInfo;
+import android.telephony.CellSignalStrengthCdma;
+import android.telephony.CellSignalStrengthGsm;
+import android.telephony.CellSignalStrengthLte;
+import android.telephony.CellSignalStrengthNr;
+import android.telephony.CellSignalStrengthTdscdma;
+import android.telephony.CellSignalStrengthWcdma;
 import android.telephony.ClientRequestStats;
 import android.telephony.DomainSelectionService;
 import android.telephony.ImsiEncryptionInfo;
@@ -68,6 +75,8 @@ import android.telephony.NeighboringCellInfo;
 import android.telephony.NetworkScanRequest;
 import android.telephony.RadioAccessFamily;
 import android.telephony.RadioAccessSpecifier;
+import android.telephony.ServiceState;
+import android.telephony.SignalStrength;
 import android.telephony.SignalThresholdInfo;
 import android.telephony.SubscriptionManager;
 import android.telephony.TelephonyHistogram;
@@ -117,6 +126,7 @@ import java.util.concurrent.atomic.AtomicLong;
 
 /**
  * RIL implementation of the CommandsInterface.
+ *
  * {@hide}
  */
 public class RIL extends BaseCommands implements CommandsInterface {
@@ -129,7 +139,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     static final int RIL_HISTOGRAM_BUCKET_COUNT = 5;
 
     /**
-     * Wake lock timeout should be longer than the longest timeout in the vendor ril.
+     * Wake lock timeout should be longer than the longest timeout in
+     * the vendor ril.
      */
     private static final int DEFAULT_WAKE_LOCK_TIMEOUT_MS = 60000;
 
@@ -150,6 +161,18 @@ public class RIL extends BaseCommands implements CommandsInterface {
     /** @hide */
     public static final HalVersion RADIO_HAL_VERSION_UNKNOWN = HalVersion.UNKNOWN;
 
+    /** @hide */
+    public static final HalVersion RADIO_HAL_VERSION_1_0 = new HalVersion(1, 0);
+
+    /** @hide */
+    public static final HalVersion RADIO_HAL_VERSION_1_1 = new HalVersion(1, 1);
+
+    /** @hide */
+    public static final HalVersion RADIO_HAL_VERSION_1_2 = new HalVersion(1, 2);
+
+    /** @hide */
+    public static final HalVersion RADIO_HAL_VERSION_1_3 = new HalVersion(1, 3);
+
     /** @hide */
     public static final HalVersion RADIO_HAL_VERSION_1_4 = new HalVersion(1, 4);
 
@@ -180,7 +203,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     public final WakeLock mAckWakeLock;        // Wake lock associated with ack sent
     final int mWakeLockTimeout;         // Timeout associated with request/response
     final int mAckWakeLockTimeout;      // Timeout associated with ack sent
-    // The number of wakelock requests currently active. Don't release the lock until dec'd to 0.
+    // The number of wakelock requests currently active.  Don't release the lock
+    // until dec'd to 0
     int mWakeLockCount;
 
     // Variables used to identify releasing of WL on wakelock timeouts
@@ -320,10 +344,11 @@ public class RIL extends BaseCommands implements CommandsInterface {
                             }
                             if (RILJ_LOGD) {
                                 int count = mRequestList.size();
-                                riljLog("WAKE_LOCK_TIMEOUT mRequestList=" + count);
+                                Rlog.d(RILJ_LOG_TAG, "WAKE_LOCK_TIMEOUT " +
+                                        " mRequestList=" + count);
                                 for (int i = 0; i < count; i++) {
                                     rr = mRequestList.valueAt(i);
-                                    riljLog(i + ": [" + rr.mSerial + "] "
+                                    Rlog.d(RILJ_LOG_TAG, i + ": [" + rr.mSerial + "] "
                                             + RILUtils.requestToString(rr.mRequest));
                                 }
                             }
@@ -334,7 +359,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
                 case EVENT_ACK_WAKE_LOCK_TIMEOUT:
                     if (msg.arg1 == mAckWlSequenceNum && clearWakeLock(FOR_ACK_WAKELOCK)) {
                         if (RILJ_LOGV) {
-                            riljLog("ACK_WAKE_LOCK_TIMEOUT");
+                            Rlog.d(RILJ_LOG_TAG, "ACK_WAKE_LOCK_TIMEOUT");
                         }
                     }
                     break;
@@ -593,10 +618,10 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @VisibleForTesting
     public void setCompatVersion(int rilRequest, @NonNull HalVersion halVersion) {
         HalVersion oldVersion = getCompatVersion(rilRequest);
-        // Do not allow to set same or greater versions
+        // Do not allow to set same or greater verions
         if (oldVersion != null && halVersion.greaterOrEqual(oldVersion)) {
-            riljLoge("setCompatVersion with equal or greater one, ignored, halVersion=" + halVersion
-                    + ", oldVersion=" + oldVersion);
+            riljLoge("setCompatVersion with equal or greater one, ignored, halVerion=" + halVersion
+                    + ", oldVerion=" + oldVersion);
             return;
         }
         mCompatOverrides.put(rilRequest, halVersion);
@@ -657,7 +682,39 @@ public class RIL extends BaseCommands implements CommandsInterface {
                 }
 
                 if (mRadioProxy == null) {
-                    riljLoge("IRadio <1.4 is no longer supported.");
+                    try {
+                        mRadioProxy = android.hardware.radio.V1_3.IRadio.getService(
+                                HIDL_SERVICE_NAME[mPhoneId], true);
+                        mHalVersion.put(HAL_SERVICE_RADIO, RADIO_HAL_VERSION_1_3);
+                    } catch (NoSuchElementException e) {
+                    }
+                }
+
+                if (mRadioProxy == null) {
+                    try {
+                        mRadioProxy = android.hardware.radio.V1_2.IRadio.getService(
+                                HIDL_SERVICE_NAME[mPhoneId], true);
+                        mHalVersion.put(HAL_SERVICE_RADIO, RADIO_HAL_VERSION_1_2);
+                    } catch (NoSuchElementException e) {
+                    }
+                }
+
+                if (mRadioProxy == null) {
+                    try {
+                        mRadioProxy = android.hardware.radio.V1_1.IRadio.getService(
+                                HIDL_SERVICE_NAME[mPhoneId], true);
+                        mHalVersion.put(HAL_SERVICE_RADIO, RADIO_HAL_VERSION_1_1);
+                    } catch (NoSuchElementException e) {
+                    }
+                }
+
+                if (mRadioProxy == null) {
+                    try {
+                        mRadioProxy = android.hardware.radio.V1_0.IRadio.getService(
+                                HIDL_SERVICE_NAME[mPhoneId], true);
+                        mHalVersion.put(HAL_SERVICE_RADIO, RADIO_HAL_VERSION_1_0);
+                    } catch (NoSuchElementException e) {
+                    }
                 }
 
                 if (mRadioProxy != null) {
@@ -728,7 +785,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
     public synchronized RadioServiceProxy getRadioServiceProxy(int service) {
         if (!SubscriptionManager.isValidPhoneId(mPhoneId)) return mServiceProxies.get(service);
         if ((service >= HAL_SERVICE_IMS) && !isRadioServiceSupported(service)) {
-            riljLogw("getRadioServiceProxy: " + serviceToString(service) + " for "
+            Rlog.w(RILJ_LOG_TAG, "getRadioServiceProxy: " + serviceToString(service) + " for "
                     + HIDL_SERVICE_NAME[mPhoneId] + " is not supported\n"
                     + android.util.Log.getStackTraceString(new RuntimeException()));
             return mServiceProxies.get(service);
@@ -894,7 +951,46 @@ public class RIL extends BaseCommands implements CommandsInterface {
 
                 if (serviceProxy.isEmpty()
                         && mHalVersion.get(service).less(RADIO_HAL_VERSION_2_0)) {
-                    riljLoge("IRadio <1.4 is no longer supported.");
+                    try {
+                        mHalVersion.put(service, RADIO_HAL_VERSION_1_3);
+                        serviceProxy.setHidl(mHalVersion.get(service),
+                                android.hardware.radio.V1_3.IRadio.getService(
+                                        HIDL_SERVICE_NAME[mPhoneId], true));
+                    } catch (NoSuchElementException e) {
+                    }
+                }
+
+                if (serviceProxy.isEmpty()
+                        && mHalVersion.get(service).less(RADIO_HAL_VERSION_2_0)) {
+                    try {
+                        mHalVersion.put(service, RADIO_HAL_VERSION_1_2);
+                        serviceProxy.setHidl(mHalVersion.get(service),
+                                android.hardware.radio.V1_2.IRadio.getService(
+                                        HIDL_SERVICE_NAME[mPhoneId], true));
+                    } catch (NoSuchElementException e) {
+                    }
+                }
+
+                if (serviceProxy.isEmpty()
+                        && mHalVersion.get(service).less(RADIO_HAL_VERSION_2_0)) {
+                    try {
+                        mHalVersion.put(service, RADIO_HAL_VERSION_1_1);
+                        serviceProxy.setHidl(mHalVersion.get(service),
+                                android.hardware.radio.V1_1.IRadio.getService(
+                                        HIDL_SERVICE_NAME[mPhoneId], true));
+                    } catch (NoSuchElementException e) {
+                    }
+                }
+
+                if (serviceProxy.isEmpty()
+                        && mHalVersion.get(service).less(RADIO_HAL_VERSION_2_0)) {
+                    try {
+                        mHalVersion.put(service, RADIO_HAL_VERSION_1_0);
+                        serviceProxy.setHidl(mHalVersion.get(service),
+                                android.hardware.radio.V1_0.IRadio.getService(
+                                        HIDL_SERVICE_NAME[mPhoneId], true));
+                    } catch (NoSuchElementException e) {
+                    }
                 }
 
                 if (!serviceProxy.isEmpty()) {
@@ -944,7 +1040,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
                                 break;
                         }
                     } else {
-                        if (mHalVersion.get(service).greaterOrEqual(RADIO_HAL_VERSION_2_0)) {
+                        if (mHalVersion.get(service)
+                                .greaterOrEqual(RADIO_HAL_VERSION_2_0)) {
                             throw new AssertionError("serviceProxy shouldn't be HIDL with HAL 2.0");
                         }
                         if (!mIsRadioProxyInitialized) {
@@ -1265,6 +1362,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
         }
     }
 
+    
     private boolean canMakeRequest(String request, RadioServiceProxy proxy, Message result,
             HalVersion version) {
         int service = HAL_SERVICE_RADIO;
@@ -1307,14 +1405,34 @@ public class RIL extends BaseCommands implements CommandsInterface {
         return true;
     }
 
+    private void handleRadioServiceNotAvailable(RadioServiceProxy proxy, Message result) {
+        if (result != null) {
+            riljLoge("RadioService is not available, " + proxy);
+            AsyncResult.forMessage(result, null,
+                    CommandException.fromRilErrno(RADIO_NOT_AVAILABLE));
+            result.sendToTarget();
+        }
+    }
+
+    private void handleRadioProxyNotAvailable(Message result) {
+        if (result != null) {
+            riljLoge("RadioProxy is not available");
+            AsyncResult.forMessage(result, null,
+                    CommandException.fromRilErrno(RADIO_NOT_AVAILABLE));
+            result.sendToTarget();
+        }
+    }
+
     @Override
     public void getIccCardStatus(Message result) {
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("getIccCardStatus", simProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_GET_SIM_STATUS, result, mRILDefaultWorkSource);
+        RILRequest rr = obtainRequest(RIL_REQUEST_GET_SIM_STATUS, result,
+                mRILDefaultWorkSource);
 
         if (RILJ_LOGD) {
             riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
@@ -1327,12 +1445,24 @@ public class RIL extends BaseCommands implements CommandsInterface {
 
     @Override
     public void getIccSlotsStatus(Message result) {
-        // TODO(b/280900995): remove this and references
+        if (RILJ_LOGD) Rlog.d(RILJ_LOG_TAG, "getIccSlotsStatus: REQUEST_NOT_SUPPORTED");
+        if (result != null) {
+            AsyncResult.forMessage(result, null,
+                    CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+            result.sendToTarget();
+        }
     }
 
     @Override
     public void setLogicalToPhysicalSlotMapping(int[] physicalSlots, Message result) {
-        // TODO(b/280900995): remove this and references
+        if (RILJ_LOGD) {
+            Rlog.d(RILJ_LOG_TAG, "setLogicalToPhysicalSlotMapping: REQUEST_NOT_SUPPORTED");
+        }
+        if (result != null) {
+            AsyncResult.forMessage(result, null,
+                    CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+            result.sendToTarget();
+        }
     }
 
     @Override
@@ -1343,7 +1473,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void supplyIccPinForApp(String pin, String aid, Message result) {
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("supplyIccPinForApp", simProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
 
@@ -1368,7 +1499,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void supplyIccPukForApp(String puk, String newPin, String aid, Message result) {
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("supplyIccPukForApp", simProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
 
@@ -1395,7 +1527,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void supplyIccPin2ForApp(String pin, String aid, Message result) {
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("supplyIccPin2ForApp", simProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
 
@@ -1420,7 +1553,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void supplyIccPuk2ForApp(String puk, String newPin2, String aid, Message result) {
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("supplyIccPuk2ForApp", simProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
 
@@ -1446,7 +1580,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void changeIccPinForApp(String oldPin, String newPin, String aid, Message result) {
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("changeIccPinForApp", simProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
 
@@ -1473,7 +1608,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void changeIccPin2ForApp(String oldPin2, String newPin2, String aid, Message result) {
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("changeIccPin2ForApp", simProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
 
@@ -1495,8 +1631,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void supplyNetworkDepersonalization(String netpin, Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("supplyNetworkDepersonalization", networkProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
 
@@ -1517,35 +1653,45 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void supplySimDepersonalization(PersoSubState persoType, String controlKey,
             Message result) {
-        if (mHalVersion.get(HAL_SERVICE_SIM).less(RADIO_HAL_VERSION_1_5)
-                && PersoSubState.PERSOSUBSTATE_SIM_NETWORK == persoType) {
-            supplyNetworkDepersonalization(controlKey, result);
-            return;
-        }
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("supplySimDepersonalization", simProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_SIM).greaterOrEqual(RADIO_HAL_VERSION_1_5)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_ENTER_SIM_DEPERSONALIZATION, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_ENTER_SIM_DEPERSONALIZATION, result,
-                mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
+                        + " controlKey = " + controlKey + " persoType" + persoType);
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
-                    + " controlKey = " + controlKey + " persoType" + persoType);
+            radioServiceInvokeHelper(HAL_SERVICE_SIM, rr, "supplySimDepersonalization", () -> {
+                simProxy.supplySimDepersonalization(rr.mSerial, persoType,
+                        RILUtils.convertNullToEmptyString(controlKey));
+            });
+        } else {
+            if (PersoSubState.PERSOSUBSTATE_SIM_NETWORK == persoType) {
+                supplyNetworkDepersonalization(controlKey, result);
+                return;
+            }
+            if (RILJ_LOGD) {
+                Rlog.d(RILJ_LOG_TAG, "supplySimDepersonalization: REQUEST_NOT_SUPPORTED");
+            }
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_SIM, rr, "supplySimDepersonalization", () -> {
-            simProxy.supplySimDepersonalization(rr.mSerial, persoType,
-                    RILUtils.convertNullToEmptyString(controlKey));
-        });
     }
 
     @Override
     public void getCurrentCalls(Message result) {
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("getCurrentCalls", voiceProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
 
@@ -1570,93 +1716,131 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void enableModem(boolean enable, Message result) {
         RadioModemProxy modemProxy = getRadioServiceProxy(RadioModemProxy.class);
-        if (!canMakeRequest("enableModem", modemProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (modemProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(modemProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_MODEM).greaterOrEqual(RADIO_HAL_VERSION_1_3)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_ENABLE_MODEM, result, mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_ENABLE_MODEM, result, mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
+                        + " enable = " + enable);
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
-                    + " enable = " + enable);
+            radioServiceInvokeHelper(HAL_SERVICE_MODEM, rr, "enableModem", () -> {
+                modemProxy.enableModem(rr.mSerial, enable);
+            });
+        } else {
+            if (RILJ_LOGV) riljLog("enableModem: not supported.");
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_MODEM, rr, "enableModem", () -> {
-            modemProxy.enableModem(rr.mSerial, enable);
-        });
     }
 
     @Override
     public void setSystemSelectionChannels(@NonNull List<RadioAccessSpecifier> specifiers,
             Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("setSystemSelectionChannels", networkProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_NETWORK).greaterOrEqual(RADIO_HAL_VERSION_1_3)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_SET_SYSTEM_SELECTION_CHANNELS, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_SET_SYSTEM_SELECTION_CHANNELS, result,
-                mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
+                        + " setSystemSelectionChannels_1.3= " + specifiers);
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
-                    + " setSystemSelectionChannels= " + specifiers);
+            radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "setSystemSelectionChannels", () -> {
+                networkProxy.setSystemSelectionChannels(rr.mSerial, specifiers);
+            });
+        } else {
+            if (RILJ_LOGV) riljLog("setSystemSelectionChannels: not supported.");
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "setSystemSelectionChannels", () -> {
-            networkProxy.setSystemSelectionChannels(rr.mSerial, specifiers);
-        });
     }
 
     @Override
     public void getSystemSelectionChannels(Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("getSystemSelectionChannels", networkProxy, result,
-                RADIO_HAL_VERSION_1_6)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_NETWORK).greaterOrEqual(RADIO_HAL_VERSION_1_6)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_GET_SYSTEM_SELECTION_CHANNELS, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_GET_SYSTEM_SELECTION_CHANNELS, result,
-                mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
+                        + " getSystemSelectionChannels");
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
-                    + " getSystemSelectionChannels");
+            radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "getSystemSelectionChannels", () -> {
+                networkProxy.getSystemSelectionChannels(rr.mSerial);
+            });
+        } else {
+            if (RILJ_LOGV) riljLog("getSystemSelectionChannels: not supported.");
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "getSystemSelectionChannels", () -> {
-            networkProxy.getSystemSelectionChannels(rr.mSerial);
-        });
     }
 
     @Override
     public void getModemStatus(Message result) {
         RadioModemProxy modemProxy = getRadioServiceProxy(RadioModemProxy.class);
-        if (!canMakeRequest("getModemStatus", modemProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (modemProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(modemProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_MODEM).greaterOrEqual(RADIO_HAL_VERSION_1_3)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_GET_MODEM_STATUS, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_GET_MODEM_STATUS, result, mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            radioServiceInvokeHelper(HAL_SERVICE_MODEM, rr, "getModemStatus", () -> {
+                modemProxy.getModemStackStatus(rr.mSerial);
+            });
+        } else {
+            if (RILJ_LOGV) riljLog("getModemStatus: not supported.");
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_MODEM, rr, "getModemStatus", () -> {
-            modemProxy.getModemStackStatus(rr.mSerial);
-        });
     }
 
     @Override
     public void dial(String address, boolean isEmergencyCall, EmergencyNumber emergencyNumberInfo,
             boolean hasKnownUserIntentEmergency, int clirMode, UUSInfo uusInfo, Message result) {
-        if (isEmergencyCall && emergencyNumberInfo != null) {
+        if (isEmergencyCall
+                && mHalVersion.get(HAL_SERVICE_VOICE).greaterOrEqual(RADIO_HAL_VERSION_1_4)
+                && emergencyNumberInfo != null) {
             emergencyDial(address, emergencyNumberInfo, hasKnownUserIntentEmergency, clirMode,
                     uusInfo, result);
             return;
         }
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("dial", voiceProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
 
@@ -1675,21 +1859,26 @@ public class RIL extends BaseCommands implements CommandsInterface {
     private void emergencyDial(String address, EmergencyNumber emergencyNumberInfo,
             boolean hasKnownUserIntentEmergency, int clirMode, UUSInfo uusInfo, Message result) {
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("emergencyDial", voiceProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_VOICE).greaterOrEqual(RADIO_HAL_VERSION_1_4)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_EMERGENCY_DIAL, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_EMERGENCY_DIAL, result, mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                // Do not log function arg for privacy
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            }
 
-        if (RILJ_LOGD) {
-            // Do not log function arg for privacy
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            radioServiceInvokeHelper(HAL_SERVICE_VOICE, rr, "emergencyDial", () -> {
+                voiceProxy.emergencyDial(rr.mSerial, RILUtils.convertNullToEmptyString(address),
+                        emergencyNumberInfo, hasKnownUserIntentEmergency, clirMode, uusInfo);
+            });
+        } else {
+            riljLoge("emergencyDial is not supported with 1.4 below IRadio");
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_VOICE, rr, "emergencyDial", () -> {
-            voiceProxy.emergencyDial(rr.mSerial, RILUtils.convertNullToEmptyString(address),
-                    emergencyNumberInfo, hasKnownUserIntentEmergency, clirMode, uusInfo);
-        });
     }
 
     @Override
@@ -1700,7 +1889,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void getIMSIForApp(String aid, Message result) {
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("getIMSIForApp", simProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
 
@@ -1718,7 +1908,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void hangupConnection(int gsmIndex, Message result) {
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("hangupConnection", voiceProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
 
@@ -1738,11 +1929,10 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void hangupWaitingOrBackground(Message result) {
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("hangupWaitingOrBackground", voiceProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
-
         RILRequest rr = obtainRequest(RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND, result,
                 mRILDefaultWorkSource);
 
@@ -1759,8 +1949,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void hangupForegroundResumeBackground(Message result) {
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("hangupForegroundResumeBackground", voiceProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
 
@@ -1779,8 +1969,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void switchWaitingOrHoldingAndActive(Message result) {
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("switchWaitingOrHoldingAndActive", voiceProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
 
@@ -1799,10 +1989,10 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void conference(Message result) {
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("conference", voiceProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
-
         RILRequest rr = obtainRequest(RIL_REQUEST_CONFERENCE, result, mRILDefaultWorkSource);
 
         if (RILJ_LOGD) {
@@ -1817,7 +2007,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void rejectCall(Message result) {
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("rejectCall", voiceProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
 
@@ -1835,7 +2026,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void getLastCallFailCause(Message result) {
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("getLastCallFailCause", voiceProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
 
@@ -1854,7 +2046,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void getSignalStrength(Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("getSignalStrength", networkProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
 
@@ -1872,8 +2065,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void getVoiceRegistrationState(Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("getVoiceRegistrationState", networkProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
 
@@ -1897,8 +2090,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void getDataRegistrationState(Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("getDataRegistrationState", networkProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
 
@@ -1922,7 +2115,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void getOperator(Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("getOperator", networkProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
 
@@ -1942,7 +2136,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     public void setRadioPower(boolean on, boolean forEmergencyCall,
             boolean preferredForEmergencyCall, Message result) {
         RadioModemProxy modemProxy = getRadioServiceProxy(RadioModemProxy.class);
-        if (!canMakeRequest("setRadioPower", modemProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (modemProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(modemProxy, result);
             return;
         }
 
@@ -1963,7 +2158,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void sendDtmf(char c, Message result) {
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("sendDtmf", voiceProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
 
@@ -1981,8 +2177,10 @@ public class RIL extends BaseCommands implements CommandsInterface {
 
     @Override
     public void sendSMS(String smscPdu, String pdu, Message result) {
-        RadioMessagingProxy messagingProxy = getRadioServiceProxy(RadioMessagingProxy.class);
-        if (!canMakeRequest("sendSMS", messagingProxy, result, RADIO_HAL_VERSION_1_4)) {
+        RadioMessagingProxy messagingProxy =
+                getRadioServiceProxy(RadioMessagingProxy.class);
+        if (messagingProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(messagingProxy, result);
             return;
         }
 
@@ -2020,8 +2218,10 @@ public class RIL extends BaseCommands implements CommandsInterface {
 
     @Override
     public void sendSMSExpectMore(String smscPdu, String pdu, Message result) {
-        RadioMessagingProxy messagingProxy = getRadioServiceProxy(RadioMessagingProxy.class);
-        if (!canMakeRequest("sendSMSExpectMore", messagingProxy, result, RADIO_HAL_VERSION_1_4)) {
+        RadioMessagingProxy messagingProxy =
+                getRadioServiceProxy(RadioMessagingProxy.class);
+        if (messagingProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(messagingProxy, result);
             return;
         }
 
@@ -2041,12 +2241,13 @@ public class RIL extends BaseCommands implements CommandsInterface {
     }
 
     @Override
-    public void setupDataCall(int accessNetworkType, DataProfile dataProfile,
-            boolean isRoaming /* unused */, boolean allowRoaming, int reason,
-            LinkProperties linkProperties, int pduSessionId, NetworkSliceInfo sliceInfo,
-            TrafficDescriptor trafficDescriptor, boolean matchAllRuleAllowed, Message result) {
+    public void setupDataCall(int accessNetworkType, DataProfile dataProfile, boolean isRoaming,
+            boolean allowRoaming, int reason, LinkProperties linkProperties, int pduSessionId,
+            NetworkSliceInfo sliceInfo, TrafficDescriptor trafficDescriptor,
+            boolean matchAllRuleAllowed, Message result) {
         RadioDataProxy dataProxy = getRadioServiceProxy(RadioDataProxy.class);
-        if (!canMakeRequest("setupDataCall", dataProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (dataProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(dataProxy, result);
             return;
         }
 
@@ -2056,16 +2257,17 @@ public class RIL extends BaseCommands implements CommandsInterface {
             riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
                     + ",reason=" + RILUtils.setupDataReasonToString(reason)
                     + ",accessNetworkType=" + AccessNetworkType.toString(accessNetworkType)
-                    + ",dataProfile=" + dataProfile + ",allowRoaming=" + allowRoaming
+                    + ",dataProfile=" + dataProfile + ",isRoaming=" + isRoaming
+                    + ",allowRoaming=" + allowRoaming
                     + ",linkProperties=" + linkProperties + ",pduSessionId=" + pduSessionId
                     + ",sliceInfo=" + sliceInfo + ",trafficDescriptor=" + trafficDescriptor
                     + ",matchAllRuleAllowed=" + matchAllRuleAllowed);
         }
 
         radioServiceInvokeHelper(HAL_SERVICE_DATA, rr, "setupDataCall", () -> {
-            dataProxy.setupDataCall(rr.mSerial, accessNetworkType, dataProfile, allowRoaming,
-                    reason, linkProperties, pduSessionId, sliceInfo, trafficDescriptor,
-                    matchAllRuleAllowed);
+            dataProxy.setupDataCall(rr.mSerial, mPhoneId, accessNetworkType, dataProfile,
+                    isRoaming, allowRoaming, reason, linkProperties, pduSessionId, sliceInfo,
+                    trafficDescriptor, matchAllRuleAllowed);
         });
     }
 
@@ -2079,7 +2281,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     public void iccIOForApp(int command, int fileId, String path, int p1, int p2, int p3,
             String data, String pin2, String aid, Message result) {
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("iccIOForApp", simProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
 
@@ -2108,8 +2311,10 @@ public class RIL extends BaseCommands implements CommandsInterface {
 
     @Override
     public void sendUSSD(String ussd, Message result) {
-        RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("sendUSSD", voiceProxy, result, RADIO_HAL_VERSION_1_4)) {
+        RadioVoiceProxy voiceProxy =
+                getRadioServiceProxy(RadioVoiceProxy.class);
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
 
@@ -2129,8 +2334,10 @@ public class RIL extends BaseCommands implements CommandsInterface {
 
     @Override
     public void cancelPendingUssd(Message result) {
-        RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("cancelPendingUssd", voiceProxy, result, RADIO_HAL_VERSION_1_4)) {
+        RadioVoiceProxy voiceProxy =
+                getRadioServiceProxy(RadioVoiceProxy.class);
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
 
@@ -2148,7 +2355,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void getCLIR(Message result) {
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("getCLIR", voiceProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
 
@@ -2166,7 +2374,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void setCLIR(int clirMode, Message result) {
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("setCLIR", voiceProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
 
@@ -2186,7 +2395,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     public void queryCallForwardStatus(int cfReason, int serviceClass, String number,
             Message result) {
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("queryCallForwardStatus", voiceProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
 
@@ -2195,7 +2405,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
 
         if (RILJ_LOGD) {
             riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
-                    + " cfReason = " + cfReason + " serviceClass = " + serviceClass);
+                    + " cfreason = " + cfReason + " serviceClass = " + serviceClass);
         }
 
         radioServiceInvokeHelper(HAL_SERVICE_VOICE, rr, "queryCallForwardStatus", () -> {
@@ -2207,7 +2417,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     public void setCallForward(int action, int cfReason, int serviceClass, String number,
             int timeSeconds, Message result) {
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("setCallForward", voiceProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
 
@@ -2228,7 +2439,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void queryCallWaiting(int serviceClass, Message result) {
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("queryCallWaiting", voiceProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
 
@@ -2248,7 +2460,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void setCallWaiting(boolean enable, int serviceClass, Message result) {
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("setCallWaiting", voiceProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
 
@@ -2266,9 +2479,10 @@ public class RIL extends BaseCommands implements CommandsInterface {
 
     @Override
     public void acknowledgeLastIncomingGsmSms(boolean success, int cause, Message result) {
-        RadioMessagingProxy messagingProxy = getRadioServiceProxy(RadioMessagingProxy.class);
-        if (!canMakeRequest("acknowledgeLastIncomingGsmSms", messagingProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        RadioMessagingProxy messagingProxy =
+                getRadioServiceProxy(RadioMessagingProxy.class);
+        if (messagingProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(messagingProxy, result);
             return;
         }
 
@@ -2279,15 +2493,17 @@ public class RIL extends BaseCommands implements CommandsInterface {
                     + " success = " + success + " cause = " + cause);
         }
 
-        radioServiceInvokeHelper(HAL_SERVICE_MESSAGING, rr, "acknowledgeLastIncomingGsmSms", () -> {
-            messagingProxy.acknowledgeLastIncomingGsmSms(rr.mSerial, success, cause);
-        });
+        radioServiceInvokeHelper(
+                HAL_SERVICE_MESSAGING, rr, "acknowledgeLastIncomingGsmSms", () -> {
+                    messagingProxy.acknowledgeLastIncomingGsmSms(rr.mSerial, success, cause);
+                });
     }
 
     @Override
     public void acceptCall(Message result) {
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("acceptCall", voiceProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
 
@@ -2306,7 +2522,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void deactivateDataCall(int cid, int reason, Message result) {
         RadioDataProxy dataProxy = getRadioServiceProxy(RadioDataProxy.class);
-        if (!canMakeRequest("deactivateDataCall", dataProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (dataProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(dataProxy, result);
             return;
         }
 
@@ -2335,7 +2552,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     public void queryFacilityLockForApp(String facility, String password, int serviceClass,
             String appId, Message result) {
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("queryFacilityLockForApp", simProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
 
@@ -2351,8 +2569,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
         radioServiceInvokeHelper(HAL_SERVICE_SIM, rr, "queryFacilityLockForApp", () -> {
             simProxy.getFacilityLockForApp(rr.mSerial,
                     RILUtils.convertNullToEmptyString(facility),
-                    RILUtils.convertNullToEmptyString(password), serviceClass,
-                    RILUtils.convertNullToEmptyString(appId));
+                    RILUtils.convertNullToEmptyString(password),
+                    serviceClass, RILUtils.convertNullToEmptyString(appId));
         });
 
     }
@@ -2367,7 +2585,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     public void setFacilityLockForApp(String facility, boolean lockState, String password,
             int serviceClass, String appId, Message result) {
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("setFacilityLockForApp", simProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
 
@@ -2391,7 +2610,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     public void changeBarringPassword(String facility, String oldPwd, String newPwd,
             Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("changeBarringPassword", networkProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
 
@@ -2415,8 +2635,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void getNetworkSelectionMode(Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("getNetworkSelectionMode", networkProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
 
@@ -2435,8 +2655,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void setNetworkSelectionModeAutomatic(Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("setNetworkSelectionModeAutomatic", networkProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
 
@@ -2447,8 +2667,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
             riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
         }
 
-        radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "setNetworkSelectionModeAutomatic",
-                () -> {
+        radioServiceInvokeHelper(
+                HAL_SERVICE_NETWORK, rr, "setNetworkSelectionModeAutomatic", () -> {
                     networkProxy.setNetworkSelectionModeAutomatic(rr.mSerial);
                 });
     }
@@ -2456,8 +2676,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void setNetworkSelectionModeManual(String operatorNumeric, int ran, Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("setNetworkSelectionModeManual", networkProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
 
@@ -2478,7 +2698,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void getAvailableNetworks(Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("getAvailableNetworks", networkProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
 
@@ -2503,50 +2724,70 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void startNetworkScan(NetworkScanRequest networkScanRequest, Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("startNetworkScan", networkProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_NETWORK).greaterOrEqual(RADIO_HAL_VERSION_1_1)) {
+            HalVersion overrideHalVersion = getCompatVersion(RIL_REQUEST_START_NETWORK_SCAN);
+            if (RILJ_LOGD) {
+                riljLog("startNetworkScan: overrideHalVersion=" + overrideHalVersion);
+            }
 
-        HalVersion overrideHalVersion = getCompatVersion(RIL_REQUEST_START_NETWORK_SCAN);
-        if (RILJ_LOGD) {
-            riljLog("startNetworkScan: overrideHalVersion=" + overrideHalVersion);
-        }
+            RILRequest rr = obtainRequest(RIL_REQUEST_START_NETWORK_SCAN, result,
+                    mRILDefaultWorkSource, networkScanRequest);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_START_NETWORK_SCAN, result,
-                mRILDefaultWorkSource, networkScanRequest);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "startNetworkScan", () -> {
+                networkProxy.startNetworkScan(rr.mSerial, networkScanRequest, overrideHalVersion,
+                        result);
+            });
+        } else {
+            if (RILJ_LOGD) Rlog.d(RILJ_LOG_TAG, "startNetworkScan: REQUEST_NOT_SUPPORTED");
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "startNetworkScan", () -> {
-            networkProxy.startNetworkScan(rr.mSerial, networkScanRequest, overrideHalVersion,
-                    result);
-        });
     }
 
     @Override
     public void stopNetworkScan(Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("stopNetworkScan", networkProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_NETWORK).greaterOrEqual(RADIO_HAL_VERSION_1_1)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_STOP_NETWORK_SCAN, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_STOP_NETWORK_SCAN, result, mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "stopNetworkScan", () -> {
+                networkProxy.stopNetworkScan(rr.mSerial);
+            });
+        } else {
+            if (RILJ_LOGD) Rlog.d(RILJ_LOG_TAG, "stopNetworkScan: REQUEST_NOT_SUPPORTED");
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "stopNetworkScan", () -> {
-            networkProxy.stopNetworkScan(rr.mSerial);
-        });
     }
 
     @Override
     public void startDtmf(char c, Message result) {
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("startDtmf", voiceProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
 
@@ -2565,7 +2806,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void stopDtmf(Message result) {
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("stopDtmf", voiceProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
 
@@ -2583,7 +2825,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void separateConnection(int gsmIndex, Message result) {
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("separateConnection", voiceProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
 
@@ -2603,7 +2846,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void getBasebandVersion(Message result) {
         RadioModemProxy modemProxy = getRadioServiceProxy(RadioModemProxy.class);
-        if (!canMakeRequest("getBasebandVersion", modemProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (modemProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(modemProxy, result);
             return;
         }
 
@@ -2621,7 +2865,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void setMute(boolean enableMute, Message result) {
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("setMute", voiceProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
 
@@ -2640,7 +2885,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void getMute(Message result) {
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("getMute", voiceProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
 
@@ -2658,7 +2904,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void queryCLIP(Message result) {
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("queryCLIP", voiceProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
 
@@ -2679,14 +2926,14 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     @Deprecated
     public void getPDPContextList(Message result) {
-        // TODO(b/280900995): remove this and references
         getDataCallList(result);
     }
 
     @Override
     public void getDataCallList(Message result) {
         RadioDataProxy dataProxy = getRadioServiceProxy(RadioDataProxy.class);
-        if (!canMakeRequest("getDataCallList", dataProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (dataProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(dataProxy, result);
             return;
         }
 
@@ -2701,22 +2948,22 @@ public class RIL extends BaseCommands implements CommandsInterface {
         });
     }
 
+    // TODO(b/171260715) Remove when HAL definition is removed
     @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)
     @Override
     public void invokeOemRilRequestRaw(byte[] data, Message response) {
-        // TODO(b/280900995): remove this and references
     }
 
+    // TODO(b/171260715) Remove when HAL definition is removed
     @Override
     public void invokeOemRilRequestStrings(String[] strings, Message result) {
-        // TODO(b/280900995): remove this and references
     }
 
     @Override
     public void setSuppServiceNotifications(boolean enable, Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("setSuppServiceNotifications", networkProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
 
@@ -2735,8 +2982,10 @@ public class RIL extends BaseCommands implements CommandsInterface {
 
     @Override
     public void writeSmsToSim(int status, String smsc, String pdu, Message result) {
-        RadioMessagingProxy messagingProxy = getRadioServiceProxy(RadioMessagingProxy.class);
-        if (!canMakeRequest("writeSmsToSim", messagingProxy, result, RADIO_HAL_VERSION_1_4)) {
+        RadioMessagingProxy messagingProxy =
+                getRadioServiceProxy(RadioMessagingProxy.class);
+        if (messagingProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(messagingProxy, result);
             return;
         }
 
@@ -2756,8 +3005,10 @@ public class RIL extends BaseCommands implements CommandsInterface {
 
     @Override
     public void deleteSmsOnSim(int index, Message result) {
-        RadioMessagingProxy messagingProxy = getRadioServiceProxy(RadioMessagingProxy.class);
-        if (!canMakeRequest("deleteSmsOnSim", messagingProxy, result, RADIO_HAL_VERSION_1_4)) {
+        RadioMessagingProxy messagingProxy =
+                getRadioServiceProxy(RadioMessagingProxy.class);
+        if (messagingProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(messagingProxy, result);
             return;
         }
 
@@ -2776,7 +3027,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void setBandMode(int bandMode, Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("setBandMode", networkProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
 
@@ -2795,8 +3047,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void queryAvailableBandMode(Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("queryAvailableBandMode", networkProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
 
@@ -2815,7 +3067,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void sendEnvelope(String contents, Message result) {
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("sendEnvelope", simProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
 
@@ -2835,7 +3088,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void sendTerminalResponse(String contents, Message result) {
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("sendTerminalResponse", simProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
 
@@ -2857,7 +3111,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void sendEnvelopeWithStatus(String contents, Message result) {
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("sendEnvelopeWithStatus", simProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
 
@@ -2878,7 +3133,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void explicitCallTransfer(Message result) {
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("explicitCallTransfer", voiceProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
 
@@ -2897,8 +3153,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void setPreferredNetworkType(@PrefNetworkMode int networkType , Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("setPreferredNetworkType", networkProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
 
@@ -2920,8 +3176,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void getPreferredNetworkType(Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("getPreferredNetworkType", networkProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
 
@@ -2940,18 +3196,17 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void setAllowedNetworkTypesBitmap(
             @TelephonyManager.NetworkTypeBitMask int networkTypeBitmask, Message result) {
+        RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
+            return;
+        }
         if (mHalVersion.get(HAL_SERVICE_NETWORK).less(RADIO_HAL_VERSION_1_6)) {
             // For older HAL, redirects the call to setPreferredNetworkType.
             setPreferredNetworkType(
                     RadioAccessFamily.getNetworkTypeFromRaf(networkTypeBitmask), result);
             return;
         }
-        RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("setAllowedNetworkTypesBitmap", networkProxy, result,
-                RADIO_HAL_VERSION_1_6)) {
-            return;
-        }
-
         RILRequest rr = obtainRequest(RIL_REQUEST_SET_ALLOWED_NETWORK_TYPES_BITMAP, result,
                 mRILDefaultWorkSource);
 
@@ -2968,8 +3223,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void getAllowedNetworkTypesBitmap(Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("getAllowedNetworkTypesBitmap", networkProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
 
@@ -2988,7 +3243,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void setLocationUpdates(boolean enable, WorkSource workSource, Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("setLocationUpdates", networkProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
 
@@ -3011,21 +3267,31 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void isNrDualConnectivityEnabled(Message result, WorkSource workSource) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("isNrDualConnectivityEnabled", networkProxy, result,
-                RADIO_HAL_VERSION_1_6)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_NETWORK).greaterOrEqual(RADIO_HAL_VERSION_1_6)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_IS_NR_DUAL_CONNECTIVITY_ENABLED, result,
+                    getDefaultWorkSourceIfInvalid(workSource));
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_IS_NR_DUAL_CONNECTIVITY_ENABLED, result,
-                getDefaultWorkSourceIfInvalid(workSource));
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "isNrDualConnectivityEnabled", () -> {
+                networkProxy.isNrDualConnectivityEnabled(rr.mSerial);
+            });
+        } else {
+            if (RILJ_LOGD) {
+                Rlog.d(RILJ_LOG_TAG, "isNrDualConnectivityEnabled: REQUEST_NOT_SUPPORTED");
+            }
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "isNrDualConnectivityEnabled", () -> {
-            networkProxy.isNrDualConnectivityEnabled(rr.mSerial);
-        });
     }
 
     /**
@@ -3043,22 +3309,30 @@ public class RIL extends BaseCommands implements CommandsInterface {
     public void setNrDualConnectivityState(int nrDualConnectivityState, Message result,
             WorkSource workSource) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("setNrDualConnectivityState", networkProxy, result,
-                RADIO_HAL_VERSION_1_6)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_NETWORK).greaterOrEqual(RADIO_HAL_VERSION_1_6)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_ENABLE_NR_DUAL_CONNECTIVITY, result,
+                    getDefaultWorkSourceIfInvalid(workSource));
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_ENABLE_NR_DUAL_CONNECTIVITY, result,
-                getDefaultWorkSourceIfInvalid(workSource));
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
+                        + " enable = " + nrDualConnectivityState);
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
-                    + " enable = " + nrDualConnectivityState);
+            radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "setNrDualConnectivityState", () -> {
+                networkProxy.setNrDualConnectivityState(rr.mSerial, (byte) nrDualConnectivityState);
+            });
+        } else {
+            if (RILJ_LOGD) Rlog.d(RILJ_LOG_TAG, "enableNrDualConnectivity: REQUEST_NOT_SUPPORTED");
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "setNrDualConnectivityState", () -> {
-            networkProxy.setNrDualConnectivityState(rr.mSerial, (byte) nrDualConnectivityState);
-        });
     }
 
     private void setVoNrEnabled(boolean enabled) {
@@ -3075,26 +3349,28 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void isVoNrEnabled(Message result, WorkSource workSource) {
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        // Send null result so errors aren't sent in canMakeRequest
-        if (!canMakeRequest("isVoNrEnabled", voiceProxy, null, RADIO_HAL_VERSION_2_0)) {
-            boolean isEnabled = isVoNrEnabled();
-            if (result != null) {
-                AsyncResult.forMessage(result, isEnabled, null);
-                result.sendToTarget();
-            }
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_VOICE).greaterOrEqual(RADIO_HAL_VERSION_2_0)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_IS_VONR_ENABLED, result,
+                    getDefaultWorkSourceIfInvalid(workSource));
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_IS_VONR_ENABLED, result,
-                getDefaultWorkSourceIfInvalid(workSource));
-
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
-        }
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            }
 
-        radioServiceInvokeHelper(HAL_SERVICE_VOICE, rr, "isVoNrEnabled", () -> {
-            voiceProxy.isVoNrEnabled(rr.mSerial);
-        });
+            radioServiceInvokeHelper(HAL_SERVICE_VOICE, rr, "isVoNrEnabled", () -> {
+                voiceProxy.isVoNrEnabled(rr.mSerial);
+            });
+        } else {
+            boolean isEnabled = isVoNrEnabled();
+            if (result != null) {
+                AsyncResult.forMessage(result, isEnabled, null);
+                result.sendToTarget();
+            }
+        }
     }
 
     /**
@@ -3105,8 +3381,22 @@ public class RIL extends BaseCommands implements CommandsInterface {
     public void setVoNrEnabled(boolean enabled, Message result, WorkSource workSource) {
         setVoNrEnabled(enabled);
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        // Send null result so errors aren't sent in canMakeRequest
-        if (!canMakeRequest("setVoNrEnabled", voiceProxy, null, RADIO_HAL_VERSION_2_0)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
+            return;
+        }
+        if (mHalVersion.get(HAL_SERVICE_VOICE).greaterOrEqual(RADIO_HAL_VERSION_2_0)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_ENABLE_VONR, result,
+                    getDefaultWorkSourceIfInvalid(workSource));
+
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            }
+
+            radioServiceInvokeHelper(HAL_SERVICE_VOICE, rr, "setVoNrEnabled", () -> {
+                voiceProxy.setVoNrEnabled(rr.mSerial, enabled);
+            });
+        } else {
             /* calling a query api to let HAL know that VoNREnabled state is updated.
                This is a work around as new AIDL API is not allowed for older HAL version devices.
                HAL can check the value of PROPERTY_IS_VONR_ENABLED property to determine
@@ -3117,25 +3407,14 @@ public class RIL extends BaseCommands implements CommandsInterface {
                 AsyncResult.forMessage(result, null, null);
                 result.sendToTarget();
             }
-            return;
-        }
-
-        RILRequest rr = obtainRequest(RIL_REQUEST_ENABLE_VONR, result,
-                getDefaultWorkSourceIfInvalid(workSource));
-
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_VOICE, rr, "setVoNrEnabled", () -> {
-            voiceProxy.setVoNrEnabled(rr.mSerial, enabled);
-        });
     }
 
     @Override
     public void setCdmaSubscriptionSource(int cdmaSubscription, Message result) {
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("setCdmaSubscriptionSource", simProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
 
@@ -3155,8 +3434,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void queryCdmaRoamingPreference(Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("queryCdmaRoamingPreference", networkProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
 
@@ -3175,8 +3454,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void setCdmaRoamingPreference(int cdmaRoamingType, Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("setCdmaRoamingPreference", networkProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
 
@@ -3196,7 +3475,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void queryTTYMode(Message result) {
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("queryTTYMode", voiceProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
 
@@ -3214,7 +3494,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void setTTYMode(int ttyMode, Message result) {
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("setTTYMode", voiceProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
 
@@ -3233,8 +3514,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void setPreferredVoicePrivacy(boolean enable, Message result) {
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("setPreferredVoicePrivacy", voiceProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
 
@@ -3254,8 +3535,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void getPreferredVoicePrivacy(Message result) {
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("getPreferredVoicePrivacy", voiceProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
 
@@ -3274,7 +3555,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void sendCDMAFeatureCode(String featureCode, Message result) {
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("sendCDMAFeatureCode", voiceProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
 
@@ -3294,7 +3576,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void sendBurstDtmf(String dtmfString, int on, int off, Message result) {
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("sendBurstDtmf", voiceProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
 
@@ -3313,9 +3596,10 @@ public class RIL extends BaseCommands implements CommandsInterface {
 
     @Override
     public void sendCdmaSMSExpectMore(byte[] pdu, Message result) {
-        RadioMessagingProxy messagingProxy = getRadioServiceProxy(RadioMessagingProxy.class);
-        if (!canMakeRequest("sendCdmaSMSExpectMore", messagingProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        RadioMessagingProxy messagingProxy =
+                getRadioServiceProxy(RadioMessagingProxy.class);
+        if (messagingProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(messagingProxy, result);
             return;
         }
 
@@ -3339,8 +3623,10 @@ public class RIL extends BaseCommands implements CommandsInterface {
 
     @Override
     public void sendCdmaSms(byte[] pdu, Message result) {
-        RadioMessagingProxy messagingProxy = getRadioServiceProxy(RadioMessagingProxy.class);
-        if (!canMakeRequest("sendCdmaSms", messagingProxy, result, RADIO_HAL_VERSION_1_4)) {
+        RadioMessagingProxy messagingProxy =
+                getRadioServiceProxy(RadioMessagingProxy.class);
+        if (messagingProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(messagingProxy, result);
             return;
         }
 
@@ -3360,9 +3646,10 @@ public class RIL extends BaseCommands implements CommandsInterface {
 
     @Override
     public void acknowledgeLastIncomingCdmaSms(boolean success, int cause, Message result) {
-        RadioMessagingProxy messagingProxy = getRadioServiceProxy(RadioMessagingProxy.class);
-        if (!canMakeRequest("acknowledgeLastIncomingCdmaSms", messagingProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        RadioMessagingProxy messagingProxy =
+                getRadioServiceProxy(RadioMessagingProxy.class);
+        if (messagingProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(messagingProxy, result);
             return;
         }
 
@@ -3374,17 +3661,18 @@ public class RIL extends BaseCommands implements CommandsInterface {
                     + " success = " + success + " cause = " + cause);
         }
 
-        radioServiceInvokeHelper(HAL_SERVICE_MESSAGING, rr, "acknowledgeLastIncomingCdmaSms",
-                () -> {
+        radioServiceInvokeHelper(
+                HAL_SERVICE_MESSAGING, rr, "acknowledgeLastIncomingCdmaSms", () -> {
                     messagingProxy.acknowledgeLastIncomingCdmaSms(rr.mSerial, success, cause);
                 });
     }
 
     @Override
     public void getGsmBroadcastConfig(Message result) {
-        RadioMessagingProxy messagingProxy = getRadioServiceProxy(RadioMessagingProxy.class);
-        if (!canMakeRequest("getGsmBroadcastConfig", messagingProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        RadioMessagingProxy messagingProxy =
+                getRadioServiceProxy(RadioMessagingProxy.class);
+        if (messagingProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(messagingProxy, result);
             return;
         }
 
@@ -3402,9 +3690,10 @@ public class RIL extends BaseCommands implements CommandsInterface {
 
     @Override
     public void setGsmBroadcastConfig(SmsBroadcastConfigInfo[] config, Message result) {
-        RadioMessagingProxy messagingProxy = getRadioServiceProxy(RadioMessagingProxy.class);
-        if (!canMakeRequest("setGsmBroadcastConfig", messagingProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        RadioMessagingProxy messagingProxy =
+                getRadioServiceProxy(RadioMessagingProxy.class);
+        if (messagingProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(messagingProxy, result);
             return;
         }
 
@@ -3426,9 +3715,10 @@ public class RIL extends BaseCommands implements CommandsInterface {
 
     @Override
     public void setGsmBroadcastActivation(boolean activate, Message result) {
-        RadioMessagingProxy messagingProxy = getRadioServiceProxy(RadioMessagingProxy.class);
-        if (!canMakeRequest("setGsmBroadcastActivation", messagingProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        RadioMessagingProxy messagingProxy =
+                getRadioServiceProxy(RadioMessagingProxy.class);
+        if (messagingProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(messagingProxy, result);
             return;
         }
 
@@ -3447,9 +3737,10 @@ public class RIL extends BaseCommands implements CommandsInterface {
 
     @Override
     public void getCdmaBroadcastConfig(Message result) {
-        RadioMessagingProxy messagingProxy = getRadioServiceProxy(RadioMessagingProxy.class);
-        if (!canMakeRequest("getCdmaBroadcastConfig", messagingProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        RadioMessagingProxy messagingProxy =
+                getRadioServiceProxy(RadioMessagingProxy.class);
+        if (messagingProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(messagingProxy, result);
             return;
         }
 
@@ -3467,9 +3758,10 @@ public class RIL extends BaseCommands implements CommandsInterface {
 
     @Override
     public void setCdmaBroadcastConfig(CdmaSmsBroadcastConfigInfo[] configs, Message result) {
-        RadioMessagingProxy messagingProxy = getRadioServiceProxy(RadioMessagingProxy.class);
-        if (!canMakeRequest("setCdmaBroadcastConfig", messagingProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        RadioMessagingProxy messagingProxy =
+                getRadioServiceProxy(RadioMessagingProxy.class);
+        if (messagingProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(messagingProxy, result);
             return;
         }
 
@@ -3491,9 +3783,10 @@ public class RIL extends BaseCommands implements CommandsInterface {
 
     @Override
     public void setCdmaBroadcastActivation(boolean activate, Message result) {
-        RadioMessagingProxy messagingProxy = getRadioServiceProxy(RadioMessagingProxy.class);
-        if (!canMakeRequest("setCdmaBroadcastActivation", messagingProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        RadioMessagingProxy messagingProxy =
+                getRadioServiceProxy(RadioMessagingProxy.class);
+        if (messagingProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(messagingProxy, result);
             return;
         }
 
@@ -3513,7 +3806,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void getCDMASubscription(Message result) {
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("getCDMASubscription", simProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
 
@@ -3530,8 +3824,10 @@ public class RIL extends BaseCommands implements CommandsInterface {
 
     @Override
     public void writeSmsToRuim(int status, byte[] pdu, Message result) {
-        RadioMessagingProxy messagingProxy = getRadioServiceProxy(RadioMessagingProxy.class);
-        if (!canMakeRequest("writeSmsToRuim", messagingProxy, result, RADIO_HAL_VERSION_1_4)) {
+        RadioMessagingProxy messagingProxy =
+                getRadioServiceProxy(RadioMessagingProxy.class);
+        if (messagingProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(messagingProxy, result);
             return;
         }
 
@@ -3550,8 +3846,10 @@ public class RIL extends BaseCommands implements CommandsInterface {
 
     @Override
     public void deleteSmsOnRuim(int index, Message result) {
-        RadioMessagingProxy messagingProxy = getRadioServiceProxy(RadioMessagingProxy.class);
-        if (!canMakeRequest("deleteSmsOnRuim", messagingProxy, result, RADIO_HAL_VERSION_1_4)) {
+        RadioMessagingProxy messagingProxy =
+                getRadioServiceProxy(RadioMessagingProxy.class);
+        if (messagingProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(messagingProxy, result);
             return;
         }
 
@@ -3571,11 +3869,13 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void getDeviceIdentity(Message result) {
         RadioModemProxy modemProxy = getRadioServiceProxy(RadioModemProxy.class);
-        if (!canMakeRequest("getDeviceIdentity", modemProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (modemProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(modemProxy, result);
             return;
         }
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_DEVICE_IDENTITY, result, mRILDefaultWorkSource);
+        RILRequest rr = obtainRequest(RIL_REQUEST_DEVICE_IDENTITY, result,
+                mRILDefaultWorkSource);
 
         if (RILJ_LOGD) {
             riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
@@ -3589,26 +3889,38 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void getImei(Message result) {
         RadioModemProxy modemProxy = getRadioServiceProxy(RadioModemProxy.class);
-        if (!canMakeRequest("getImei", modemProxy, result, RADIO_HAL_VERSION_2_1)) {
+        if (modemProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(modemProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_MODEM).greaterOrEqual(RADIO_HAL_VERSION_2_1)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_DEVICE_IMEI, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_DEVICE_IMEI, result, mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            radioServiceInvokeHelper(HAL_SERVICE_MODEM, rr, "getImei", () -> {
+                modemProxy.getImei(rr.mSerial);
+            });
+        } else {
+            if (RILJ_LOGD) {
+                Rlog.e(RILJ_LOG_TAG, "getImei: REQUEST_NOT_SUPPORTED");
+            }
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_MODEM, rr, "getImei", () -> {
-            modemProxy.getImei(rr.mSerial);
-        });
     }
 
     @Override
     public void exitEmergencyCallbackMode(Message result) {
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("exitEmergencyCallbackMode", voiceProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
 
@@ -3626,12 +3938,15 @@ public class RIL extends BaseCommands implements CommandsInterface {
 
     @Override
     public void getSmscAddress(Message result) {
-        RadioMessagingProxy messagingProxy = getRadioServiceProxy(RadioMessagingProxy.class);
-        if (!canMakeRequest("getSmscAddress", messagingProxy, result, RADIO_HAL_VERSION_1_4)) {
+        RadioMessagingProxy messagingProxy =
+                getRadioServiceProxy(RadioMessagingProxy.class);
+        if (messagingProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(messagingProxy, result);
             return;
         }
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_GET_SMSC_ADDRESS, result, mRILDefaultWorkSource);
+        RILRequest rr = obtainRequest(RIL_REQUEST_GET_SMSC_ADDRESS, result,
+                mRILDefaultWorkSource);
 
         if (RILJ_LOGD) {
             riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
@@ -3644,8 +3959,10 @@ public class RIL extends BaseCommands implements CommandsInterface {
 
     @Override
     public void setSmscAddress(String address, Message result) {
-        RadioMessagingProxy messagingProxy = getRadioServiceProxy(RadioMessagingProxy.class);
-        if (!canMakeRequest("setSmscAddress", messagingProxy, result, RADIO_HAL_VERSION_1_4)) {
+        RadioMessagingProxy messagingProxy =
+                getRadioServiceProxy(RadioMessagingProxy.class);
+        if (messagingProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(messagingProxy, result);
             return;
         }
 
@@ -3657,15 +3974,17 @@ public class RIL extends BaseCommands implements CommandsInterface {
         }
 
         radioServiceInvokeHelper(HAL_SERVICE_MESSAGING, rr, "setSmscAddress", () -> {
-            messagingProxy.setSmscAddress(rr.mSerial, RILUtils.convertNullToEmptyString(address));
+            messagingProxy.setSmscAddress(rr.mSerial,
+                    RILUtils.convertNullToEmptyString(address));
         });
     }
 
     @Override
     public void reportSmsMemoryStatus(boolean available, Message result) {
-        RadioMessagingProxy messagingProxy = getRadioServiceProxy(RadioMessagingProxy.class);
-        if (!canMakeRequest("reportSmsMemoryStatus", messagingProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        RadioMessagingProxy messagingProxy =
+                getRadioServiceProxy(RadioMessagingProxy.class);
+        if (messagingProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(messagingProxy, result);
             return;
         }
 
@@ -3685,7 +4004,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void reportStkServiceIsRunning(Message result) {
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("reportStkServiceIsRunning", simProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
 
@@ -3704,7 +4024,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void getCdmaSubscriptionSource(Message result) {
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("getCdmaSubscriptionSource", simProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
 
@@ -3722,9 +4043,10 @@ public class RIL extends BaseCommands implements CommandsInterface {
 
     @Override
     public void acknowledgeIncomingGsmSmsWithPdu(boolean success, String ackPdu, Message result) {
-        RadioMessagingProxy messagingProxy = getRadioServiceProxy(RadioMessagingProxy.class);
-        if (!canMakeRequest("acknowledgeIncomingGsmSmsWithPdu", messagingProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        RadioMessagingProxy messagingProxy =
+                getRadioServiceProxy(RadioMessagingProxy.class);
+        if (messagingProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(messagingProxy, result);
             return;
         }
 
@@ -3736,8 +4058,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
                     + " success = " + success);
         }
 
-        radioServiceInvokeHelper(HAL_SERVICE_MESSAGING, rr, "acknowledgeIncomingGsmSmsWithPdu",
-                () -> {
+        radioServiceInvokeHelper(
+                HAL_SERVICE_MESSAGING, rr, "acknowledgeIncomingGsmSmsWithPdu", () -> {
                     messagingProxy.acknowledgeIncomingGsmSmsWithPdu(rr.mSerial, success,
                             RILUtils.convertNullToEmptyString(ackPdu));
                 });
@@ -3746,8 +4068,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void getVoiceRadioTechnology(Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("getVoiceRadioTechnology", networkProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
 
@@ -3765,7 +4087,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void getCellInfoList(Message result, WorkSource workSource) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("getCellInfoList", networkProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
 
@@ -3784,7 +4107,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void setCellInfoListRate(int rateInMillis, Message result, WorkSource workSource) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("setCellInfoListRate", networkProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
 
@@ -3802,10 +4126,10 @@ public class RIL extends BaseCommands implements CommandsInterface {
     }
 
     @Override
-    public void setInitialAttachApn(DataProfile dataProfile, boolean isRoaming /* unused */,
-            Message result) {
+    public void setInitialAttachApn(DataProfile dataProfile, boolean isRoaming, Message result) {
         RadioDataProxy dataProxy = getRadioServiceProxy(RadioDataProxy.class);
-        if (!canMakeRequest("setInitialAttachApn", dataProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (dataProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(dataProxy, result);
             return;
         }
 
@@ -3813,19 +4137,20 @@ public class RIL extends BaseCommands implements CommandsInterface {
                 mRILDefaultWorkSource);
 
         if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest) + dataProfile);
+            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
+                    + dataProfile);
         }
 
         radioServiceInvokeHelper(HAL_SERVICE_DATA, rr, "setInitialAttachApn", () -> {
-            dataProxy.setInitialAttachApn(rr.mSerial, dataProfile);
+            dataProxy.setInitialAttachApn(rr.mSerial, dataProfile, isRoaming);
         });
     }
 
     @Override
     public void getImsRegistrationState(Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("getImsRegistrationState", networkProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
 
@@ -3844,8 +4169,10 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void sendImsGsmSms(String smscPdu, String pdu, int retry, int messageRef,
             Message result) {
-        RadioMessagingProxy messagingProxy = getRadioServiceProxy(RadioMessagingProxy.class);
-        if (!canMakeRequest("sendImsGsmSms", messagingProxy, result, RADIO_HAL_VERSION_1_4)) {
+        RadioMessagingProxy messagingProxy =
+                getRadioServiceProxy(RadioMessagingProxy.class);
+        if (messagingProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(messagingProxy, result);
             return;
         }
 
@@ -3865,8 +4192,10 @@ public class RIL extends BaseCommands implements CommandsInterface {
 
     @Override
     public void sendImsCdmaSms(byte[] pdu, int retry, int messageRef, Message result) {
-        RadioMessagingProxy messagingProxy = getRadioServiceProxy(RadioMessagingProxy.class);
-        if (!canMakeRequest("sendImsCdmaSms", messagingProxy, result, RADIO_HAL_VERSION_1_4)) {
+        RadioMessagingProxy messagingProxy =
+                getRadioServiceProxy(RadioMessagingProxy.class);
+        if (messagingProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(messagingProxy, result);
             return;
         }
 
@@ -3888,8 +4217,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     public void iccTransmitApduBasicChannel(int cla, int instruction, int p1, int p2, int p3,
             String data, Message result) {
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("iccTransmitApduBasicChannel", simProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
 
@@ -3908,14 +4237,16 @@ public class RIL extends BaseCommands implements CommandsInterface {
         }
 
         radioServiceInvokeHelper(HAL_SERVICE_SIM, rr, "iccTransmitApduBasicChannel", () -> {
-            simProxy.iccTransmitApduBasicChannel(rr.mSerial, cla, instruction, p1, p2, p3, data);
+            simProxy.iccTransmitApduBasicChannel(
+                    rr.mSerial, cla, instruction, p1, p2, p3, data);
         });
     }
 
     @Override
     public void iccOpenLogicalChannel(String aid, int p2, Message result) {
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("iccOpenLogicalChannel", simProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
 
@@ -3931,14 +4262,16 @@ public class RIL extends BaseCommands implements CommandsInterface {
         }
 
         radioServiceInvokeHelper(HAL_SERVICE_SIM, rr, "iccOpenLogicalChannel", () -> {
-            simProxy.iccOpenLogicalChannel(rr.mSerial, RILUtils.convertNullToEmptyString(aid), p2);
+            simProxy.iccOpenLogicalChannel(rr.mSerial, RILUtils.convertNullToEmptyString(aid),
+                    p2);
         });
     }
 
     @Override
     public void iccCloseLogicalChannel(int channel, boolean isEs10, Message result) {
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("iccCloseLogicalChannel", simProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
 
@@ -3962,8 +4295,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
         }
 
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("iccTransmitApduLogicalChannel", simProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
 
@@ -3984,15 +4317,16 @@ public class RIL extends BaseCommands implements CommandsInterface {
         }
 
         radioServiceInvokeHelper(HAL_SERVICE_SIM, rr, "iccTransmitApduLogicalChannel", () -> {
-            simProxy.iccTransmitApduLogicalChannel(rr.mSerial, channel, cla, instruction, p1, p2,
-                    p3, data, isEs10Command);
+            simProxy.iccTransmitApduLogicalChannel(
+                    rr.mSerial, channel, cla, instruction, p1, p2, p3, data, isEs10Command);
         });
     }
 
     @Override
     public void nvReadItem(int itemID, Message result, WorkSource workSource) {
         RadioModemProxy modemProxy = getRadioServiceProxy(RadioModemProxy.class);
-        if (!canMakeRequest("nvReadItem", modemProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (modemProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(modemProxy, result);
             return;
         }
 
@@ -4012,7 +4346,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void nvWriteItem(int itemId, String itemValue, Message result, WorkSource workSource) {
         RadioModemProxy modemProxy = getRadioServiceProxy(RadioModemProxy.class);
-        if (!canMakeRequest("nvWriteItem", modemProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (modemProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(modemProxy, result);
             return;
         }
 
@@ -4033,7 +4368,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void nvWriteCdmaPrl(byte[] preferredRoamingList, Message result) {
         RadioModemProxy modemProxy = getRadioServiceProxy(RadioModemProxy.class);
-        if (!canMakeRequest("nvWriteCdmaPrl", modemProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (modemProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(modemProxy, result);
             return;
         }
 
@@ -4053,7 +4389,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void nvResetConfig(int resetType, Message result) {
         RadioModemProxy modemProxy = getRadioServiceProxy(RadioModemProxy.class);
-        if (!canMakeRequest("nvResetConfig", modemProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (modemProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(modemProxy, result);
             return;
         }
 
@@ -4073,7 +4410,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     public void setUiccSubscription(int slotId, int appIndex, int subId, int subStatus,
             Message result) {
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("setUiccSubscription", simProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
 
@@ -4098,14 +4436,17 @@ public class RIL extends BaseCommands implements CommandsInterface {
      */
     @Override
     public boolean supportsEid() {
-        // TODO(b/280900995): remove this and references
-        return true;
+        // EID should be supported as long as HAL >= 1.2.
+        //  - in HAL 1.2 we have EID through ATR
+        //  - in later HAL versions we also have EID through slot / card status.
+        return mHalVersion.get(HAL_SERVICE_RADIO).greaterOrEqual(RADIO_HAL_VERSION_1_2);
     }
 
     @Override
     public void setDataAllowed(boolean allowed, Message result) {
         RadioDataProxy dataProxy = getRadioServiceProxy(RadioDataProxy.class);
-        if (!canMakeRequest("setDataAllowed", dataProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (dataProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(dataProxy, result);
             return;
         }
 
@@ -4124,7 +4465,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void getHardwareConfig(Message result) {
         RadioModemProxy modemProxy = getRadioServiceProxy(RadioModemProxy.class);
-        if (!canMakeRequest("getHardwareConfig", modemProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (modemProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(modemProxy, result);
             return;
         }
 
@@ -4145,8 +4487,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     public void requestIccSimAuthentication(int authContext, String data, String aid,
             Message result) {
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("requestIccSimAuthentication", simProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
 
@@ -4166,9 +4508,10 @@ public class RIL extends BaseCommands implements CommandsInterface {
     }
 
     @Override
-    public void setDataProfile(DataProfile[] dps, boolean isRoaming /* unused */, Message result) {
+    public void setDataProfile(DataProfile[] dps, boolean isRoaming, Message result) {
         RadioDataProxy dataProxy = getRadioServiceProxy(RadioDataProxy.class);
-        if (!canMakeRequest("setDataProfile", dataProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (dataProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(dataProxy, result);
             return;
         }
 
@@ -4183,14 +4526,15 @@ public class RIL extends BaseCommands implements CommandsInterface {
         }
 
         radioServiceInvokeHelper(HAL_SERVICE_DATA, rr, "setDataProfile", () -> {
-            dataProxy.setDataProfile(rr.mSerial, dps);
+            dataProxy.setDataProfile(rr.mSerial, dps, isRoaming);
         });
     }
 
     @Override
     public void requestShutdown(Message result) {
         RadioModemProxy modemProxy = getRadioServiceProxy(RadioModemProxy.class);
-        if (!canMakeRequest("requestShutdown", modemProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (modemProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(modemProxy, result);
             return;
         }
 
@@ -4208,7 +4552,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void getRadioCapability(Message result) {
         RadioModemProxy modemProxy = getRadioServiceProxy(RadioModemProxy.class);
-        if (!canMakeRequest("getRadioCapability", modemProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (modemProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(modemProxy, result);
             return;
         }
 
@@ -4227,7 +4572,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void setRadioCapability(RadioCapability rc, Message result) {
         RadioModemProxy modemProxy = getRadioServiceProxy(RadioModemProxy.class);
-        if (!canMakeRequest("setRadioCapability", modemProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (modemProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(modemProxy, result);
             return;
         }
 
@@ -4246,12 +4592,65 @@ public class RIL extends BaseCommands implements CommandsInterface {
 
     @Override
     public void startLceService(int reportIntervalMs, boolean pullMode, Message result) {
-        // TODO(b/280900995): remove this and references
+        if (mHalVersion.get(HAL_SERVICE_RADIO).greaterOrEqual(RADIO_HAL_VERSION_1_2)) {
+            // We have a 1.2 or later radio, so the LCE 1.0 LCE service control path is unused.
+            // Instead the LCE functionality is always-on and provides unsolicited indications.
+            if (RILJ_LOGD) Rlog.d(RILJ_LOG_TAG, "startLceService: REQUEST_NOT_SUPPORTED");
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
+            return;
+        }
+
+        IRadio radioProxy = getRadioProxy();
+        if (radioProxy == null) {
+            handleRadioProxyNotAvailable(result);
+            return;
+        }
+
+        RILRequest rr = obtainRequest(RIL_REQUEST_START_LCE, result, mRILDefaultWorkSource);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
+                    + " reportIntervalMs = " + reportIntervalMs + " pullMode = " + pullMode);
+        }
+
+        radioServiceInvokeHelper(HAL_SERVICE_RADIO, rr, "startLceService", () -> {
+            radioProxy.startLceService(rr.mSerial, reportIntervalMs, pullMode);
+        });
     }
 
     @Override
     public void stopLceService(Message result) {
-        // TODO(b/280900995): remove this and references
+        if (mHalVersion.get(HAL_SERVICE_RADIO).greaterOrEqual(RADIO_HAL_VERSION_1_2)) {
+            // We have a 1.2 or later radio, so the LCE 1.0 LCE service control is unused.
+            // Instead the LCE functionality is always-on and provides unsolicited indications.
+            if (RILJ_LOGD) Rlog.d(RILJ_LOG_TAG, "stopLceService: REQUEST_NOT_SUPPORTED");
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
+            return;
+        }
+
+        IRadio radioProxy = getRadioProxy();
+        if (radioProxy == null) {
+            handleRadioProxyNotAvailable(result);
+            return;
+        }
+
+        RILRequest rr = obtainRequest(RIL_REQUEST_STOP_LCE, result, mRILDefaultWorkSource);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+        }
+
+        radioServiceInvokeHelper(HAL_SERVICE_RADIO, rr, "stopLceService", () -> {
+            radioProxy.stopLceService(rr.mSerial);
+        });
     }
 
     /**
@@ -4267,23 +4666,33 @@ public class RIL extends BaseCommands implements CommandsInterface {
     public void setDataThrottling(Message result, WorkSource workSource, int dataThrottlingAction,
             long completionWindowMillis) {
         RadioDataProxy dataProxy = getRadioServiceProxy(RadioDataProxy.class);
-        if (!canMakeRequest("setDataThrottling", dataProxy, result, RADIO_HAL_VERSION_1_6)) {
+        if (dataProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(dataProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_DATA).greaterOrEqual(RADIO_HAL_VERSION_1_6)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_SET_DATA_THROTTLING, result,
+                    getDefaultWorkSourceIfInvalid(workSource));
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_SET_DATA_THROTTLING, result,
-                getDefaultWorkSourceIfInvalid(workSource));
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> "
+                        + RILUtils.requestToString(rr.mRequest)
+                        + " dataThrottlingAction = " + dataThrottlingAction
+                        + " completionWindowMillis " + completionWindowMillis);
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
-                    + " dataThrottlingAction = " + dataThrottlingAction
-                    + " completionWindowMillis " + completionWindowMillis);
+            radioServiceInvokeHelper(HAL_SERVICE_DATA, rr, "setDataThrottling", () -> {
+                dataProxy.setDataThrottling(rr.mSerial, (byte) dataThrottlingAction,
+                        completionWindowMillis);
+            });
+        } else {
+            if (RILJ_LOGD) Rlog.d(RILJ_LOG_TAG, "setDataThrottling: REQUEST_NOT_SUPPORTED");
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_DATA, rr, "setDataThrottling", () -> {
-            dataProxy.setDataThrottling(rr.mSerial, (byte) dataThrottlingAction,
-                    completionWindowMillis);
-        });
     }
 
     /**
@@ -4299,13 +4708,40 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Deprecated
     @Override
     public void pullLceData(Message result) {
-        // TODO(b/280900995): remove this and references
+        if (mHalVersion.get(HAL_SERVICE_RADIO).greaterOrEqual(RADIO_HAL_VERSION_1_2)) {
+            // We have a 1.2 or later radio, so the LCE 1.0 LCE service control path is unused.
+            // Instead the LCE functionality is always-on and provides unsolicited indications.
+            if (RILJ_LOGD) Rlog.d(RILJ_LOG_TAG, "pullLceData: REQUEST_NOT_SUPPORTED");
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
+            return;
+        }
+
+        IRadio radioProxy = getRadioProxy();
+        if (radioProxy == null) {
+            handleRadioProxyNotAvailable(result);
+            return;
+        }
+
+        RILRequest rr = obtainRequest(RIL_REQUEST_PULL_LCEDATA, result, mRILDefaultWorkSource);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+        }
+
+        radioServiceInvokeHelper(HAL_SERVICE_RADIO, rr, "pullLceData", () -> {
+            radioProxy.pullLceData(rr.mSerial);
+        });
     }
 
     @Override
     public void getModemActivityInfo(Message result, WorkSource workSource) {
         RadioModemProxy modemProxy = getRadioServiceProxy(RadioModemProxy.class);
-        if (!canMakeRequest("getModemActivityInfo", modemProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (modemProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(modemProxy, result);
             return;
         }
 
@@ -4318,7 +4754,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
 
         radioServiceInvokeHelper(HAL_SERVICE_MODEM, rr, "getModemActivityInfo", () -> {
             modemProxy.getModemActivityInfo(rr.mSerial);
-            Message msg = mRilHandler.obtainMessage(EVENT_BLOCKING_RESPONSE_TIMEOUT, rr.mSerial);
+            Message msg =
+                    mRilHandler.obtainMessage(EVENT_BLOCKING_RESPONSE_TIMEOUT, rr.mSerial);
             mRilHandler.sendMessageDelayed(msg, DEFAULT_BLOCKING_MESSAGE_RESPONSE_TIMEOUT_MS);
         });
     }
@@ -4329,7 +4766,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
         Objects.requireNonNull(carrierRestrictionRules, "Carrier restriction cannot be null.");
 
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("setAllowedCarriers", simProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
 
@@ -4342,14 +4780,15 @@ public class RIL extends BaseCommands implements CommandsInterface {
         }
 
         radioServiceInvokeHelper(HAL_SERVICE_SIM, rr, "setAllowedCarriers", () -> {
-            simProxy.setAllowedCarriers(rr.mSerial, carrierRestrictionRules);
+            simProxy.setAllowedCarriers(rr.mSerial, carrierRestrictionRules, result);
         });
     }
 
     @Override
     public void getAllowedCarriers(Message result, WorkSource workSource) {
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("getAllowedCarriers", simProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
 
@@ -4368,7 +4807,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void sendDeviceState(int stateType, boolean state, Message result) {
         RadioModemProxy modemProxy = getRadioServiceProxy(RadioModemProxy.class);
-        if (!canMakeRequest("sendDeviceState", modemProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (modemProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(modemProxy, result);
             return;
         }
 
@@ -4387,8 +4827,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void setUnsolResponseFilter(int filter, Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("setUnsolResponseFilter", networkProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
 
@@ -4409,23 +4849,26 @@ public class RIL extends BaseCommands implements CommandsInterface {
     public void setSignalStrengthReportingCriteria(
             @NonNull List<SignalThresholdInfo> signalThresholdInfos, @Nullable Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("setSignalStrengthReportingCriteria", networkProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_NETWORK).greaterOrEqual(RADIO_HAL_VERSION_1_2)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_SET_SIGNAL_STRENGTH_REPORTING_CRITERIA,
+                    result, mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_SET_SIGNAL_STRENGTH_REPORTING_CRITERIA, result,
-                mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            radioServiceInvokeHelper(
+                    HAL_SERVICE_NETWORK, rr, "setSignalStrengthReportingCriteria", () -> {
+                        networkProxy.setSignalStrengthReportingCriteria(rr.mSerial,
+                                signalThresholdInfos);
+                    });
+        } else {
+            riljLoge("setSignalStrengthReportingCriteria ignored on IRadio version less than 1.2");
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "setSignalStrengthReportingCriteria",
-                () -> {
-                    networkProxy.setSignalStrengthReportingCriteria(rr.mSerial,
-                            signalThresholdInfos);
-                });
     }
 
     @Override
@@ -4433,30 +4876,35 @@ public class RIL extends BaseCommands implements CommandsInterface {
             int hysteresisUlKbps, int[] thresholdsDlKbps, int[] thresholdsUlKbps, int ran,
             Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("setLinkCapacityReportingCriteria", networkProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_NETWORK).greaterOrEqual(RADIO_HAL_VERSION_1_2)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_SET_LINK_CAPACITY_REPORTING_CRITERIA, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_SET_LINK_CAPACITY_REPORTING_CRITERIA, result,
-                mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            radioServiceInvokeHelper(
+                    HAL_SERVICE_NETWORK, rr, "setLinkCapacityReportingCriteria", () -> {
+                        networkProxy.setLinkCapacityReportingCriteria(rr.mSerial, hysteresisMs,
+                                hysteresisDlKbps, hysteresisUlKbps, thresholdsDlKbps,
+                                thresholdsUlKbps,
+                                ran);
+                    });
+        } else {
+            riljLoge("setLinkCapacityReportingCriteria ignored on IRadio version less than 1.2");
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "setLinkCapacityReportingCriteria",
-                () -> {
-                    networkProxy.setLinkCapacityReportingCriteria(rr.mSerial, hysteresisMs,
-                            hysteresisDlKbps, hysteresisUlKbps, thresholdsDlKbps, thresholdsUlKbps,
-                            ran);
-                });
     }
 
     @Override
     public void setSimCardPower(int state, Message result, WorkSource workSource) {
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("setSimCardPower", simProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
 
@@ -4469,7 +4917,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
         }
 
         radioServiceInvokeHelper(HAL_SERVICE_SIM, rr, "setSimCardPower", () -> {
-            simProxy.setSimCardPower(rr.mSerial, state);
+            simProxy.setSimCardPower(rr.mSerial, state, result);
         });
     }
 
@@ -4478,20 +4926,30 @@ public class RIL extends BaseCommands implements CommandsInterface {
             Message result) {
         Objects.requireNonNull(imsiEncryptionInfo, "ImsiEncryptionInfo cannot be null.");
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("setCarrierInfoForImsiEncryption", simProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_SIM).greaterOrEqual(RADIO_HAL_VERSION_1_1)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_SET_CARRIER_INFO_IMSI_ENCRYPTION, result,
+                    mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            }
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_SET_CARRIER_INFO_IMSI_ENCRYPTION, result,
-                mRILDefaultWorkSource);
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            radioServiceInvokeHelper(HAL_SERVICE_SIM, rr, "setCarrierInfoForImsiEncryption", () -> {
+                simProxy.setCarrierInfoForImsiEncryption(rr.mSerial, imsiEncryptionInfo);
+            });
+        } else {
+            if (RILJ_LOGD) {
+                Rlog.d(RILJ_LOG_TAG, "setCarrierInfoForImsiEncryption: REQUEST_NOT_SUPPORTED");
+            }
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_SIM, rr, "setCarrierInfoForImsiEncryption", () -> {
-            simProxy.setCarrierInfoForImsiEncryption(rr.mSerial, imsiEncryptionInfo);
-        });
     }
 
     @Override
@@ -4499,47 +4957,67 @@ public class RIL extends BaseCommands implements CommandsInterface {
             int intervalMillis, Message result) {
         Objects.requireNonNull(packetData, "KeepaliveRequest cannot be null.");
         RadioDataProxy dataProxy = getRadioServiceProxy(RadioDataProxy.class);
-        if (!canMakeRequest("startNattKeepalive", dataProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (dataProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(dataProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_DATA).greaterOrEqual(RADIO_HAL_VERSION_1_1)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_START_KEEPALIVE, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_START_KEEPALIVE, result, mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            radioServiceInvokeHelper(HAL_SERVICE_DATA, rr, "startNattKeepalive", () -> {
+                dataProxy.startKeepalive(rr.mSerial, contextId, packetData, intervalMillis, result);
+            });
+        } else {
+            if (RILJ_LOGD) Rlog.d(RILJ_LOG_TAG, "startNattKeepalive: REQUEST_NOT_SUPPORTED");
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_DATA, rr, "startNattKeepalive", () -> {
-            dataProxy.startKeepalive(rr.mSerial, contextId, packetData, intervalMillis, result);
-        });
     }
 
     @Override
     public void stopNattKeepalive(int sessionHandle, Message result) {
         RadioDataProxy dataProxy = getRadioServiceProxy(RadioDataProxy.class);
-        if (!canMakeRequest("stopNattKeepalive", dataProxy, result, RADIO_HAL_VERSION_1_4)) {
+        if (dataProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(dataProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_DATA).greaterOrEqual(RADIO_HAL_VERSION_1_1)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_STOP_KEEPALIVE, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_STOP_KEEPALIVE, result, mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            radioServiceInvokeHelper(HAL_SERVICE_DATA, rr, "stopNattKeepalive", () -> {
+                dataProxy.stopKeepalive(rr.mSerial, sessionHandle);
+            });
+        } else {
+            if (RILJ_LOGD) Rlog.d(RILJ_LOG_TAG, "stopNattKeepalive: REQUEST_NOT_SUPPORTED");
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_DATA, rr, "stopNattKeepalive", () -> {
-            dataProxy.stopKeepalive(rr.mSerial, sessionHandle);
-        });
     }
 
     @Override
     public void getIMEI(Message result) {
-        // TODO(b/280900995): remove this and references
+        throw new RuntimeException("getIMEI not expected to be called");
     }
 
     @Override
     public void getIMEISV(Message result) {
-        // TODO(b/280900995): remove this and references
+        throw new RuntimeException("getIMEISV not expected to be called");
     }
 
     /**
@@ -4548,7 +5026,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Deprecated
     @Override
     public void getLastPdpFailCause(Message result) {
-        // TODO(b/280900995): remove this and references
+        throw new RuntimeException("getLastPdpFailCause not expected to be called");
     }
 
     /**
@@ -4556,7 +5034,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
      */
     @Override
     public void getLastDataCallFailCause(Message result) {
-        // TODO(b/280900995): remove this and references
+        throw new RuntimeException("getLastDataCallFailCause not expected to be called");
     }
 
     /**
@@ -4568,21 +5046,30 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void enableUiccApplications(boolean enable, Message result) {
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("enableUiccApplications", simProxy, result, RADIO_HAL_VERSION_1_5)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_SIM).greaterOrEqual(RADIO_HAL_VERSION_1_5)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_ENABLE_UICC_APPLICATIONS, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_ENABLE_UICC_APPLICATIONS, result,
-                mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
+                        + " " + enable);
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
-                    + " " + enable);
+            radioServiceInvokeHelper(HAL_SERVICE_SIM, rr, "enableUiccApplications", () -> {
+                simProxy.enableUiccApplications(rr.mSerial, enable);
+            });
+        } else {
+            if (RILJ_LOGD) Rlog.d(RILJ_LOG_TAG, "enableUiccApplications: REQUEST_NOT_SUPPORTED");
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_SIM, rr, "enableUiccApplications", () -> {
-            simProxy.enableUiccApplications(rr.mSerial, enable);
-        });
     }
 
     /**
@@ -4593,21 +5080,31 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void areUiccApplicationsEnabled(Message result) {
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("areUiccApplicationsEnabled", simProxy, result,
-                RADIO_HAL_VERSION_1_5)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_SIM).greaterOrEqual(RADIO_HAL_VERSION_1_5)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_GET_UICC_APPLICATIONS_ENABLEMENT, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_GET_UICC_APPLICATIONS_ENABLEMENT, result,
-                mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            radioServiceInvokeHelper(HAL_SERVICE_SIM, rr, "areUiccApplicationsEnabled", () -> {
+                simProxy.areUiccApplicationsEnabled(rr.mSerial);
+            });
+        } else {
+            if (RILJ_LOGD) {
+                Rlog.d(RILJ_LOG_TAG, "areUiccApplicationsEnabled: REQUEST_NOT_SUPPORTED");
+            }
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_SIM, rr, "areUiccApplicationsEnabled", () -> {
-            simProxy.areUiccApplicationsEnabled(rr.mSerial);
-        });
     }
 
     /**
@@ -4615,13 +5112,13 @@ public class RIL extends BaseCommands implements CommandsInterface {
      */
     @Override
     public boolean canToggleUiccApplicationsEnablement() {
-        return canMakeRequest("canToggleUiccApplicationsEnablement",
-                getRadioServiceProxy(RadioSimProxy.class), null, RADIO_HAL_VERSION_1_5);
+        return !getRadioServiceProxy(RadioSimProxy.class).isEmpty()
+                && mHalVersion.get(HAL_SERVICE_SIM).greaterOrEqual(RADIO_HAL_VERSION_1_5);
     }
 
     @Override
     public void resetRadio(Message result) {
-        // TODO(b/280900995): remove this and references
+        throw new RuntimeException("resetRadio not expected to be called");
     }
 
     /**
@@ -4630,8 +5127,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void handleCallSetupRequestFromSim(boolean accept, Message result) {
         RadioVoiceProxy voiceProxy = getRadioServiceProxy(RadioVoiceProxy.class);
-        if (!canMakeRequest("handleCallSetupRequestFromSim", voiceProxy, result,
-                RADIO_HAL_VERSION_1_4)) {
+        if (voiceProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(voiceProxy, result);
             return;
         }
 
@@ -4653,19 +5150,29 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void getBarringInfo(Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("getBarringInfo", networkProxy, result, RADIO_HAL_VERSION_1_5)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_NETWORK).greaterOrEqual(RADIO_HAL_VERSION_1_5)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_GET_BARRING_INFO, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_GET_BARRING_INFO, result, mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "getBarringInfo", () -> {
+                networkProxy.getBarringInfo(rr.mSerial);
+            });
+        } else {
+            if (RILJ_LOGD) Rlog.d(RILJ_LOG_TAG, "getBarringInfo: REQUEST_NOT_SUPPORTED");
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "getBarringInfo", () -> {
-            networkProxy.getBarringInfo(rr.mSerial);
-        });
     }
 
     /**
@@ -4674,19 +5181,26 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void allocatePduSessionId(Message result) {
         RadioDataProxy dataProxy = getRadioServiceProxy(RadioDataProxy.class);
-        if (!canMakeRequest("allocatePduSessionId", dataProxy, result, RADIO_HAL_VERSION_1_6)) {
+        if (dataProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(dataProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_DATA).greaterOrEqual(RADIO_HAL_VERSION_1_6)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_ALLOCATE_PDU_SESSION_ID, result,
+                    mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            }
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_ALLOCATE_PDU_SESSION_ID, result,
-                mRILDefaultWorkSource);
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            radioServiceInvokeHelper(HAL_SERVICE_DATA, rr, "allocatePduSessionId", () -> {
+                dataProxy.allocatePduSessionId(rr.mSerial);
+            });
+        } else {
+            if (RILJ_LOGD) Rlog.d(RILJ_LOG_TAG, "allocatePduSessionId: REQUEST_NOT_SUPPORTED");
+            AsyncResult.forMessage(result, null,
+                    CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+            result.sendToTarget();
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_DATA, rr, "allocatePduSessionId", () -> {
-            dataProxy.allocatePduSessionId(rr.mSerial);
-        });
     }
 
     /**
@@ -4695,19 +5209,26 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void releasePduSessionId(Message result, int pduSessionId) {
         RadioDataProxy dataProxy = getRadioServiceProxy(RadioDataProxy.class);
-        if (!canMakeRequest("releasePduSessionId", dataProxy, result, RADIO_HAL_VERSION_1_6)) {
+        if (dataProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(dataProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_DATA).greaterOrEqual(RADIO_HAL_VERSION_1_6)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_RELEASE_PDU_SESSION_ID, result,
+                    mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            }
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_RELEASE_PDU_SESSION_ID, result,
-                mRILDefaultWorkSource);
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            radioServiceInvokeHelper(HAL_SERVICE_DATA, rr, "releasePduSessionId", () -> {
+                dataProxy.releasePduSessionId(rr.mSerial, pduSessionId);
+            });
+        } else {
+            if (RILJ_LOGD) Rlog.d(RILJ_LOG_TAG, "releasePduSessionId: REQUEST_NOT_SUPPORTED");
+            AsyncResult.forMessage(result, null,
+                    CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+            result.sendToTarget();
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_DATA, rr, "releasePduSessionId", () -> {
-            dataProxy.releasePduSessionId(rr.mSerial, pduSessionId);
-        });
     }
 
     /**
@@ -4716,18 +5237,28 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void startHandover(Message result, int callId) {
         RadioDataProxy dataProxy = getRadioServiceProxy(RadioDataProxy.class);
-        if (!canMakeRequest("startHandover", dataProxy, result, RADIO_HAL_VERSION_1_6)) {
+        if (dataProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(dataProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_DATA).greaterOrEqual(RADIO_HAL_VERSION_1_6)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_START_HANDOVER, result,
+                    mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            }
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_START_HANDOVER, result, mRILDefaultWorkSource);
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
-        }
-
-        radioServiceInvokeHelper(HAL_SERVICE_DATA, rr, "startHandover", () -> {
-            dataProxy.startHandover(rr.mSerial, callId);
-        });
+            radioServiceInvokeHelper(HAL_SERVICE_DATA, rr, "startHandover", () -> {
+                dataProxy.startHandover(rr.mSerial, callId);
+            });
+        } else {
+            if (RILJ_LOGD) Rlog.d(RILJ_LOG_TAG, "startHandover: REQUEST_NOT_SUPPORTED");
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
+        }
     }
 
     /**
@@ -4736,18 +5267,26 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void cancelHandover(Message result, int callId) {
         RadioDataProxy dataProxy = getRadioServiceProxy(RadioDataProxy.class);
-        if (!canMakeRequest("cancelHandover", dataProxy, result, RADIO_HAL_VERSION_1_6)) {
+        if (dataProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(dataProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_DATA).greaterOrEqual(RADIO_HAL_VERSION_1_6)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_CANCEL_HANDOVER, result,
+                    mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            }
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_CANCEL_HANDOVER, result, mRILDefaultWorkSource);
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            radioServiceInvokeHelper(HAL_SERVICE_DATA, rr, "cancelHandover", () -> {
+                dataProxy.cancelHandover(rr.mSerial, callId);
+            });
+        } else {
+            if (RILJ_LOGD) Rlog.d(RILJ_LOG_TAG, "cancelHandover: REQUEST_NOT_SUPPORTED");
+            AsyncResult.forMessage(result, null,
+                    CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+            result.sendToTarget();
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_DATA, rr, "cancelHandover", () -> {
-            dataProxy.cancelHandover(rr.mSerial, callId);
-        });
     }
 
     /**
@@ -4756,78 +5295,118 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void getSlicingConfig(Message result) {
         RadioDataProxy dataProxy = getRadioServiceProxy(RadioDataProxy.class);
-        if (!canMakeRequest("getSlicingConfig", dataProxy, result, RADIO_HAL_VERSION_1_6)) {
+        if (dataProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(dataProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_DATA).greaterOrEqual(RADIO_HAL_VERSION_1_6)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_GET_SLICING_CONFIG, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_GET_SLICING_CONFIG, result,
-                mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            radioServiceInvokeHelper(HAL_SERVICE_DATA, rr, "getSlicingConfig", () -> {
+                dataProxy.getSlicingConfig(rr.mSerial);
+            });
+        } else {
+            if (RILJ_LOGD) Rlog.d(RILJ_LOG_TAG, "getSlicingConfig: REQUEST_NOT_SUPPORTED");
+            AsyncResult.forMessage(result, null,
+                    CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+            result.sendToTarget();
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_DATA, rr, "getSlicingConfig", () -> {
-            dataProxy.getSlicingConfig(rr.mSerial);
-        });
     }
 
     @Override
     public void getSimPhonebookRecords(Message result) {
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("getSimPhonebookRecords", simProxy, result, RADIO_HAL_VERSION_1_6)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_SIM).greaterOrEqual(RADIO_HAL_VERSION_1_6)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_GET_SIM_PHONEBOOK_RECORDS, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_GET_SIM_PHONEBOOK_RECORDS, result,
-                mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            radioServiceInvokeHelper(HAL_SERVICE_SIM, rr, "getSimPhonebookRecords", () -> {
+                simProxy.getSimPhonebookRecords(rr.mSerial);
+            });
+        } else {
+            if (RILJ_LOGD) {
+                Rlog.d(RILJ_LOG_TAG, "getSimPhonebookRecords: REQUEST_NOT_SUPPORTED");
+            }
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_SIM, rr, "getSimPhonebookRecords", () -> {
-            simProxy.getSimPhonebookRecords(rr.mSerial);
-        });
     }
 
     @Override
     public void getSimPhonebookCapacity(Message result) {
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("getSimPhonebookCapacity", simProxy, result, RADIO_HAL_VERSION_1_6)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_SIM).greaterOrEqual(RADIO_HAL_VERSION_1_6)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_GET_SIM_PHONEBOOK_CAPACITY, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_GET_SIM_PHONEBOOK_CAPACITY, result,
-                mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            radioServiceInvokeHelper(HAL_SERVICE_SIM, rr, "getSimPhonebookCapacity", () -> {
+                simProxy.getSimPhonebookCapacity(rr.mSerial);
+            });
+        } else {
+            if (RILJ_LOGD) {
+                Rlog.d(RILJ_LOG_TAG, "getSimPhonebookCapacity: REQUEST_NOT_SUPPORTED");
+            }
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_SIM, rr, "getSimPhonebookCapacity", () -> {
-            simProxy.getSimPhonebookCapacity(rr.mSerial);
-        });
     }
 
     @Override
     public void updateSimPhonebookRecord(SimPhonebookRecord phonebookRecord, Message result) {
         RadioSimProxy simProxy = getRadioServiceProxy(RadioSimProxy.class);
-        if (!canMakeRequest("updateSimPhonebookRecord", simProxy, result, RADIO_HAL_VERSION_1_6)) {
+        if (simProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(simProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_SIM).greaterOrEqual(RADIO_HAL_VERSION_1_6)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_UPDATE_SIM_PHONEBOOK_RECORD, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_UPDATE_SIM_PHONEBOOK_RECORD, result,
-                mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
+                        + " with " + phonebookRecord.toString());
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
-                    + " with " + phonebookRecord.toString());
+            radioServiceInvokeHelper(HAL_SERVICE_SIM, rr, "updateSimPhonebookRecord", () -> {
+                simProxy.updateSimPhonebookRecords(rr.mSerial, phonebookRecord);
+            });
+        } else {
+            if (RILJ_LOGD) {
+                Rlog.d(RILJ_LOG_TAG, "updateSimPhonebookRecords: REQUEST_NOT_SUPPORTED");
+            }
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_SIM, rr, "updateSimPhonebookRecord", () -> {
-            simProxy.updateSimPhonebookRecords(rr.mSerial, phonebookRecord);
-        });
     }
 
     /**
@@ -4840,19 +5419,31 @@ public class RIL extends BaseCommands implements CommandsInterface {
     public void setUsageSetting(Message result,
             /* @TelephonyManager.UsageSetting */ int usageSetting) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("setUsageSetting", networkProxy, result, RADIO_HAL_VERSION_2_0)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_NETWORK).greaterOrEqual(RADIO_HAL_VERSION_2_0)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_SET_USAGE_SETTING, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_SET_USAGE_SETTING, result, mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "setUsageSetting", () -> {
+                networkProxy.setUsageSetting(rr.mSerial, usageSetting);
+            });
+        } else {
+            if (RILJ_LOGD) {
+                Rlog.d(RILJ_LOG_TAG, "setUsageSetting: REQUEST_NOT_SUPPORTED");
+            }
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "setUsageSetting", () -> {
-            networkProxy.setUsageSetting(rr.mSerial, usageSetting);
-        });
     }
 
     /**
@@ -4863,39 +5454,63 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void getUsageSetting(Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("getUsageSetting", networkProxy, result, RADIO_HAL_VERSION_2_0)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_NETWORK).greaterOrEqual(RADIO_HAL_VERSION_2_0)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_GET_USAGE_SETTING, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_GET_USAGE_SETTING, result, mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "getUsageSetting", () -> {
+                networkProxy.getUsageSetting(rr.mSerial);
+            });
+        } else {
+            if (RILJ_LOGD) {
+                Rlog.d(RILJ_LOG_TAG, "getUsageSetting: REQUEST_NOT_SUPPORTED");
+            }
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "getUsageSetting", () -> {
-            networkProxy.getUsageSetting(rr.mSerial);
-        });
     }
 
     @Override
     public void setSrvccCallInfo(SrvccConnection[] srvccConnections, Message result) {
         RadioImsProxy imsProxy = getRadioServiceProxy(RadioImsProxy.class);
-        if (!canMakeRequest("setSrvccCallInfo", imsProxy, result, RADIO_HAL_VERSION_2_0)) {
+        if (imsProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(imsProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_IMS).greaterOrEqual(RADIO_HAL_VERSION_2_0)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_SET_SRVCC_CALL_INFO, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_SET_SRVCC_CALL_INFO, result,
-                mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                // Do not log function arg for privacy
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            }
 
-        if (RILJ_LOGD) {
-            // Do not log function arg for privacy
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            radioServiceInvokeHelper(HAL_SERVICE_IMS, rr, "setSrvccCallInfo", () -> {
+                imsProxy.setSrvccCallInfo(rr.mSerial,
+                        RILUtils.convertToHalSrvccCall(srvccConnections));
+            });
+        } else {
+            if (RILJ_LOGD) {
+                Rlog.d(RILJ_LOG_TAG, "setSrvccCallInfo: REQUEST_NOT_SUPPORTED");
+            }
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_IMS, rr, "setSrvccCallInfo", () -> {
-            imsProxy.setSrvccCallInfo(rr.mSerial, RILUtils.convertToHalSrvccCall(srvccConnections));
-        });
     }
 
     @Override
@@ -4905,108 +5520,168 @@ public class RIL extends BaseCommands implements CommandsInterface {
             @RegistrationManager.SuggestedAction int suggestedAction,
             int capabilities, Message result) {
         RadioImsProxy imsProxy = getRadioServiceProxy(RadioImsProxy.class);
-        if (!canMakeRequest("updateImsRegistrationInfo", imsProxy, result, RADIO_HAL_VERSION_2_0)) {
+        if (imsProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(imsProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_IMS).greaterOrEqual(RADIO_HAL_VERSION_2_0)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_UPDATE_IMS_REGISTRATION_INFO, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_UPDATE_IMS_REGISTRATION_INFO, result,
-                mRILDefaultWorkSource);
-
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
-                    + " state=" + state + ", radioTech=" + imsRadioTech
-                    + ", suggested=" + suggestedAction + ", cap=" + capabilities);
-        }
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
+                        + " state=" + state + ", radioTech=" + imsRadioTech
+                        + ", suggested=" + suggestedAction + ", cap=" + capabilities);
+            }
 
-        android.hardware.radio.ims.ImsRegistration registrationInfo =
-                new android.hardware.radio.ims.ImsRegistration();
-        registrationInfo.regState = RILUtils.convertImsRegistrationState(state);
-        registrationInfo.accessNetworkType = RILUtils.convertImsRegistrationTech(imsRadioTech);
-        registrationInfo.suggestedAction = suggestedAction;
-        registrationInfo.capabilities = RILUtils.convertImsCapability(capabilities);
+            android.hardware.radio.ims.ImsRegistration registrationInfo =
+                    new android.hardware.radio.ims.ImsRegistration();
+            registrationInfo.regState = RILUtils.convertImsRegistrationState(state);
+            registrationInfo.accessNetworkType = RILUtils.convertImsRegistrationTech(imsRadioTech);
+            registrationInfo.suggestedAction = suggestedAction;
+            registrationInfo.capabilities = RILUtils.convertImsCapability(capabilities);
 
-        radioServiceInvokeHelper(HAL_SERVICE_IMS, rr, "updateImsRegistrationInfo", () -> {
-            imsProxy.updateImsRegistrationInfo(rr.mSerial, registrationInfo);
-        });
+            radioServiceInvokeHelper(HAL_SERVICE_IMS, rr, "updateImsRegistrationInfo", () -> {
+                imsProxy.updateImsRegistrationInfo(rr.mSerial, registrationInfo);
+            });
+        } else {
+            if (RILJ_LOGD) {
+                Rlog.d(RILJ_LOG_TAG, "updateImsRegistrationInfo: REQUEST_NOT_SUPPORTED");
+            }
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
+        }
     }
 
     @Override
-    public void startImsTraffic(int token, int trafficType, int accessNetworkType,
-            int trafficDirection, Message result) {
+    public void startImsTraffic(int token,
+            int trafficType, int accessNetworkType, int trafficDirection, Message result) {
         RadioImsProxy imsProxy = getRadioServiceProxy(RadioImsProxy.class);
-        if (!canMakeRequest("startImsTraffic", imsProxy, result, RADIO_HAL_VERSION_2_0)) {
+        if (imsProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(imsProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_IMS).greaterOrEqual(RADIO_HAL_VERSION_2_0)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_START_IMS_TRAFFIC, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_START_IMS_TRAFFIC, result, mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
+                        + "{" + token + ", " + trafficType + ", "
+                        + accessNetworkType + ", " + trafficDirection + "}");
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
-                    + "{" + token + ", " + trafficType + ", "
-                    + accessNetworkType + ", " + trafficDirection + "}");
+            radioServiceInvokeHelper(HAL_SERVICE_IMS, rr, "startImsTraffic", () -> {
+                imsProxy.startImsTraffic(rr.mSerial, token,
+                        RILUtils.convertImsTrafficType(trafficType), accessNetworkType,
+                        RILUtils.convertImsTrafficDirection(trafficDirection));
+            });
+        } else {
+            if (RILJ_LOGD) {
+                Rlog.d(RILJ_LOG_TAG, "startImsTraffic: REQUEST_NOT_SUPPORTED");
+            }
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_IMS, rr, "startImsTraffic", () -> {
-            imsProxy.startImsTraffic(rr.mSerial, token, RILUtils.convertImsTrafficType(trafficType),
-                    accessNetworkType, RILUtils.convertImsTrafficDirection(trafficDirection));
-        });
     }
 
     @Override
     public void stopImsTraffic(int token, Message result) {
         RadioImsProxy imsProxy = getRadioServiceProxy(RadioImsProxy.class);
-        if (!canMakeRequest("stopImsTraffic", imsProxy, result, RADIO_HAL_VERSION_2_0)) {
+        if (imsProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(imsProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_IMS).greaterOrEqual(RADIO_HAL_VERSION_2_0)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_STOP_IMS_TRAFFIC, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_STOP_IMS_TRAFFIC, result, mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
+                        + "{" + token + "}");
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
-                    + "{" + token + "}");
+            radioServiceInvokeHelper(HAL_SERVICE_IMS, rr, "stopImsTraffic", () -> {
+                imsProxy.stopImsTraffic(rr.mSerial, token);
+            });
+        } else {
+            if (RILJ_LOGD) {
+                Rlog.d(RILJ_LOG_TAG, "stopImsTraffic: REQUEST_NOT_SUPPORTED");
+            }
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_IMS, rr, "stopImsTraffic", () -> {
-            imsProxy.stopImsTraffic(rr.mSerial, token);
-        });
     }
 
     @Override
     public void triggerEpsFallback(int reason, Message result) {
         RadioImsProxy imsProxy = getRadioServiceProxy(RadioImsProxy.class);
-        if (!canMakeRequest("triggerEpsFallback", imsProxy, result, RADIO_HAL_VERSION_2_0)) {
+        if (imsProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(imsProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_IMS).greaterOrEqual(RADIO_HAL_VERSION_2_0)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_TRIGGER_EPS_FALLBACK, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_TRIGGER_EPS_FALLBACK, result,
-                mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
+                        + " reason=" + reason);
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
-                    + " reason=" + reason);
+            radioServiceInvokeHelper(HAL_SERVICE_IMS, rr, "triggerEpsFallback", () -> {
+                imsProxy.triggerEpsFallback(rr.mSerial, reason);
+            });
+        } else {
+            if (RILJ_LOGD) {
+                Rlog.d(RILJ_LOG_TAG, "triggerEpsFallback: REQUEST_NOT_SUPPORTED");
+            }
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_IMS, rr, "triggerEpsFallback", () -> {
-            imsProxy.triggerEpsFallback(rr.mSerial, reason);
-        });
     }
 
     @Override
-    public void sendAnbrQuery(int mediaType, int direction, int bitsPerSecond, Message result) {
+    public void sendAnbrQuery(int mediaType, int direction, int bitsPerSecond,
+            Message result) {
         RadioImsProxy imsProxy = getRadioServiceProxy(RadioImsProxy.class);
-        if (!canMakeRequest("sendAnbrQuery", imsProxy, result, RADIO_HAL_VERSION_2_0)) {
+        if (imsProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(imsProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_IMS).greaterOrEqual(RADIO_HAL_VERSION_2_0)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_SEND_ANBR_QUERY, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_SEND_ANBR_QUERY, result, mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            radioServiceInvokeHelper(HAL_SERVICE_IMS, rr, "sendAnbrQuery", () -> {
+                imsProxy.sendAnbrQuery(rr.mSerial, mediaType, direction, bitsPerSecond);
+            });
+        } else {
+            if (RILJ_LOGD) {
+                Rlog.d(RILJ_LOG_TAG, "sendAnbrQuery: REQUEST_NOT_SUPPORTED");
+            }
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_IMS, rr, "sendAnbrQuery", () -> {
-            imsProxy.sendAnbrQuery(rr.mSerial, mediaType, direction, bitsPerSecond);
-        });
     }
 
     /**
@@ -5015,21 +5690,32 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void setEmergencyMode(int emcMode, Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("setEmergencyMode", networkProxy, result, RADIO_HAL_VERSION_2_1)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_NETWORK).greaterOrEqual(RADIO_HAL_VERSION_2_1)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_SET_EMERGENCY_MODE, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_SET_EMERGENCY_MODE, result,
-                mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
+                        + " mode=" + EmergencyConstants.emergencyModeToString(emcMode));
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
-                    + " mode=" + EmergencyConstants.emergencyModeToString(emcMode));
+            radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "setEmergencyMode", () -> {
+                networkProxy.setEmergencyMode(rr.mSerial, emcMode);
+            });
+        } else {
+            if (RILJ_LOGD) {
+                Rlog.d(RILJ_LOG_TAG, "setEmergencyMode: REQUEST_NOT_SUPPORTED");
+            }
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "setEmergencyMode", () -> {
-            networkProxy.setEmergencyMode(rr.mSerial, emcMode);
-        });
     }
 
     /**
@@ -5040,24 +5726,34 @@ public class RIL extends BaseCommands implements CommandsInterface {
             @NonNull @AccessNetworkConstants.RadioAccessNetworkType int[] accessNetwork,
             @DomainSelectionService.EmergencyScanType int scanType, Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("triggerEmergencyNetworkScan", networkProxy, result,
-                RADIO_HAL_VERSION_2_1)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_NETWORK).greaterOrEqual(RADIO_HAL_VERSION_2_1)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_TRIGGER_EMERGENCY_NETWORK_SCAN, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_TRIGGER_EMERGENCY_NETWORK_SCAN, result,
-                mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
+                        + " networkType=" + RILUtils.accessNetworkTypesToString(accessNetwork)
+                        + ", scanType=" + RILUtils.scanTypeToString(scanType));
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
-                    + " networkType=" + RILUtils.accessNetworkTypesToString(accessNetwork)
-                    + ", scanType=" + RILUtils.scanTypeToString(scanType));
+            radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "triggerEmergencyNetworkScan", () -> {
+                networkProxy.triggerEmergencyNetworkScan(rr.mSerial,
+                        RILUtils.convertEmergencyNetworkScanTrigger(accessNetwork, scanType));
+            });
+        } else {
+            if (RILJ_LOGD) {
+                Rlog.d(RILJ_LOG_TAG, "triggerEmergencyNetworkScan: REQUEST_NOT_SUPPORTED");
+            }
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "triggerEmergencyNetworkScan", () -> {
-            networkProxy.triggerEmergencyNetworkScan(rr.mSerial,
-                    RILUtils.convertEmergencyNetworkScanTrigger(accessNetwork, scanType));
-        });
     }
 
     /**
@@ -5066,22 +5762,32 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void cancelEmergencyNetworkScan(boolean resetScan, Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("cancelEmergencyNetworkScan", networkProxy, result,
-                RADIO_HAL_VERSION_2_1)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_NETWORK).greaterOrEqual(RADIO_HAL_VERSION_2_1)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_CANCEL_EMERGENCY_NETWORK_SCAN, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_CANCEL_EMERGENCY_NETWORK_SCAN, result,
-                mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
+                        + " resetScan=" + resetScan);
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
-                    + " resetScan=" + resetScan);
+            radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "cancelEmergencyNetworkScan", () -> {
+                networkProxy.cancelEmergencyNetworkScan(rr.mSerial, resetScan);
+            });
+        } else {
+            if (RILJ_LOGD) {
+                Rlog.d(RILJ_LOG_TAG, "cancelEmergencyNetworkScan: REQUEST_NOT_SUPPORTED");
+            }
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "cancelEmergencyNetworkScan", () -> {
-            networkProxy.cancelEmergencyNetworkScan(rr.mSerial, resetScan);
-        });
     }
 
     /**
@@ -5090,20 +5796,31 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void exitEmergencyMode(Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("exitEmergencyMode", networkProxy, result, RADIO_HAL_VERSION_2_1)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_NETWORK).greaterOrEqual(RADIO_HAL_VERSION_2_1)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_EXIT_EMERGENCY_MODE, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_EXIT_EMERGENCY_MODE, result,
-                mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "exitEmergencyMode", () -> {
+                networkProxy.exitEmergencyMode(rr.mSerial);
+            });
+        } else {
+            if (RILJ_LOGD) {
+                Rlog.d(RILJ_LOG_TAG, "exitEmergencyMode: REQUEST_NOT_SUPPORTED");
+            }
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "exitEmergencyMode", () -> {
-            networkProxy.exitEmergencyMode(rr.mSerial);
-        });
     }
 
     /**
@@ -5115,22 +5832,32 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void setNullCipherAndIntegrityEnabled(boolean enabled, Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("setNullCipherAndIntegrityEnabled", networkProxy, result,
-                RADIO_HAL_VERSION_2_1)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_NETWORK).greaterOrEqual(RADIO_HAL_VERSION_2_1)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_SET_NULL_CIPHER_AND_INTEGRITY_ENABLED, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_SET_NULL_CIPHER_AND_INTEGRITY_ENABLED, result,
-                mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            radioServiceInvokeHelper(
+                    HAL_SERVICE_NETWORK, rr, "setNullCipherAndIntegrityEnabled", () -> {
+                        networkProxy.setNullCipherAndIntegrityEnabled(rr.mSerial, enabled);
+                    });
+        } else {
+            if (RILJ_LOGD) {
+                Rlog.d(RILJ_LOG_TAG, "setNullCipherAndIntegrityEnabled: REQUEST_NOT_SUPPORTED");
+            }
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "setNullCipherAndIntegrityEnabled",
-                () -> {
-                    networkProxy.setNullCipherAndIntegrityEnabled(rr.mSerial, enabled);
-                });
     }
 
     /**
@@ -5141,21 +5868,31 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void isNullCipherAndIntegrityEnabled(Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("isNullCipherAndIntegrityEnabled", networkProxy, result,
-                RADIO_HAL_VERSION_2_1)) {
-            return;
-        }
+        if (networkProxy.isEmpty()) return;
+        if (mHalVersion.get(HAL_SERVICE_NETWORK).greaterOrEqual(RADIO_HAL_VERSION_2_1)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_IS_NULL_CIPHER_AND_INTEGRITY_ENABLED, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_IS_NULL_CIPHER_AND_INTEGRITY_ENABLED, result,
-                mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            try {
+                networkProxy.isNullCipherAndIntegrityEnabled(rr.mSerial);
+            } catch (RemoteException | RuntimeException e) {
+                handleRadioProxyExceptionForRR(
+                        HAL_SERVICE_NETWORK, "isNullCipherAndIntegrityEnabled", e);
+            }
+        } else {
+            if (RILJ_LOGD) {
+                Rlog.d(RILJ_LOG_TAG, "isNullCipherAndIntegrityEnabled: REQUEST_NOT_SUPPORTED");
+            }
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "isNullCipherAndIntegrityEnabled", () -> {
-            networkProxy.isNullCipherAndIntegrityEnabled(rr.mSerial);
-        });
     }
 
     /**
@@ -5164,20 +5901,31 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void updateImsCallStatus(@NonNull List<ImsCallInfo> imsCallInfo, Message result) {
         RadioImsProxy imsProxy = getRadioServiceProxy(RadioImsProxy.class);
-        if (!canMakeRequest("updateImsCallStatus", imsProxy, result, RADIO_HAL_VERSION_2_0)) {
+        if (imsProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(imsProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_IMS).greaterOrEqual(RADIO_HAL_VERSION_2_0)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_UPDATE_IMS_CALL_STATUS, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_UPDATE_IMS_CALL_STATUS, result,
-                mRILDefaultWorkSource);
-
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
-                    + " " + imsCallInfo);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
+                        + " " + imsCallInfo);
+            }
+            radioServiceInvokeHelper(HAL_SERVICE_IMS, rr, "updateImsCallStatus", () -> {
+                imsProxy.updateImsCallStatus(rr.mSerial, RILUtils.convertImsCallInfo(imsCallInfo));
+            });
+        } else {
+            if (RILJ_LOGD) {
+                Rlog.d(RILJ_LOG_TAG, "updateImsCallStatus: REQUEST_NOT_SUPPORTED");
+            }
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-        radioServiceInvokeHelper(HAL_SERVICE_IMS, rr, "updateImsCallStatus", () -> {
-            imsProxy.updateImsCallStatus(rr.mSerial, RILUtils.convertImsCallInfo(imsCallInfo));
-        });
     }
 
     /**
@@ -5186,21 +5934,32 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void setN1ModeEnabled(boolean enable, Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("setN1ModeEnabled", networkProxy, result, RADIO_HAL_VERSION_2_1)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_NETWORK).greaterOrEqual(RADIO_HAL_VERSION_2_1)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_SET_N1_MODE_ENABLED, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_SET_N1_MODE_ENABLED, result,
-                mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
+                        + " enable=" + enable);
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest)
-                    + " enable=" + enable);
+            radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "setN1ModeEnabled", () -> {
+                networkProxy.setN1ModeEnabled(rr.mSerial, enable);
+            });
+        } else {
+            if (RILJ_LOGD) {
+                Rlog.d(RILJ_LOG_TAG, "setN1ModeEnabled: REQUEST_NOT_SUPPORTED");
+            }
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "setN1ModeEnabled", () -> {
-            networkProxy.setN1ModeEnabled(rr.mSerial, enable);
-        });
     }
 
     /**
@@ -5209,20 +5968,31 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @Override
     public void isN1ModeEnabled(Message result) {
         RadioNetworkProxy networkProxy = getRadioServiceProxy(RadioNetworkProxy.class);
-        if (!canMakeRequest("isN1ModeEnabled", networkProxy, result, RADIO_HAL_VERSION_2_1)) {
+        if (networkProxy.isEmpty()) {
+            handleRadioServiceNotAvailable(networkProxy, result);
             return;
         }
+        if (mHalVersion.get(HAL_SERVICE_NETWORK).greaterOrEqual(RADIO_HAL_VERSION_2_1)) {
+            RILRequest rr = obtainRequest(RIL_REQUEST_IS_N1_MODE_ENABLED, result,
+                    mRILDefaultWorkSource);
 
-        RILRequest rr = obtainRequest(RIL_REQUEST_IS_N1_MODE_ENABLED, result,
-                mRILDefaultWorkSource);
+            if (RILJ_LOGD) {
+                riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            }
 
-        if (RILJ_LOGD) {
-            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest));
+            radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "isN1ModeEnabled", () -> {
+                networkProxy.isN1ModeEnabled(rr.mSerial);
+            });
+        } else {
+            if (RILJ_LOGD) {
+                Rlog.d(RILJ_LOG_TAG, "isN1ModeEnabled: REQUEST_NOT_SUPPORTED");
+            }
+            if (result != null) {
+                AsyncResult.forMessage(result, null,
+                        CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                result.sendToTarget();
+            }
         }
-
-        radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "isN1ModeEnabled", () -> {
-            networkProxy.isN1ModeEnabled(rr.mSerial);
-        });
     }
 
     /**
@@ -5286,7 +6056,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
                 });
     }
 
-   /**
+    /**
      * {@inheritDoc}
      */
     @Override
@@ -5311,7 +6081,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
         radioServiceInvokeHelper(HAL_SERVICE_NETWORK, rr, "setSecurityAlgorithmsUpdatedEnabled",
                 () -> {
                     networkProxy.setSecurityAlgorithmsUpdatedEnabled(rr.mSerial, enable);
-            });
+           });
     }
 
     /**
@@ -5363,7 +6133,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
             rr = mRequestList.get(serial);
         }
         if (rr == null) {
-            riljLogw("processRequestAck: Unexpected solicited ack response! serial: " + serial);
+            Rlog.w(RILJ_LOG_TAG, "processRequestAck: Unexpected solicited ack response! "
+                    + "serial: " + serial);
         } else {
             decrementWakeLock(rr);
             if (RILJ_LOGD) {
@@ -5421,7 +6192,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
                 rr = mRequestList.get(serial);
             }
             if (rr == null) {
-                riljLogw("Unexpected solicited ack response! sn: " + serial);
+                Rlog.w(RILJ_LOG_TAG, "Unexpected solicited ack response! sn: " + serial);
             } else {
                 decrementWakeLock(rr);
                 if (mRadioBugDetector != null) {
@@ -5437,8 +6208,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
 
         rr = findAndRemoveRequestFromList(serial);
         if (rr == null) {
-            riljLoge("processResponse: Unexpected response! serial: " + serial
-                    + ", error: " + error);
+            Rlog.e(RILJ_LOG_TAG, "processResponse: Unexpected response! serial: " + serial
+                    + " ,error: " + error);
             return null;
         }
         Trace.asyncTraceForTrackEnd(Trace.TRACE_TAG_NETWORK, "RIL", rr.mSerial);
@@ -5624,7 +6395,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
                     riljLoge("sendAck: " + e);
                 }
             } else {
-                riljLoge("Error trying to send ack, radioProxy = null");
+                Rlog.e(RILJ_LOG_TAG, "Error trying to send ack, radioProxy = null");
             }
         } else {
             RadioServiceProxy serviceProxy = getRadioServiceProxy(service);
@@ -5636,7 +6407,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
                     riljLoge("sendAck: " + e);
                 }
             } else {
-                riljLoge("Error trying to send ack, serviceProxy is empty");
+                Rlog.e(RILJ_LOG_TAG, "Error trying to send ack, serviceProxy is empty");
             }
         }
         rr.release();
@@ -5663,11 +6434,11 @@ public class RIL extends BaseCommands implements CommandsInterface {
     private void acquireWakeLock(RILRequest rr, int wakeLockType) {
         synchronized (rr) {
             if (rr.mWakeLockType != INVALID_WAKELOCK) {
-                riljLog("Failed to acquire wakelock for " + rr.serialString());
+                Rlog.d(RILJ_LOG_TAG, "Failed to aquire wakelock for " + rr.serialString());
                 return;
             }
 
-            switch (wakeLockType) {
+            switch(wakeLockType) {
                 case FOR_WAKELOCK:
                     synchronized (mWakeLock) {
                         mWakeLock.acquire();
@@ -5699,7 +6470,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
                     }
                     break;
                 default: //WTF
-                    riljLogw("Acquiring Invalid Wakelock type " + wakeLockType);
+                    Rlog.w(RILJ_LOG_TAG, "Acquiring Invalid Wakelock type " + wakeLockType);
                     return;
             }
             rr.mWakeLockType = wakeLockType;
@@ -5753,7 +6524,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
                 case INVALID_WAKELOCK:
                     break;
                 default:
-                    riljLogw("Decrementing Invalid Wakelock type " + rr.mWakeLockType);
+                    Rlog.w(RILJ_LOG_TAG, "Decrementing Invalid Wakelock type " + rr.mWakeLockType);
             }
             rr.mWakeLockType = INVALID_WAKELOCK;
         }
@@ -5764,7 +6535,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
         if (wakeLockType == FOR_WAKELOCK) {
             synchronized (mWakeLock) {
                 if (mWakeLockCount == 0 && !mWakeLock.isHeld()) return false;
-                riljLog("NOTE: mWakeLockCount is " + mWakeLockCount + " at time of clearing");
+                Rlog.d(RILJ_LOG_TAG, "NOTE: mWakeLockCount is " + mWakeLockCount
+                        + " at time of clearing");
                 mWakeLockCount = 0;
                 mWakeLock.release();
                 mClientWakelockTracker.stopTrackingAll();
@@ -5791,14 +6563,15 @@ public class RIL extends BaseCommands implements CommandsInterface {
         synchronized (mRequestList) {
             int count = mRequestList.size();
             if (RILJ_LOGD && loggable) {
-                riljLog("clearRequestList " + " mWakeLockCount=" + mWakeLockCount
-                        + " mRequestList=" + count);
+                Rlog.d(RILJ_LOG_TAG, "clearRequestList " + " mWakeLockCount="
+                        + mWakeLockCount + " mRequestList=" + count);
             }
 
             for (int i = 0; i < count; i++) {
                 rr = mRequestList.valueAt(i);
                 if (RILJ_LOGD && loggable) {
-                    riljLog(i + ": [" + rr.mSerial + "] " + RILUtils.requestToString(rr.mRequest));
+                    Rlog.d(RILJ_LOG_TAG, i + ": [" + rr.mSerial + "] "
+                            + RILUtils.requestToString(rr.mRequest));
                 }
                 rr.onError(error, null);
                 decrementWakeLock(rr);
@@ -6076,22 +6849,18 @@ public class RIL extends BaseCommands implements CommandsInterface {
         Rlog.v(RILJ_LOG_TAG, msg + (" [PHONE" + mPhoneId + "]"));
     }
 
-    void riljLogw(String msg) {
-        Rlog.w(RILJ_LOG_TAG, msg + (" [PHONE" + mPhoneId + "]"));
-    }
-
     boolean isLogOrTrace() {
-        return RILJ_LOGD || Trace.isTagEnabled(Trace.TRACE_TAG_NETWORK);
+        return RIL.RILJ_LOGD || Trace.isTagEnabled(Trace.TRACE_TAG_NETWORK);
     }
 
     boolean isLogvOrTrace() {
-        return RILJ_LOGV || Trace.isTagEnabled(Trace.TRACE_TAG_NETWORK);
+        return RIL.RILJ_LOGV || Trace.isTagEnabled(Trace.TRACE_TAG_NETWORK);
     }
 
     @UnsupportedAppUsage
     void unsljLog(int response) {
         String logStr = RILUtils.responseToString(response);
-        if (RILJ_LOGD) {
+        if (RIL.RILJ_LOGD) {
             riljLog("[UNSL]< " + logStr);
         }
         Trace.instantForTrack(Trace.TRACE_TAG_NETWORK, "RIL", logStr);
@@ -6100,7 +6869,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @UnsupportedAppUsage
     void unsljLogMore(int response, String more) {
         String logStr = RILUtils.responseToString(response) + " " + more;
-        if (RILJ_LOGD) {
+        if (RIL.RILJ_LOGD) {
             riljLog("[UNSL]< " + logStr);
         }
         Trace.instantForTrack(Trace.TRACE_TAG_NETWORK, "RIL", logStr);
@@ -6109,7 +6878,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @UnsupportedAppUsage
     void unsljLogRet(int response, Object ret) {
         String logStr = RILUtils.responseToString(response) + " " + retToString(response, ret);
-        if (RILJ_LOGD) {
+        if (RIL.RILJ_LOGD) {
             riljLog("[UNSL]< " + logStr);
         }
         Trace.instantForTrack(Trace.TRACE_TAG_NETWORK, "RIL", logStr);
@@ -6118,7 +6887,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
     @UnsupportedAppUsage
     void unsljLogvRet(int response, Object ret) {
         String logStr = RILUtils.responseToString(response) + " " + retToString(response, ret);
-        if (RILJ_LOGV) {
+        if (RIL.RILJ_LOGV) {
             riljLogv("[UNSL]< " + logStr);
         }
         Trace.instantForTrack(Trace.TRACE_TAG_NETWORK, "RIL", logStr);
@@ -6171,6 +6940,58 @@ public class RIL extends BaseCommands implements CommandsInterface {
         return mClientWakelockTracker.getClientRequestStats();
     }
 
+    /**
+     * Fixup for SignalStrength 1.0 to Assume GSM to WCDMA when
+     * The current RAT type is one of the UMTS RATs.
+     * @param signalStrength the initial signal strength
+     * @return a new SignalStrength if RAT is UMTS or existing SignalStrength
+     */
+    public SignalStrength fixupSignalStrength10(SignalStrength signalStrength) {
+        List<CellSignalStrengthGsm> gsmList = signalStrength.getCellSignalStrengths(
+                CellSignalStrengthGsm.class);
+        // If GSM is not the primary type, then bail out; no fixup needed.
+        if (gsmList.isEmpty() || !gsmList.get(0).isValid()) {
+            return signalStrength;
+        }
+
+        CellSignalStrengthGsm gsmStrength = gsmList.get(0);
+
+        // Use the voice RAT which is a guarantee in GSM and UMTS
+        int voiceRat = ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN;
+        Phone phone = PhoneFactory.getPhone(mPhoneId);
+        if (phone != null) {
+            ServiceState ss = phone.getServiceState();
+            if (ss != null) {
+                voiceRat = ss.getRilVoiceRadioTechnology();
+            }
+        }
+        switch (voiceRat) {
+            case ServiceState.RIL_RADIO_TECHNOLOGY_UMTS: /* fallthrough */
+            case ServiceState.RIL_RADIO_TECHNOLOGY_HSDPA: /* fallthrough */
+            case ServiceState.RIL_RADIO_TECHNOLOGY_HSUPA: /* fallthrough */
+            case ServiceState.RIL_RADIO_TECHNOLOGY_HSPA: /* fallthrough */
+            case ServiceState.RIL_RADIO_TECHNOLOGY_HSPAP: /* fallthrough */
+                break;
+            default:
+                // If we are not currently on WCDMA/HSPA, then we don't need to do a fixup.
+                return signalStrength;
+        }
+
+        // The service state reports WCDMA, and the SignalStrength is reported for GSM, so at this
+        // point we take an educated guess that the GSM SignalStrength report is actually for
+        // WCDMA. Also, if we are in WCDMA/GSM we can safely assume that there are no other valid
+        // signal strength reports (no SRLTE, which is the only supported case in HAL 1.0).
+        // Thus, we just construct a new SignalStrength and migrate RSSI and BER from the
+        // GSM report to the WCDMA report, leaving everything else empty.
+        return new SignalStrength(
+                new CellSignalStrengthCdma(), new CellSignalStrengthGsm(),
+                new CellSignalStrengthWcdma(gsmStrength.getRssi(),
+                        gsmStrength.getBitErrorRate(),
+                        CellInfo.UNAVAILABLE, CellInfo.UNAVAILABLE),
+                new CellSignalStrengthTdscdma(), new CellSignalStrengthLte(),
+                new CellSignalStrengthNr());
+    }
+
     void notifyBarringInfoChanged(@NonNull BarringInfo barringInfo) {
         mLastBarringInfo = barringInfo;
         mBarringInfoChangedRegistrants.notifyRegistrants(new AsyncResult(null, barringInfo, null));
diff --git a/src/java/com/android/internal/telephony/RILUtils.java b/src/java/com/android/internal/telephony/RILUtils.java
index 8897db4e45..04e90f7f83 100644
--- a/src/java/com/android/internal/telephony/RILUtils.java
+++ b/src/java/com/android/internal/telephony/RILUtils.java
@@ -886,6 +886,41 @@ public class RILUtils {
         return new SmsMessage(addr, env);
     }
 
+    /**
+     * Convert to DataProfileInfo defined in radio/1.0/types.hal
+     * @param dp Data profile
+     * @return The converted DataProfileInfo
+     */
+    public static android.hardware.radio.V1_0.DataProfileInfo convertToHalDataProfile10(
+            DataProfile dp) {
+        android.hardware.radio.V1_0.DataProfileInfo dpi =
+                new android.hardware.radio.V1_0.DataProfileInfo();
+
+        dpi.profileId = dp.getProfileId();
+        dpi.apn = dp.getApn();
+        dpi.protocol = ApnSetting.getProtocolStringFromInt(dp.getProtocolType());
+        dpi.roamingProtocol = ApnSetting.getProtocolStringFromInt(dp.getRoamingProtocolType());
+        dpi.authType = dp.getAuthType();
+        dpi.user = TextUtils.emptyIfNull(dp.getUserName());
+        dpi.password = TextUtils.emptyIfNull(dp.getPassword());
+        dpi.type = dp.getType();
+        dpi.maxConnsTime = dp.getMaxConnectionsTime();
+        dpi.maxConns = dp.getMaxConnections();
+        dpi.waitTime = dp.getWaitTime();
+        dpi.enabled = dp.isEnabled();
+        dpi.supportedApnTypesBitmap = dp.getSupportedApnTypesBitmask();
+        // Shift by 1 bit due to the discrepancy between
+        // android.hardware.radio.V1_0.RadioAccessFamily and the bitmask version of
+        // ServiceState.RIL_RADIO_TECHNOLOGY_XXXX.
+        dpi.bearerBitmap = ServiceState.convertNetworkTypeBitmaskToBearerBitmask(
+                dp.getBearerBitmask()) << 1;
+        dpi.mtu = dp.getMtuV4();
+        dpi.mvnoType = android.hardware.radio.V1_0.MvnoType.NONE;
+        dpi.mvnoMatchData = "";
+
+        return dpi;
+    }
+
     /**
      * Convert to DataProfileInfo defined in radio/1.4/types.hal
      * @param dp Data profile
@@ -2180,15 +2215,21 @@ public class RILUtils {
     }
 
     /**
-     * Convert LinkCapacityEstimate defined in radio/1.2, 1.6/types.hal to
-     * a list of LinkCapacityEstimates
-     * @param lceObj LinkCapacityEstimate defined in radio/1.2, 1.6/types.hal
+     * Convert LceDataInfo defined in radio/1.0/types.hal and LinkCapacityEstimate defined in
+     * radio/1.2, 1.6/types.hal to a list of LinkCapacityEstimates
+     * @param lceObj LceDataInfo defined in radio/1.0/types.hal or LinkCapacityEstimate defined in
+     *        radio/1.2, 1.6/types.hal
      * @return The converted list of LinkCapacityEstimates
      */
-    public static List<LinkCapacityEstimate> convertHalLinkCapacityEstimate(Object lceObj) {
+    public static List<LinkCapacityEstimate> convertHalLceData(Object lceObj) {
         final List<LinkCapacityEstimate> lceList = new ArrayList<>();
         if (lceObj == null) return lceList;
-        if (lceObj instanceof android.hardware.radio.V1_2.LinkCapacityEstimate) {
+        if (lceObj instanceof android.hardware.radio.V1_0.LceDataInfo) {
+            android.hardware.radio.V1_0.LceDataInfo lce =
+                    (android.hardware.radio.V1_0.LceDataInfo) lceObj;
+            lceList.add(new LinkCapacityEstimate(LinkCapacityEstimate.LCE_TYPE_COMBINED,
+                    lce.lastHopCapacityKbps, LinkCapacityEstimate.INVALID));
+        } else if (lceObj instanceof android.hardware.radio.V1_2.LinkCapacityEstimate) {
             android.hardware.radio.V1_2.LinkCapacityEstimate lce =
                     (android.hardware.radio.V1_2.LinkCapacityEstimate) lceObj;
             lceList.add(new LinkCapacityEstimate(LinkCapacityEstimate.LCE_TYPE_COMBINED,
@@ -2216,13 +2257,26 @@ public class RILUtils {
         return lceList;
     }
 
+    /**
+     * Convert LceDataInfo defined in LceDataInfo.aidl to a list of LinkCapacityEstimates
+     * @param lce LceDataInfo defined in LceDataInfo.aidl
+     * @return The converted list of LinkCapacityEstimates
+     */
+    public static List<LinkCapacityEstimate> convertHalLceData(
+            android.hardware.radio.network.LceDataInfo lce) {
+        final List<LinkCapacityEstimate> lceList = new ArrayList<>();
+        lceList.add(new LinkCapacityEstimate(LinkCapacityEstimate.LCE_TYPE_COMBINED,
+                lce.lastHopCapacityKbps, LinkCapacityEstimate.INVALID));
+        return lceList;
+    }
+
     /**
      * Convert LinkCapacityEstimate defined in LinkCapacityEstimate.aidl to a list of
      * LinkCapacityEstimates
      * @param lce LinkCapacityEstimate defined in LinkCapacityEstimate.aidl
      * @return The converted list of LinkCapacityEstimates
      */
-    public static List<LinkCapacityEstimate> convertHalLinkCapacityEstimate(
+    public static List<LinkCapacityEstimate> convertHalLceData(
             android.hardware.radio.network.LinkCapacityEstimate lce) {
         final List<LinkCapacityEstimate> lceList = new ArrayList<>();
         int primaryDownlinkCapacityKbps = lce.downlinkCapacityKbps;
@@ -2246,9 +2300,9 @@ public class RILUtils {
 
 
     /**
-     * Convert a list of CellInfo defined in radio/1.4, 1.5, 1.6/types.hal to a list of
+     * Convert a list of CellInfo defined in radio/1.0, 1.2, 1.4, 1.5, 1.6/types.hal to a list of
      * CellInfos
-     * @param records List of CellInfo defined in radio/1.4, 1.5, 1.6/types.hal
+     * @param records List of CellInfo defined in radio/1.0, 1.2, 1.4, 1.5, 1.6/types.hal
      * @return The converted list of CellInfos
      */
     public static ArrayList<CellInfo> convertHalCellInfoList(ArrayList<Object> records) {
@@ -2278,8 +2332,8 @@ public class RILUtils {
     }
 
     /**
-     * Convert a CellInfo defined in radio/1.4, 1.5, 1.6/types.hal to CellInfo
-     * @param cellInfo CellInfo defined in radio/1.4, 1.5, 1.6/types.hal
+     * Convert a CellInfo defined in radio/1.0, 1.2, 1.4, 1.5, 1.6/types.hal to CellInfo
+     * @param cellInfo CellInfo defined in radio/1.0, 1.2, 1.4, 1.5, 1.6/types.hal
      * @param nanotime time the CellInfo was created
      * @return The converted CellInfo
      */
@@ -2301,7 +2355,87 @@ public class RILUtils {
         CellSignalStrengthTdscdma tdscdmaSs = null;
         CellIdentityNr nrCi = null;
         CellSignalStrengthNr nrSs = null;
-        if (cellInfo instanceof android.hardware.radio.V1_4.CellInfo) {
+        if (cellInfo instanceof android.hardware.radio.V1_0.CellInfo) {
+            final android.hardware.radio.V1_0.CellInfo record =
+                    (android.hardware.radio.V1_0.CellInfo) cellInfo;
+            connectionStatus = CellInfo.CONNECTION_UNKNOWN;
+            registered = record.registered;
+            switch (record.cellInfoType) {
+                case android.hardware.radio.V1_0.CellInfoType.GSM:
+                    type = CellInfo.TYPE_GSM;
+                    android.hardware.radio.V1_0.CellInfoGsm gsm = record.gsm.get(0);
+                    gsmCi = convertHalCellIdentityGsm(gsm.cellIdentityGsm);
+                    gsmSs = convertHalGsmSignalStrength(gsm.signalStrengthGsm);
+                    break;
+                case android.hardware.radio.V1_0.CellInfoType.CDMA:
+                    type = CellInfo.TYPE_CDMA;
+                    android.hardware.radio.V1_0.CellInfoCdma cdma = record.cdma.get(0);
+                    cdmaCi = convertHalCellIdentityCdma(cdma.cellIdentityCdma);
+                    cdmaSs = convertHalCdmaSignalStrength(
+                            cdma.signalStrengthCdma, cdma.signalStrengthEvdo);
+                    break;
+                case android.hardware.radio.V1_0.CellInfoType.LTE:
+                    type = CellInfo.TYPE_LTE;
+                    android.hardware.radio.V1_0.CellInfoLte lte = record.lte.get(0);
+                    lteCi = convertHalCellIdentityLte(lte.cellIdentityLte);
+                    lteSs = convertHalLteSignalStrength(lte.signalStrengthLte);
+                    lteCc = new CellConfigLte();
+                    break;
+                case android.hardware.radio.V1_0.CellInfoType.WCDMA:
+                    type = CellInfo.TYPE_WCDMA;
+                    android.hardware.radio.V1_0.CellInfoWcdma wcdma = record.wcdma.get(0);
+                    wcdmaCi = convertHalCellIdentityWcdma(wcdma.cellIdentityWcdma);
+                    wcdmaSs = convertHalWcdmaSignalStrength(wcdma.signalStrengthWcdma);
+                    break;
+                case android.hardware.radio.V1_0.CellInfoType.TD_SCDMA:
+                    type = CellInfo.TYPE_TDSCDMA;
+                    android.hardware.radio.V1_0.CellInfoTdscdma tdscdma = record.tdscdma.get(0);
+                    tdscdmaCi = convertHalCellIdentityTdscdma(tdscdma.cellIdentityTdscdma);
+                    tdscdmaSs = convertHalTdscdmaSignalStrength(tdscdma.signalStrengthTdscdma);
+                    break;
+                default: return null;
+            }
+        } else if (cellInfo instanceof android.hardware.radio.V1_2.CellInfo) {
+            final android.hardware.radio.V1_2.CellInfo record =
+                    (android.hardware.radio.V1_2.CellInfo) cellInfo;
+            connectionStatus = record.connectionStatus;
+            registered = record.registered;
+            switch(record.cellInfoType) {
+                case android.hardware.radio.V1_0.CellInfoType.GSM:
+                    type = CellInfo.TYPE_GSM;
+                    android.hardware.radio.V1_2.CellInfoGsm gsm = record.gsm.get(0);
+                    gsmCi = convertHalCellIdentityGsm(gsm.cellIdentityGsm);
+                    gsmSs = convertHalGsmSignalStrength(gsm.signalStrengthGsm);
+                    break;
+                case android.hardware.radio.V1_0.CellInfoType.CDMA:
+                    type = CellInfo.TYPE_CDMA;
+                    android.hardware.radio.V1_2.CellInfoCdma cdma = record.cdma.get(0);
+                    cdmaCi = convertHalCellIdentityCdma(cdma.cellIdentityCdma);
+                    cdmaSs = convertHalCdmaSignalStrength(
+                            cdma.signalStrengthCdma, cdma.signalStrengthEvdo);
+                    break;
+                case android.hardware.radio.V1_0.CellInfoType.LTE:
+                    type = CellInfo.TYPE_LTE;
+                    android.hardware.radio.V1_2.CellInfoLte lte = record.lte.get(0);
+                    lteCi = convertHalCellIdentityLte(lte.cellIdentityLte);
+                    lteSs = convertHalLteSignalStrength(lte.signalStrengthLte);
+                    lteCc = new CellConfigLte();
+                    break;
+                case android.hardware.radio.V1_0.CellInfoType.WCDMA:
+                    type = CellInfo.TYPE_WCDMA;
+                    android.hardware.radio.V1_2.CellInfoWcdma wcdma = record.wcdma.get(0);
+                    wcdmaCi = convertHalCellIdentityWcdma(wcdma.cellIdentityWcdma);
+                    wcdmaSs = convertHalWcdmaSignalStrength(wcdma.signalStrengthWcdma);
+                    break;
+                case android.hardware.radio.V1_0.CellInfoType.TD_SCDMA:
+                    type = CellInfo.TYPE_TDSCDMA;
+                    android.hardware.radio.V1_2.CellInfoTdscdma tdscdma = record.tdscdma.get(0);
+                    tdscdmaCi = convertHalCellIdentityTdscdma(tdscdma.cellIdentityTdscdma);
+                    tdscdmaSs = convertHalTdscdmaSignalStrength(tdscdma.signalStrengthTdscdma);
+                    break;
+                default: return null;
+            }
+        } else if (cellInfo instanceof android.hardware.radio.V1_4.CellInfo) {
             final android.hardware.radio.V1_4.CellInfo record =
                     (android.hardware.radio.V1_4.CellInfo) cellInfo;
             connectionStatus = record.connectionStatus;
@@ -2531,13 +2665,43 @@ public class RILUtils {
     }
 
     /**
-     * Convert a CellIdentity defined in radio/1.2, 1.5/types.hal to CellIdentity
-     * @param halCi CellIdentity defined in radio/1.2, 1.5/types.hal
+     * Convert a CellIdentity defined in radio/1.0, 1.2, 1.5/types.hal to CellIdentity
+     * @param halCi CellIdentity defined in radio/1.0, 1.2, 1.5/types.hal
      * @return The converted CellIdentity
      */
     public static CellIdentity convertHalCellIdentity(Object halCi) {
         if (halCi == null) return null;
-        if (halCi instanceof android.hardware.radio.V1_2.CellIdentity) {
+        if (halCi instanceof android.hardware.radio.V1_0.CellIdentity) {
+            android.hardware.radio.V1_0.CellIdentity ci =
+                    (android.hardware.radio.V1_0.CellIdentity) halCi;
+            switch (ci.cellInfoType) {
+                case CellInfo.TYPE_GSM:
+                    if (ci.cellIdentityGsm.size() == 1) {
+                        return convertHalCellIdentityGsm(ci.cellIdentityGsm.get(0));
+                    }
+                    break;
+                case CellInfo.TYPE_CDMA:
+                    if (ci.cellIdentityCdma.size() == 1) {
+                        return convertHalCellIdentityCdma(ci.cellIdentityCdma.get(0));
+                    }
+                    break;
+                case CellInfo.TYPE_LTE:
+                    if (ci.cellIdentityLte.size() == 1) {
+                        return convertHalCellIdentityLte(ci.cellIdentityLte.get(0));
+                    }
+                    break;
+                case CellInfo.TYPE_WCDMA:
+                    if (ci.cellIdentityWcdma.size() == 1) {
+                        return convertHalCellIdentityWcdma(ci.cellIdentityWcdma.get(0));
+                    }
+                    break;
+                case CellInfo.TYPE_TDSCDMA:
+                    if (ci.cellIdentityTdscdma.size() == 1) {
+                        return convertHalCellIdentityTdscdma(ci.cellIdentityTdscdma.get(0));
+                    }
+                    break;
+            }
+        } else if (halCi instanceof android.hardware.radio.V1_2.CellIdentity) {
             android.hardware.radio.V1_2.CellIdentity ci =
                     (android.hardware.radio.V1_2.CellIdentity) halCi;
             switch (ci.cellInfoType) {
@@ -2614,13 +2778,19 @@ public class RILUtils {
     }
 
     /**
-     * Convert a CellIdentityGsm defined in radio/1.2, 1.5/types.hal to CellIdentityGsm
-     * @param gsm CellIdentityGsm defined in radio/1.2, 1.5/types.hal
+     * Convert a CellIdentityGsm defined in radio/1.0, 1.2, 1.5/types.hal to CellIdentityGsm
+     * @param gsm CellIdentityGsm defined in radio/1.0, 1.2, 1.5/types.hal
      * @return The converted CellIdentityGsm
      */
     public static CellIdentityGsm convertHalCellIdentityGsm(Object gsm) {
         if (gsm == null) return null;
-        if (gsm instanceof android.hardware.radio.V1_2.CellIdentityGsm) {
+        if (gsm instanceof android.hardware.radio.V1_0.CellIdentityGsm) {
+            android.hardware.radio.V1_0.CellIdentityGsm ci =
+                    (android.hardware.radio.V1_0.CellIdentityGsm) gsm;
+            return new CellIdentityGsm(ci.lac, ci.cid, ci.arfcn,
+                    ci.bsic == (byte) 0xFF ? CellInfo.UNAVAILABLE : ci.bsic, ci.mcc, ci.mnc, "", "",
+                    new ArraySet<>());
+        } else if (gsm instanceof android.hardware.radio.V1_2.CellIdentityGsm) {
             android.hardware.radio.V1_2.CellIdentityGsm ci =
                     (android.hardware.radio.V1_2.CellIdentityGsm) gsm;
             return new CellIdentityGsm(ci.base.lac, ci.base.cid, ci.base.arfcn,
@@ -2653,13 +2823,18 @@ public class RILUtils {
     }
 
     /**
-     * Convert a CellIdentityCdma defined in radio/1.2/types.hal to CellIdentityCdma
-     * @param cdma CellIdentityCdma defined in radio/1.2/types.hal
+     * Convert a CellIdentityCdma defined in radio/1.0, 1.2/types.hal to CellIdentityCdma
+     * @param cdma CellIdentityCdma defined in radio/1.0, 1.2/types.hal
      * @return The converted CellIdentityCdma
      */
     public static CellIdentityCdma convertHalCellIdentityCdma(Object cdma) {
         if (cdma == null) return null;
-        if (cdma instanceof android.hardware.radio.V1_2.CellIdentityCdma) {
+        if (cdma instanceof android.hardware.radio.V1_0.CellIdentityCdma) {
+            android.hardware.radio.V1_0.CellIdentityCdma ci =
+                    (android.hardware.radio.V1_0.CellIdentityCdma) cdma;
+            return new CellIdentityCdma(ci.networkId, ci.systemId, ci.baseStationId, ci.longitude,
+                    ci.latitude, "", "");
+        } else if (cdma instanceof android.hardware.radio.V1_2.CellIdentityCdma) {
             android.hardware.radio.V1_2.CellIdentityCdma ci =
                     (android.hardware.radio.V1_2.CellIdentityCdma) cdma;
             return new CellIdentityCdma(ci.base.networkId, ci.base.systemId, ci.base.baseStationId,
@@ -2682,13 +2857,18 @@ public class RILUtils {
     }
 
     /**
-     * Convert a CellIdentityLte defined in radio/1.2, 1.5/types.hal to CellIdentityLte
-     * @param lte CellIdentityLte defined in radio/1.2, 1.5/types.hal
+     * Convert a CellIdentityLte defined in radio/1.0, 1.2, 1.5/types.hal to CellIdentityLte
+     * @param lte CellIdentityLte defined in radio/1.0, 1.2, 1.5/types.hal
      * @return The converted CellIdentityLte
      */
     public static CellIdentityLte convertHalCellIdentityLte(Object lte) {
         if (lte == null) return null;
-        if (lte instanceof android.hardware.radio.V1_2.CellIdentityLte) {
+        if (lte instanceof android.hardware.radio.V1_0.CellIdentityLte) {
+            android.hardware.radio.V1_0.CellIdentityLte ci =
+                    (android.hardware.radio.V1_0.CellIdentityLte) lte;
+            return new CellIdentityLte(ci.ci, ci.pci, ci.tac, ci.earfcn, new int[] {},
+                    CellInfo.UNAVAILABLE, ci.mcc, ci.mnc, "", "", new ArraySet<>(), null);
+        } else if (lte instanceof android.hardware.radio.V1_2.CellIdentityLte) {
             android.hardware.radio.V1_2.CellIdentityLte ci =
                     (android.hardware.radio.V1_2.CellIdentityLte) lte;
             return new CellIdentityLte(ci.base.ci, ci.base.pci, ci.base.tac, ci.base.earfcn,
@@ -2722,13 +2902,18 @@ public class RILUtils {
     }
 
     /**
-     * Convert a CellIdentityWcdma defined in radio/1.2, 1.5/types.hal to CellIdentityWcdma
-     * @param wcdma CellIdentityWcdma defined in radio/1.2, 1.5/types.hal
+     * Convert a CellIdentityWcdma defined in radio/1.0, 1.2, 1.5/types.hal to CellIdentityWcdma
+     * @param wcdma CellIdentityWcdma defined in radio/1.0, 1.2, 1.5/types.hal
      * @return The converted CellIdentityWcdma
      */
     public static CellIdentityWcdma convertHalCellIdentityWcdma(Object wcdma) {
         if (wcdma == null) return null;
-        if (wcdma instanceof android.hardware.radio.V1_2.CellIdentityWcdma) {
+        if (wcdma instanceof android.hardware.radio.V1_0.CellIdentityWcdma) {
+            android.hardware.radio.V1_0.CellIdentityWcdma ci =
+                    (android.hardware.radio.V1_0.CellIdentityWcdma) wcdma;
+            return new CellIdentityWcdma(ci.lac, ci.cid, ci.psc, ci.uarfcn, ci.mcc, ci.mnc, "", "",
+                    new ArraySet<>(), null);
+        } else if (wcdma instanceof android.hardware.radio.V1_2.CellIdentityWcdma) {
             android.hardware.radio.V1_2.CellIdentityWcdma ci =
                     (android.hardware.radio.V1_2.CellIdentityWcdma) wcdma;
             return new CellIdentityWcdma(ci.base.lac, ci.base.cid, ci.base.psc, ci.base.uarfcn,
@@ -2760,13 +2945,18 @@ public class RILUtils {
     }
 
     /**
-     * Convert a CellIdentityTdscdma defined in radio/1.2, 1.5/types.hal to CellIdentityTdscdma
-     * @param tdscdma CellIdentityTdscdma defined in radio/1.2, 1.5/types.hal
+     * Convert a CellIdentityTdscdma defined in radio/1.0, 1.2, 1.5/types.hal to CellIdentityTdscdma
+     * @param tdscdma CellIdentityTdscdma defined in radio/1.0, 1.2, 1.5/types.hal
      * @return The converted CellIdentityTdscdma
      */
     public static CellIdentityTdscdma convertHalCellIdentityTdscdma(Object tdscdma) {
         if (tdscdma == null) return null;
-        if (tdscdma instanceof android.hardware.radio.V1_2.CellIdentityTdscdma) {
+        if (tdscdma instanceof android.hardware.radio.V1_0.CellIdentityTdscdma) {
+            android.hardware.radio.V1_0.CellIdentityTdscdma ci =
+                    (android.hardware.radio.V1_0.CellIdentityTdscdma) tdscdma;
+            return new CellIdentityTdscdma(ci.mcc, ci.mnc, ci.lac, ci.cid, ci.cpid,
+                    CellInfo.UNAVAILABLE, "", "", Collections.emptyList(), null);
+        } else if (tdscdma instanceof android.hardware.radio.V1_2.CellIdentityTdscdma) {
             android.hardware.radio.V1_2.CellIdentityTdscdma ci =
                     (android.hardware.radio.V1_2.CellIdentityTdscdma) tdscdma;
             return new CellIdentityTdscdma(ci.base.mcc, ci.base.mnc, ci.base.lac, ci.base.cid,
@@ -2786,7 +2976,7 @@ public class RILUtils {
 
     /**
      * Convert a CellIdentityTdscdma defined in CellIdentityTdscdma.aidl to CellIdentityTdscdma
-     * @param cid CellIdentityTdscdma defined in radio/1.2, 1.5/types.hal
+     * @param cid CellIdentityTdscdma defined in radio/1.0, 1.2, 1.5/types.hal
      * @return The converted CellIdentityTdscdma
      */
     public static CellIdentityTdscdma convertHalCellIdentityTdscdma(
@@ -2835,13 +3025,31 @@ public class RILUtils {
     }
 
     /**
-     * Convert a SignalStrength defined in radio/1.4, 1.6/types.hal to SignalStrength
-     * @param ss SignalStrength defined in radio/1.4, 1.6/types.hal
+     * Convert a SignalStrength defined in radio/1.0, 1.2, 1.4, 1.6/types.hal to SignalStrength
+     * @param ss SignalStrength defined in radio/1.0, 1.2, 1.4, 1.6/types.hal
      * @return The converted SignalStrength
      */
     public static SignalStrength convertHalSignalStrength(Object ss) {
         if (ss == null) return null;
-        if (ss instanceof android.hardware.radio.V1_4.SignalStrength) {
+        if (ss instanceof android.hardware.radio.V1_0.SignalStrength) {
+            android.hardware.radio.V1_0.SignalStrength signalStrength =
+                    (android.hardware.radio.V1_0.SignalStrength) ss;
+            return new SignalStrength(
+                    convertHalCdmaSignalStrength(signalStrength.cdma, signalStrength.evdo),
+                    convertHalGsmSignalStrength(signalStrength.gw), new CellSignalStrengthWcdma(),
+                    convertHalTdscdmaSignalStrength(signalStrength.tdScdma),
+                    convertHalLteSignalStrength(signalStrength.lte),
+                    new CellSignalStrengthNr());
+        } else if (ss instanceof android.hardware.radio.V1_2.SignalStrength) {
+            android.hardware.radio.V1_2.SignalStrength signalStrength =
+                    (android.hardware.radio.V1_2.SignalStrength) ss;
+            return new SignalStrength(
+                    convertHalCdmaSignalStrength(signalStrength.cdma, signalStrength.evdo),
+                    convertHalGsmSignalStrength(signalStrength.gsm),
+                    convertHalWcdmaSignalStrength(signalStrength.wcdma),
+                    convertHalTdscdmaSignalStrength(signalStrength.tdScdma),
+                    convertHalLteSignalStrength(signalStrength.lte), new CellSignalStrengthNr());
+        } else if (ss instanceof android.hardware.radio.V1_4.SignalStrength) {
             android.hardware.radio.V1_4.SignalStrength signalStrength =
                     (android.hardware.radio.V1_4.SignalStrength) ss;
             return new SignalStrength(
@@ -2989,19 +3197,29 @@ public class RILUtils {
     }
 
     /**
-     * Convert a WcdmaSignalStrength defined in radio/1.2/types.hal to CellSignalStrengthWcdma
-     * @param wcdma WcdmaSignalStrength defined in radio/1.2/types.hal
+     * Convert a WcdmaSignalStrength defined in radio/1.0, 1.2/types.hal to CellSignalStrengthWcdma
+     * @param wcdma WcdmaSignalStrength defined in radio/1.0, 1.2/types.hal
      * @return The converted CellSignalStrengthWcdma
      */
     public static CellSignalStrengthWcdma convertHalWcdmaSignalStrength(Object wcdma) {
         if (wcdma == null) return null;
-        android.hardware.radio.V1_2.WcdmaSignalStrength ss =
-                (android.hardware.radio.V1_2.WcdmaSignalStrength) wcdma;
-        CellSignalStrengthWcdma ret = new CellSignalStrengthWcdma(
-                CellSignalStrength.getRssiDbmFromAsu(ss.base.signalStrength),
-                ss.base.bitErrorRate, CellSignalStrength.getRscpDbmFromAsu(ss.rscp),
-                CellSignalStrength.getEcNoDbFromAsu(ss.ecno));
-        if (ret.getRssi() == CellInfo.UNAVAILABLE && ret.getRscp() == CellInfo.UNAVAILABLE) {
+        CellSignalStrengthWcdma ret = null;
+        if (wcdma instanceof android.hardware.radio.V1_0.WcdmaSignalStrength) {
+            android.hardware.radio.V1_0.WcdmaSignalStrength ss =
+                    (android.hardware.radio.V1_0.WcdmaSignalStrength) wcdma;
+            ret = new CellSignalStrengthWcdma(
+                    CellSignalStrength.getRssiDbmFromAsu(ss.signalStrength), ss.bitErrorRate,
+                    CellInfo.UNAVAILABLE, CellInfo.UNAVAILABLE);
+        } else if (wcdma instanceof android.hardware.radio.V1_2.WcdmaSignalStrength) {
+            android.hardware.radio.V1_2.WcdmaSignalStrength ss =
+                    (android.hardware.radio.V1_2.WcdmaSignalStrength) wcdma;
+            ret = new CellSignalStrengthWcdma(
+                    CellSignalStrength.getRssiDbmFromAsu(ss.base.signalStrength),
+                    ss.base.bitErrorRate, CellSignalStrength.getRscpDbmFromAsu(ss.rscp),
+                    CellSignalStrength.getEcNoDbFromAsu(ss.ecno));
+        }
+        if (ret != null && ret.getRssi() == CellInfo.UNAVAILABLE
+                && ret.getRscp() == CellInfo.UNAVAILABLE) {
             ret.setDefaultValues();
             ret.updateLevel(null, null);
         }
@@ -3027,18 +3245,29 @@ public class RILUtils {
     }
 
     /**
-     * Convert a TdscdmaSignalStrength defined in radio/1.2/types.hal to CellSignalStrengthTdscdma
-     * @param tdscdma TdscdmaSignalStrength defined in radio/1.2/types.hal
+     * Convert a TdScdmaSignalStrength defined in radio/1.0/types.hal or TdscdmaSignalStrength
+     * defined in radio/1.2/types.hal to CellSignalStrengthTdscdma
+     * @param tdscdma TdScdmaSignalStrength defined in radio/1.0/types.hal or TdscdmaSignalStrength
+     *        defined in radio/1.2/types.hal
      * @return The converted CellSignalStrengthTdscdma
      */
     public static CellSignalStrengthTdscdma convertHalTdscdmaSignalStrength(Object tdscdma) {
         if (tdscdma == null) return null;
-        android.hardware.radio.V1_2.TdscdmaSignalStrength ss =
-                (android.hardware.radio.V1_2.TdscdmaSignalStrength) tdscdma;
-        CellSignalStrengthTdscdma ret = new CellSignalStrengthTdscdma(
-                CellSignalStrength.getRssiDbmFromAsu(ss.signalStrength), ss.bitErrorRate,
-                CellSignalStrength.getRscpDbmFromAsu(ss.rscp));
-        if (ret.getRssi() == CellInfo.UNAVAILABLE && ret.getRscp() == CellInfo.UNAVAILABLE) {
+        CellSignalStrengthTdscdma ret = null;
+        if (tdscdma instanceof android.hardware.radio.V1_0.TdScdmaSignalStrength) {
+            android.hardware.radio.V1_0.TdScdmaSignalStrength ss =
+                    (android.hardware.radio.V1_0.TdScdmaSignalStrength) tdscdma;
+            ret = new CellSignalStrengthTdscdma(CellInfo.UNAVAILABLE, CellInfo.UNAVAILABLE,
+                    ss.rscp != CellInfo.UNAVAILABLE ? -ss.rscp : ss.rscp);
+        } else if (tdscdma instanceof android.hardware.radio.V1_2.TdscdmaSignalStrength) {
+            android.hardware.radio.V1_2.TdscdmaSignalStrength ss =
+                    (android.hardware.radio.V1_2.TdscdmaSignalStrength) tdscdma;
+            ret = new CellSignalStrengthTdscdma(
+                    CellSignalStrength.getRssiDbmFromAsu(ss.signalStrength), ss.bitErrorRate,
+                    CellSignalStrength.getRscpDbmFromAsu(ss.rscp));
+        }
+        if (ret != null && ret.getRssi() == CellInfo.UNAVAILABLE
+                && ret.getRscp() == CellInfo.UNAVAILABLE) {
             ret.setDefaultValues();
             ret.updateLevel(null, null);
         }
@@ -3223,9 +3452,9 @@ public class RILUtils {
     }
 
     /**
-     * Convert SetupDataCallResult defined in radio/1.4, 1.5, 1.6/types.hal into
+     * Convert SetupDataCallResult defined in radio/1.0, 1.4, 1.5, 1.6/types.hal into
      * DataCallResponse
-     * @param dcResult SetupDataCallResult defined in radio/1.4, 1.5, 1.6/types.hal
+     * @param dcResult SetupDataCallResult defined in radio/1.0, 1.4, 1.5, 1.6/types.hal
      * @return The converted DataCallResponse
      */
     @VisibleForTesting
@@ -3236,10 +3465,10 @@ public class RILUtils {
         long suggestedRetryTime;
         String ifname;
         int protocolType;
-        String[] addresses;
-        String[] dnses;
-        String[] gateways;
-        String[] pcscfs;
+        String[] addresses = null;
+        String[] dnses = null;
+        String[] gateways = null;
+        String[] pcscfs = null;
         Qos defaultQos = null;
         @DataCallResponse.HandoverFailureMode
         int handoverFailureMode = DataCallResponse.HANDOVER_FAILURE_MODE_LEGACY;
@@ -3249,7 +3478,34 @@ public class RILUtils {
         NetworkSliceInfo sliceInfo = null;
         List<TrafficDescriptor> trafficDescriptors = new ArrayList<>();
 
-        if (dcResult instanceof android.hardware.radio.V1_4.SetupDataCallResult) {
+        if (dcResult instanceof android.hardware.radio.V1_0.SetupDataCallResult) {
+            final android.hardware.radio.V1_0.SetupDataCallResult result =
+                    (android.hardware.radio.V1_0.SetupDataCallResult) dcResult;
+            cause = result.status;
+            suggestedRetryTime = result.suggestedRetryTime;
+            cid = result.cid;
+            active = result.active;
+            protocolType = ApnSetting.getProtocolIntFromString(result.type);
+            ifname = result.ifname;
+            if (!TextUtils.isEmpty(result.addresses)) {
+                addresses = result.addresses.split("\\s+");
+            }
+            if (!TextUtils.isEmpty(result.dnses)) {
+                dnses = result.dnses.split("\\s+");
+            }
+            if (!TextUtils.isEmpty(result.gateways)) {
+                gateways = result.gateways.split("\\s+");
+            }
+            if (!TextUtils.isEmpty(result.pcscf)) {
+                pcscfs = result.pcscf.split("\\s+");
+            }
+            mtu = mtuV4 = mtuV6 = result.mtu;
+            if (addresses != null) {
+                for (String address : addresses) {
+                    laList.add(convertToLinkAddress(address));
+                }
+            }
+        } else if (dcResult instanceof android.hardware.radio.V1_4.SetupDataCallResult) {
             final android.hardware.radio.V1_4.SetupDataCallResult result =
                     (android.hardware.radio.V1_4.SetupDataCallResult) dcResult;
             cause = result.cause;
@@ -3802,10 +4058,10 @@ public class RILUtils {
     }
 
     /**
-     * Convert a list of SetupDataCallResult defined in radio/1.4, 1.5, 1.6/types.hal into
+     * Convert a list of SetupDataCallResult defined in radio/1.0, 1.4, 1.5, 1.6/types.hal into
      * a list of DataCallResponse
      * @param dataCallResultList List of SetupDataCallResult defined in
-     *        radio/1.4, 1.5, 1.6/types.hal
+     *        radio/1.0, 1.4, 1.5, 1.6/types.hal
      * @return The converted list of DataCallResponses
      */
     @VisibleForTesting
@@ -3895,8 +4151,8 @@ public class RILUtils {
     }
 
     /**
-     * Convert Call defined in radio/1.2, 1.6/types.hal to DriverCall
-     * @param halCall Call defined in radio/1.2, 1.6/types.hal
+     * Convert Call defined in radio/1.0, 1.2, 1.6/types.hal to DriverCall
+     * @param halCall Call defined in radio/1.0, 1.2, 1.6/types.hal
      * @return The converted DriverCall
      */
     public static DriverCall convertToDriverCall(Object halCall) {
@@ -3912,13 +4168,17 @@ public class RILUtils {
             call16 = null;
             call12 = (android.hardware.radio.V1_2.Call) halCall;
             call10 = call12.base;
+        } else if (halCall instanceof android.hardware.radio.V1_0.Call) {
+            call16 = null;
+            call12 = null;
+            call10 = (android.hardware.radio.V1_0.Call) halCall;
         } else {
             call16 = null;
             call12 = null;
             call10 = null;
         }
         if (call10 != null) {
-            dc.state = DriverCall.stateFromCLCC(call10.state);
+            dc.state = DriverCall.stateFromCLCC((int) (call10.state));
             dc.index = call10.index;
             dc.TOA = call10.toa;
             dc.isMpty = call10.isMpty;
@@ -3927,9 +4187,10 @@ public class RILUtils {
             dc.isVoice = call10.isVoice;
             dc.isVoicePrivacy = call10.isVoicePrivacy;
             dc.number = call10.number;
-            dc.numberPresentation = DriverCall.presentationFromCLIP(call10.numberPresentation);
+            dc.numberPresentation = DriverCall.presentationFromCLIP(
+                    (int) (call10.numberPresentation));
             dc.name = call10.name;
-            dc.namePresentation = DriverCall.presentationFromCLIP(call10.namePresentation);
+            dc.namePresentation = DriverCall.presentationFromCLIP((int) (call10.namePresentation));
             if (call10.uusInfo.size() == 1) {
                 dc.uusInfo = new UUSInfo();
                 dc.uusInfo.setType(call10.uusInfo.get(0).uusType);
@@ -3943,7 +4204,7 @@ public class RILUtils {
             dc.number = PhoneNumberUtils.stringFromStringAndTOA(dc.number, dc.TOA);
         }
         if (call12 != null) {
-            dc.audioQuality = call12.audioQuality;
+            dc.audioQuality = (int) (call12.audioQuality);
         }
         if (call16 != null) {
             dc.forwardedNumber = call16.forwardedNumber;
@@ -3958,7 +4219,7 @@ public class RILUtils {
      */
     public static DriverCall convertToDriverCall(android.hardware.radio.voice.Call halCall) {
         DriverCall dc = new DriverCall();
-        dc.state = DriverCall.stateFromCLCC(halCall.state);
+        dc.state = DriverCall.stateFromCLCC((int) halCall.state);
         dc.index = halCall.index;
         dc.TOA = halCall.toa;
         dc.isMpty = halCall.isMpty;
@@ -3967,9 +4228,9 @@ public class RILUtils {
         dc.isVoice = halCall.isVoice;
         dc.isVoicePrivacy = halCall.isVoicePrivacy;
         dc.number = halCall.number;
-        dc.numberPresentation = DriverCall.presentationFromCLIP(halCall.numberPresentation);
+        dc.numberPresentation = DriverCall.presentationFromCLIP((int) halCall.numberPresentation);
         dc.name = halCall.name;
-        dc.namePresentation = DriverCall.presentationFromCLIP(halCall.namePresentation);
+        dc.namePresentation = DriverCall.presentationFromCLIP((int) halCall.namePresentation);
         if (halCall.uusInfo.length == 1) {
             dc.uusInfo = new UUSInfo();
             dc.uusInfo.setType(halCall.uusInfo[0].uusType);
@@ -3980,7 +4241,7 @@ public class RILUtils {
         }
         // Make sure there's a leading + on addresses with a TOA of 145
         dc.number = PhoneNumberUtils.stringFromStringAndTOA(dc.number, dc.TOA);
-        dc.audioQuality = halCall.audioQuality;
+        dc.audioQuality = (int) halCall.audioQuality;
         dc.forwardedNumber = halCall.forwardedNumber;
         return dc;
     }
diff --git a/src/java/com/android/internal/telephony/RadioConfig.java b/src/java/com/android/internal/telephony/RadioConfig.java
index 13f65028b6..1b8b15628e 100644
--- a/src/java/com/android/internal/telephony/RadioConfig.java
+++ b/src/java/com/android/internal/telephony/RadioConfig.java
@@ -62,6 +62,7 @@ public class RadioConfig extends Handler {
     static final int EVENT_HIDL_SERVICE_DEAD = 1;
     static final int EVENT_AIDL_SERVICE_DEAD = 2;
     static final HalVersion RADIO_CONFIG_HAL_VERSION_UNKNOWN = new HalVersion(-1, -1);
+    static final HalVersion RADIO_CONFIG_HAL_VERSION_1_0 = new HalVersion(1, 0);
     static final HalVersion RADIO_CONFIG_HAL_VERSION_1_1 = new HalVersion(1, 1);
     static final HalVersion RADIO_CONFIG_HAL_VERSION_1_3 = new HalVersion(1, 3);
     static final HalVersion RADIO_CONFIG_HAL_VERSION_2_0 = new HalVersion(2, 0);
@@ -319,7 +320,13 @@ public class RadioConfig extends Handler {
         }
 
         if (mRadioConfigProxy.isEmpty()) {
-            loge("IRadioConfig <1.1 is no longer supported.");
+            try {
+                mRadioConfigProxy.setHidl(RADIO_CONFIG_HAL_VERSION_1_0,
+                        android.hardware.radio.config.V1_0.IRadioConfig.getService(true));
+            } catch (RemoteException | NoSuchElementException e) {
+                mRadioConfigProxy.clear();
+                loge("getHidlRadioConfigProxy1_0: RadioConfigProxy getService | linkToDeath: " + e);
+            }
         }
 
         if (!mRadioConfigProxy.isEmpty()) {
diff --git a/src/java/com/android/internal/telephony/RadioConfigProxy.java b/src/java/com/android/internal/telephony/RadioConfigProxy.java
index b6c6d68470..79f3d70b9e 100644
--- a/src/java/com/android/internal/telephony/RadioConfigProxy.java
+++ b/src/java/com/android/internal/telephony/RadioConfigProxy.java
@@ -35,7 +35,7 @@ public class RadioConfigProxy {
     private final RadioConfigHidlServiceDeathRecipient mRadioConfigHidlServiceDeathRecipient;
     private final RadioConfigAidlServiceDeathRecipient mRadioConfigAidlServiceDeathRecipient;
 
-    private volatile android.hardware.radio.config.V1_1.IRadioConfig mHidlRadioConfigProxy = null;
+    private volatile android.hardware.radio.config.V1_0.IRadioConfig mHidlRadioConfigProxy = null;
     private volatile android.hardware.radio.config.IRadioConfig mAidlRadioConfigProxy = null;
 
     private HalVersion mRadioConfigHalVersion = RadioConfig.RADIO_CONFIG_HAL_VERSION_UNKNOWN;
@@ -57,19 +57,27 @@ public class RadioConfigProxy {
      */
     public void setHidl(
             HalVersion radioConfigHalVersion,
-            android.hardware.radio.config.V1_1.IRadioConfig radioConfig) {
+            android.hardware.radio.config.V1_0.IRadioConfig radioConfig) {
         mRadioConfigHalVersion = radioConfigHalVersion;
         mHidlRadioConfigProxy = radioConfig;
         mIsAidl = false;
         mRadioConfigHidlServiceDeathRecipient.setService(radioConfig);
     }
 
+    /**
+     * Get HIDL IRadioConfig V1_0
+     * @return IRadioConfigV1_0
+     */
+    public android.hardware.radio.config.V1_0.IRadioConfig getHidl10() {
+        return mHidlRadioConfigProxy;
+    }
+
     /**
      * Get HIDL IRadioConfig V1_1
      * @return IRadioConfigV1_1
      */
     public android.hardware.radio.config.V1_1.IRadioConfig getHidl11() {
-        return mHidlRadioConfigProxy;
+        return (android.hardware.radio.config.V1_1.IRadioConfig) mHidlRadioConfigProxy;
     }
 
     /**
@@ -184,7 +192,7 @@ public class RadioConfigProxy {
         if (isAidl()) {
             getAidl().getSimSlotsStatus(serial);
         } else {
-            getHidl11().getSimSlotsStatus(serial);
+            getHidl10().getSimSlotsStatus(serial);
         }
     }
 
@@ -219,7 +227,7 @@ public class RadioConfigProxy {
         if (isAidl()) {
             getAidl().setSimSlotsMapping(serial, RILUtils.convertSimSlotsMapping(slotMapping));
         } else {
-            getHidl11().setSimSlotsMapping(serial,
+            getHidl10().setSimSlotsMapping(serial,
                     RILUtils.convertSlotMappingToList(slotMapping));
         }
     }
@@ -267,13 +275,13 @@ public class RadioConfigProxy {
         private static final String TAG = "RadioConfigHidlSDR";
 
         private final RadioConfig mRadioConfig;
-        private android.hardware.radio.config.V1_1.IRadioConfig mService;
+        private android.hardware.radio.config.V1_0.IRadioConfig mService;
 
         RadioConfigHidlServiceDeathRecipient(RadioConfig radioConfig) {
             mRadioConfig = radioConfig;
         }
 
-        public void setService(android.hardware.radio.config.V1_1.IRadioConfig service) {
+        public void setService(android.hardware.radio.config.V1_0.IRadioConfig service) {
             mService = service;
         }
 
diff --git a/src/java/com/android/internal/telephony/RadioDataProxy.java b/src/java/com/android/internal/telephony/RadioDataProxy.java
index 40db9e5b3d..9671077b0f 100644
--- a/src/java/com/android/internal/telephony/RadioDataProxy.java
+++ b/src/java/com/android/internal/telephony/RadioDataProxy.java
@@ -22,7 +22,9 @@ import android.os.AsyncResult;
 import android.os.Message;
 import android.os.RemoteException;
 import android.telephony.Rlog;
+import android.telephony.ServiceState;
 import android.telephony.data.DataProfile;
+import android.telephony.data.DataService;
 import android.telephony.data.NetworkSliceInfo;
 import android.telephony.data.TrafficDescriptor;
 
@@ -32,8 +34,8 @@ import java.net.InetAddress;
 import java.util.ArrayList;
 
 /**
- * A holder for IRadioData.
- * Use getAidl to get IRadioData and call the AIDL implementations of the HAL APIs.
+ * A holder for IRadioData. Use getHidl to get IRadio 1.0 and call the HIDL implementations or
+ * getAidl to get IRadioData and call the AIDL implementations of the HAL APIs.
  */
 public class RadioDataProxy extends RadioServiceProxy {
     private static final String TAG = "RadioDataProxy";
@@ -127,8 +129,12 @@ public class RadioDataProxy extends RadioServiceProxy {
         if (isEmpty()) return;
         if (isAidl()) {
             mDataProxy.deactivateDataCall(serial, cid, reason);
+        } else if (mHalVersion.greaterOrEqual(RIL.RADIO_HAL_VERSION_1_2)) {
+            ((android.hardware.radio.V1_2.IRadio) mRadioProxy).deactivateDataCall_1_2(
+                    serial, cid, reason);
         } else {
-            mRadioProxy.deactivateDataCall_1_2(serial, cid, reason);
+            mRadioProxy.deactivateDataCall(serial, cid,
+                    reason == DataService.REQUEST_REASON_SHUTDOWN);
         }
     }
 
@@ -210,9 +216,11 @@ public class RadioDataProxy extends RadioServiceProxy {
      * Call IRadioData#setDataProfile
      * @param serial Serial number of request
      * @param profiles Array of DataProfiles to set
+     * @param isRoaming Whether or not the device is roaming
      * @throws RemoteException
      */
-    public void setDataProfile(int serial, DataProfile[] profiles) throws RemoteException {
+    public void setDataProfile(int serial, DataProfile[] profiles, boolean isRoaming)
+            throws RemoteException {
         if (isEmpty()) return;
         if (isAidl()) {
             android.hardware.radio.data.DataProfileInfo[] dpis =
@@ -227,12 +235,22 @@ public class RadioDataProxy extends RadioServiceProxy {
                 dpis.add(RILUtils.convertToHalDataProfile15(dp));
             }
             ((android.hardware.radio.V1_5.IRadio) mRadioProxy).setDataProfile_1_5(serial, dpis);
-        } else {
+        } else if (mHalVersion.greaterOrEqual(RIL.RADIO_HAL_VERSION_1_4)) {
             ArrayList<android.hardware.radio.V1_4.DataProfileInfo> dpis = new ArrayList<>();
             for (DataProfile dp : profiles) {
                 dpis.add(RILUtils.convertToHalDataProfile14(dp));
             }
-            mRadioProxy.setDataProfile_1_4(serial, dpis);
+            ((android.hardware.radio.V1_4.IRadio) mRadioProxy).setDataProfile_1_4(serial, dpis);
+        } else {
+            ArrayList<android.hardware.radio.V1_0.DataProfileInfo> dpis = new ArrayList<>();
+            for (DataProfile dp : profiles) {
+                if (dp.isPersistent()) {
+                    dpis.add(RILUtils.convertToHalDataProfile10(dp));
+                }
+            }
+            if (!dpis.isEmpty()) {
+                mRadioProxy.setDataProfile(serial, dpis, isRoaming);
+            }
         }
     }
 
@@ -259,9 +277,10 @@ public class RadioDataProxy extends RadioServiceProxy {
      * Call IRadioData#setInitialAttachApn
      * @param serial Serial number of request
      * @param dataProfile Data profile containing APN settings
+     * @param isRoaming Whether or not the device is roaming
      * @throws RemoteException
      */
-    public void setInitialAttachApn(int serial, DataProfile dataProfile)
+    public void setInitialAttachApn(int serial, DataProfile dataProfile, boolean isRoaming)
             throws RemoteException {
         if (isEmpty()) return;
         if (isAidl()) {
@@ -269,17 +288,22 @@ public class RadioDataProxy extends RadioServiceProxy {
         } else if (mHalVersion.greaterOrEqual(RIL.RADIO_HAL_VERSION_1_5)) {
             ((android.hardware.radio.V1_5.IRadio) mRadioProxy).setInitialAttachApn_1_5(serial,
                     RILUtils.convertToHalDataProfile15(dataProfile));
-        } else {
-            mRadioProxy.setInitialAttachApn_1_4(serial,
+        } else if (mHalVersion.greaterOrEqual(RIL.RADIO_HAL_VERSION_1_4)) {
+            ((android.hardware.radio.V1_4.IRadio) mRadioProxy).setInitialAttachApn_1_4(serial,
                     RILUtils.convertToHalDataProfile14(dataProfile));
+        } else {
+            mRadioProxy.setInitialAttachApn(serial, RILUtils.convertToHalDataProfile10(dataProfile),
+                    dataProfile.isPersistent(), isRoaming);
         }
     }
 
     /**
      * Call IRadioData#setupDataCall
      * @param serial Serial number of request
+     * @param phoneId Phone ID of the requestor
      * @param accessNetwork Access network to setup the data call
      * @param dataProfileInfo Data profile info
+     * @param isRoaming Whether or not the device is roaming
      * @param roamingAllowed Whether or not data roaming is allowed by the user
      * @param reason Request reason
      * @param linkProperties LinkProperties containing address and DNS info
@@ -292,14 +316,15 @@ public class RadioDataProxy extends RadioServiceProxy {
      *                            is allowed
      * @throws RemoteException
      */
-    public void setupDataCall(int serial, int accessNetwork, DataProfile dataProfileInfo,
-            boolean roamingAllowed, int reason, LinkProperties linkProperties, int pduSessionId,
-            NetworkSliceInfo sliceInfo, TrafficDescriptor trafficDescriptor,
-            boolean matchAllRuleAllowed) throws RemoteException {
+    public void setupDataCall(int serial, int phoneId, int accessNetwork,
+            DataProfile dataProfileInfo, boolean isRoaming, boolean roamingAllowed, int reason,
+            LinkProperties linkProperties, int pduSessionId, NetworkSliceInfo sliceInfo,
+            TrafficDescriptor trafficDescriptor, boolean matchAllRuleAllowed)
+            throws RemoteException {
         if (isEmpty()) return;
         ArrayList<String> addresses = new ArrayList<>();
         ArrayList<String> dnses = new ArrayList<>();
-        String[] dnsesArr;
+        String[] dnsesArr = null;
         if (linkProperties != null) {
             for (InetAddress address : linkProperties.getAddresses()) {
                 addresses.add(address.getHostAddress());
@@ -336,10 +361,31 @@ public class RadioDataProxy extends RadioServiceProxy {
                     accessNetwork, RILUtils.convertToHalDataProfile15(dataProfileInfo),
                     roamingAllowed, reason, RILUtils.convertToHalLinkProperties15(linkProperties),
                     dnses);
-        } else {
-            mRadioProxy.setupDataCall_1_4(serial, accessNetwork,
-                    RILUtils.convertToHalDataProfile14(dataProfileInfo),
+        } else if (mHalVersion.greaterOrEqual(RIL.RADIO_HAL_VERSION_1_4)) {
+            ((android.hardware.radio.V1_4.IRadio) mRadioProxy).setupDataCall_1_4(serial,
+                    accessNetwork, RILUtils.convertToHalDataProfile14(dataProfileInfo),
                     roamingAllowed, reason, addresses, dnses);
+        } else if (mHalVersion.greaterOrEqual(RIL.RADIO_HAL_VERSION_1_2)) {
+            ((android.hardware.radio.V1_2.IRadio) mRadioProxy).setupDataCall_1_2(serial,
+                    accessNetwork, RILUtils.convertToHalDataProfile10(dataProfileInfo),
+                    dataProfileInfo.isPersistent(), roamingAllowed, isRoaming, reason, addresses,
+                    dnses);
+        } else {
+            // Getting data RAT here is just a workaround to support the older 1.0 vendor RIL.
+            // The new data service interface passes access network type instead of RAT for
+            // setup data request. It is impossible to convert access network type back to RAT here,
+            // so we directly get the data RAT from phone.
+            int dataRat = ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN;
+            Phone phone = PhoneFactory.getPhone(phoneId);
+            if (phone != null) {
+                ServiceState ss = phone.getServiceState();
+                if (ss != null) {
+                    dataRat = ss.getRilDataRadioTechnology();
+                }
+            }
+            mRadioProxy.setupDataCall(serial, dataRat,
+                    RILUtils.convertToHalDataProfile10(dataProfileInfo),
+                    dataProfileInfo.isPersistent(), roamingAllowed, isRoaming);
         }
     }
 
@@ -369,7 +415,7 @@ public class RadioDataProxy extends RadioServiceProxy {
      */
     public void startKeepalive(int serial, int contextId, KeepalivePacketData packetData,
             int intervalMillis, Message result) throws RemoteException {
-        if (isEmpty()) return;
+        if (isEmpty() || mHalVersion.less(RIL.RADIO_HAL_VERSION_1_1)) return;
         if (isAidl()) {
             android.hardware.radio.data.KeepaliveRequest req =
                     new android.hardware.radio.data.KeepaliveRequest();
@@ -430,7 +476,7 @@ public class RadioDataProxy extends RadioServiceProxy {
             req.destinationPort = packetData.getDstPort();
             req.maxKeepaliveIntervalMillis = intervalMillis;
 
-            mRadioProxy.startKeepalive(serial, req);
+            ((android.hardware.radio.V1_1.IRadio) mRadioProxy).startKeepalive(serial, req);
         }
     }
 
@@ -441,11 +487,11 @@ public class RadioDataProxy extends RadioServiceProxy {
      * @throws RemoteException
      */
     public void stopKeepalive(int serial, int sessionHandle) throws RemoteException {
-        if (isEmpty()) return;
+        if (isEmpty() || mHalVersion.less(RIL.RADIO_HAL_VERSION_1_1)) return;
         if (isAidl()) {
             mDataProxy.stopKeepalive(serial, sessionHandle);
         } else {
-            mRadioProxy.stopKeepalive(serial, sessionHandle);
+            ((android.hardware.radio.V1_1.IRadio) mRadioProxy).stopKeepalive(serial, sessionHandle);
         }
     }
 }
diff --git a/src/java/com/android/internal/telephony/RadioIndication.java b/src/java/com/android/internal/telephony/RadioIndication.java
index aadfe62499..b29a7bf434 100644
--- a/src/java/com/android/internal/telephony/RadioIndication.java
+++ b/src/java/com/android/internal/telephony/RadioIndication.java
@@ -240,18 +240,28 @@ public class RadioIndication extends IRadioIndication.Stub {
     }
 
     public void currentSignalStrength(int indicationType,
-            android.hardware.radio.V1_0.SignalStrength signalStrength) {
-        mRil.unsljLogMore(RIL_UNSOL_SIGNAL_STRENGTH, "unsupported on IRadio < 1.4");
+                                      android.hardware.radio.V1_0.SignalStrength signalStrength) {
+        mRil.processIndication(HAL_SERVICE_RADIO, indicationType);
+
+        SignalStrength ssInitial = RILUtils.convertHalSignalStrength(signalStrength);
+
+        SignalStrength ss = mRil.fixupSignalStrength10(ssInitial);
+        // Note this is set to "verbose" because it happens frequently
+        if (mRil.isLogvOrTrace()) mRil.unsljLogvRet(RIL_UNSOL_SIGNAL_STRENGTH, ss);
+
+        if (mRil.mSignalStrengthRegistrant != null) {
+            mRil.mSignalStrengthRegistrant.notifyRegistrant(new AsyncResult (null, ss, null));
+        }
     }
 
     /**
      * Indicates current link capacity estimate.
      */
     public void currentLinkCapacityEstimate(int indicationType,
-            android.hardware.radio.V1_2.LinkCapacityEstimate lce) {
+                                            android.hardware.radio.V1_2.LinkCapacityEstimate lce) {
         mRil.processIndication(HAL_SERVICE_RADIO, indicationType);
 
-        List<LinkCapacityEstimate> response = RILUtils.convertHalLinkCapacityEstimate(lce);
+        List<LinkCapacityEstimate> response = RILUtils.convertHalLceData(lce);
 
         if (mRil.isLogOrTrace()) mRil.unsljLogRet(RIL_UNSOL_LCEDATA_RECV, response);
 
@@ -267,7 +277,7 @@ public class RadioIndication extends IRadioIndication.Stub {
             android.hardware.radio.V1_6.LinkCapacityEstimate lce) {
         mRil.processIndication(HAL_SERVICE_RADIO, indicationType);
 
-        List<LinkCapacityEstimate> response = RILUtils.convertHalLinkCapacityEstimate(lce);
+        List<LinkCapacityEstimate> response = RILUtils.convertHalLceData(lce);
 
         if (mRil.isLogOrTrace()) mRil.unsljLogRet(RIL_UNSOL_LCEDATA_RECV, response);
 
@@ -280,8 +290,16 @@ public class RadioIndication extends IRadioIndication.Stub {
      * Indicates the current signal strength of the camped or primary serving cell.
      */
     public void currentSignalStrength_1_2(int indicationType,
-            android.hardware.radio.V1_2.SignalStrength signalStrength) {
-        mRil.unsljLogMore(RIL_UNSOL_SIGNAL_STRENGTH, "unsupported on IRadio < 1.4");
+                                      android.hardware.radio.V1_2.SignalStrength signalStrength) {
+        mRil.processIndication(HAL_SERVICE_RADIO, indicationType);
+
+        SignalStrength ss = RILUtils.convertHalSignalStrength(signalStrength);
+        // Note this is set to "verbose" because it happens frequently
+        if (mRil.isLogvOrTrace()) mRil.unsljLogvRet(RIL_UNSOL_SIGNAL_STRENGTH, ss);
+
+        if (mRil.mSignalStrengthRegistrant != null) {
+            mRil.mSignalStrengthRegistrant.notifyRegistrant(new AsyncResult(null, ss, null));
+        }
     }
 
     /**
@@ -341,7 +359,8 @@ public class RadioIndication extends IRadioIndication.Stub {
      */
     public void currentPhysicalChannelConfigs(int indicationType,
             ArrayList<android.hardware.radio.V1_2.PhysicalChannelConfig> configs) {
-        mRil.unsljLogMore(RIL_UNSOL_PHYSICAL_CHANNEL_CONFIG, "unsupported on IRadio < 1.4");
+        mRil.processIndication(HAL_SERVICE_RADIO, indicationType);
+        physicalChannelConfigsIndication(configs);
     }
 
     /**
@@ -374,7 +393,7 @@ public class RadioIndication extends IRadioIndication.Stub {
     /** Indicates current data call list. */
     public void dataCallListChanged(int indicationType,
             ArrayList<android.hardware.radio.V1_0.SetupDataCallResult> dcList) {
-        mRil.unsljLogMore(RIL_UNSOL_DATA_CALL_LIST_CHANGED, "unsupported on IRadio < 1.4");
+        responseDataCallListChanged(indicationType, dcList);
     }
 
     /** Indicates current data call list with radio HAL 1.4. */
@@ -784,13 +803,15 @@ public class RadioIndication extends IRadioIndication.Stub {
     /** Get unsolicited message for cellInfoList */
     public void cellInfoList(int indicationType,
             ArrayList<android.hardware.radio.V1_0.CellInfo> records) {
-        mRil.unsljLogMore(RIL_UNSOL_CELL_INFO_LIST, "unsupported on IRadio < 1.4");
+        mRil.processIndication(HAL_SERVICE_RADIO, indicationType);
+        responseCellInfoList(records);
     }
 
     /** Get unsolicited message for cellInfoList using HAL V1_2 */
     public void cellInfoList_1_2(int indicationType,
             ArrayList<android.hardware.radio.V1_2.CellInfo> records) {
-        mRil.unsljLogMore(RIL_UNSOL_CELL_INFO_LIST, "unsupported on IRadio < 1.4");
+        mRil.processIndication(HAL_SERVICE_RADIO, indicationType);
+        responseCellInfoList(records);
     }
 
     /** Get unsolicited message for cellInfoList using HAL V1_4 */
@@ -833,20 +854,20 @@ public class RadioIndication extends IRadioIndication.Stub {
 
     /** Incremental network scan results */
     public void networkScanResult(int indicationType,
-            android.hardware.radio.V1_1.NetworkScanResult result) {
-        mRil.unsljLogMore(RIL_UNSOL_NETWORK_SCAN_RESULT, "unsupported on IRadio < 1.4");
+                                  android.hardware.radio.V1_1.NetworkScanResult result) {
+        responseNetworkScan(indicationType, result);
     }
 
     /** Incremental network scan results with HAL V1_2 */
     public void networkScanResult_1_2(int indicationType,
-            android.hardware.radio.V1_2.NetworkScanResult result) {
-        mRil.unsljLogMore(RIL_UNSOL_NETWORK_SCAN_RESULT, "unsupported on IRadio < 1.4");
+                                      android.hardware.radio.V1_2.NetworkScanResult result) {
+        responseNetworkScan_1_2(indicationType, result);
     }
 
     /** Incremental network scan results with HAL V1_4 */
     public void networkScanResult_1_4(int indicationType,
-            android.hardware.radio.V1_4.NetworkScanResult result) {
-        responseNetworkScan(indicationType, result);
+                                      android.hardware.radio.V1_4.NetworkScanResult result) {
+        responseNetworkScan_1_4(indicationType, result);
     }
 
     /** Incremental network scan results with HAL V1_5 */
@@ -897,7 +918,8 @@ public class RadioIndication extends IRadioIndication.Stub {
                 new AsyncResult (null, response, null));
     }
 
-    public void hardwareConfigChanged(int indicationType,
+    public void hardwareConfigChanged(
+            int indicationType,
             ArrayList<android.hardware.radio.V1_0.HardwareConfig> configs) {
         mRil.processIndication(HAL_SERVICE_RADIO, indicationType);
 
@@ -910,7 +932,7 @@ public class RadioIndication extends IRadioIndication.Stub {
     }
 
     public void radioCapabilityIndication(int indicationType,
-            android.hardware.radio.V1_0.RadioCapability rc) {
+                                          android.hardware.radio.V1_0.RadioCapability rc) {
         mRil.processIndication(HAL_SERVICE_RADIO, indicationType);
 
         RadioCapability response = RILUtils.convertHalRadioCapability(rc, mRil);
@@ -980,7 +1002,15 @@ public class RadioIndication extends IRadioIndication.Stub {
     }
 
     public void lceData(int indicationType, LceDataInfo lce) {
-        mRil.unsljLogMore(RIL_UNSOL_PHYSICAL_CHANNEL_CONFIG, "unsupported on IRadio < 1.4");
+        mRil.processIndication(HAL_SERVICE_RADIO, indicationType);
+
+        List<LinkCapacityEstimate> response = RILUtils.convertHalLceData(lce);
+
+        if (mRil.isLogOrTrace()) mRil.unsljLogRet(RIL_UNSOL_LCEDATA_RECV, response);
+
+        if (mRil.mLceInfoRegistrants != null) {
+            mRil.mLceInfoRegistrants.notifyRegistrants(new AsyncResult(null, response, null));
+        }
     }
 
     public void pcoData(int indicationType, PcoDataInfo pco) {
@@ -1168,7 +1198,16 @@ public class RadioIndication extends IRadioIndication.Stub {
         List<PhysicalChannelConfig> response = new ArrayList<>(configs.size());
         try {
             for (Object obj : configs) {
-                if (obj instanceof android.hardware.radio.V1_4.PhysicalChannelConfig) {
+                if (obj instanceof android.hardware.radio.V1_2.PhysicalChannelConfig) {
+                    android.hardware.radio.V1_2.PhysicalChannelConfig config =
+                            (android.hardware.radio.V1_2.PhysicalChannelConfig) obj;
+
+                    response.add(new PhysicalChannelConfig.Builder()
+                            .setCellConnectionStatus(RILUtils.convertHalCellConnectionStatus(
+                                    config.status))
+                            .setCellBandwidthDownlinkKhz(config.cellBandwidthDownlink)
+                            .build());
+                } else if (obj instanceof android.hardware.radio.V1_4.PhysicalChannelConfig) {
                     android.hardware.radio.V1_4.PhysicalChannelConfig config =
                             (android.hardware.radio.V1_4.PhysicalChannelConfig) obj;
                     PhysicalChannelConfig.Builder builder = new PhysicalChannelConfig.Builder();
@@ -1242,6 +1281,28 @@ public class RadioIndication extends IRadioIndication.Stub {
     }
 
     private void responseNetworkScan(int indicationType,
+            android.hardware.radio.V1_1.NetworkScanResult result) {
+        mRil.processIndication(HAL_SERVICE_RADIO, indicationType);
+
+        ArrayList<CellInfo> cellInfos =
+                RILUtils.convertHalCellInfoList(new ArrayList<>(result.networkInfos));
+        NetworkScanResult nsr = new NetworkScanResult(result.status, result.error, cellInfos);
+        if (mRil.isLogOrTrace()) mRil.unsljLogRet(RIL_UNSOL_NETWORK_SCAN_RESULT, nsr);
+        mRil.mRilNetworkScanResultRegistrants.notifyRegistrants(new AsyncResult(null, nsr, null));
+    }
+
+    private void responseNetworkScan_1_2(int indicationType,
+            android.hardware.radio.V1_2.NetworkScanResult result) {
+        mRil.processIndication(HAL_SERVICE_RADIO, indicationType);
+
+        ArrayList<CellInfo> cellInfos =
+                RILUtils.convertHalCellInfoList(new ArrayList<>(result.networkInfos));
+        NetworkScanResult nsr = new NetworkScanResult(result.status, result.error, cellInfos);
+        if (mRil.isLogOrTrace()) mRil.unsljLogRet(RIL_UNSOL_NETWORK_SCAN_RESULT, nsr);
+        mRil.mRilNetworkScanResultRegistrants.notifyRegistrants(new AsyncResult(null, nsr, null));
+    }
+
+    private void responseNetworkScan_1_4(int indicationType,
             android.hardware.radio.V1_4.NetworkScanResult result) {
         mRil.processIndication(HAL_SERVICE_RADIO, indicationType);
 
diff --git a/src/java/com/android/internal/telephony/RadioMessagingProxy.java b/src/java/com/android/internal/telephony/RadioMessagingProxy.java
index c652284a11..69ccf3612a 100644
--- a/src/java/com/android/internal/telephony/RadioMessagingProxy.java
+++ b/src/java/com/android/internal/telephony/RadioMessagingProxy.java
@@ -25,8 +25,8 @@ import com.android.internal.telephony.gsm.SmsBroadcastConfigInfo;
 import java.util.ArrayList;
 
 /**
- * A holder for IRadioMessaging.
- * Use getAidl to get IRadioMessaging and call the AIDL implementations of the HAL APIs.
+ * A holder for IRadioMessaging. Use getHidl to get IRadio 1.0 and call the HIDL implementations or
+ * getAidl to get IRadioMessaging and call the AIDL implementations of the HAL APIs.
  */
 public class RadioMessagingProxy extends RadioServiceProxy {
     private static final String TAG = "RadioMessagingProxy";
diff --git a/src/java/com/android/internal/telephony/RadioModemProxy.java b/src/java/com/android/internal/telephony/RadioModemProxy.java
index cdcbcc063e..4178293d06 100644
--- a/src/java/com/android/internal/telephony/RadioModemProxy.java
+++ b/src/java/com/android/internal/telephony/RadioModemProxy.java
@@ -20,8 +20,8 @@ import android.os.RemoteException;
 import android.telephony.Rlog;
 
 /**
- * A holder for IRadioModem.
- * Use getAidl to get IRadioModem and call the AIDL implementations of the HAL APIs.
+ * A holder for IRadioModem. Use getHidl to get IRadio 1.0 and call the HIDL implementations or
+ * getAidl to get IRadioModem and call the AIDL implementations of the HAL APIs.
  */
 public class RadioModemProxy extends RadioServiceProxy {
     private static final String TAG = "RadioModemProxy";
@@ -83,11 +83,11 @@ public class RadioModemProxy extends RadioServiceProxy {
      * @throws RemoteException
      */
     public void enableModem(int serial, boolean on) throws RemoteException {
-        if (isEmpty()) return;
+        if (isEmpty() || mHalVersion.less(RIL.RADIO_HAL_VERSION_1_3)) return;
         if (isAidl()) {
             mModemProxy.enableModem(serial, on);
         } else {
-            mRadioProxy.enableModem(serial, on);
+            ((android.hardware.radio.V1_3.IRadio) mRadioProxy).enableModem(serial, on);
         }
     }
 
@@ -166,11 +166,11 @@ public class RadioModemProxy extends RadioServiceProxy {
      * @throws RemoteException
      */
     public void getModemStackStatus(int serial) throws RemoteException {
-        if (isEmpty()) return;
+        if (isEmpty() || mHalVersion.less(RIL.RADIO_HAL_VERSION_1_3)) return;
         if (isAidl()) {
             mModemProxy.getModemStackStatus(serial);
         } else {
-            mRadioProxy.getModemStackStatus(serial);
+            ((android.hardware.radio.V1_3.IRadio) mRadioProxy).getModemStackStatus(serial);
         }
     }
 
diff --git a/src/java/com/android/internal/telephony/RadioNetworkProxy.java b/src/java/com/android/internal/telephony/RadioNetworkProxy.java
index 4acc71acee..069e0667df 100644
--- a/src/java/com/android/internal/telephony/RadioNetworkProxy.java
+++ b/src/java/com/android/internal/telephony/RadioNetworkProxy.java
@@ -33,17 +33,19 @@ import java.util.List;
 import java.util.stream.Collectors;
 
 /**
- * A holder for IRadioNetwork.
- * Use getAidl to get IRadioNetwork and call the AIDL implementations of the HAL APIs.
+ * A holder for IRadioNetwork. Use getHidl to get IRadio 1.0 and call the HIDL implementations or
+ * getAidl to get IRadioNetwork and call the AIDL implementations of the HAL APIs.
  */
 public class RadioNetworkProxy extends RadioServiceProxy {
     private static final String TAG = "RadioNetworkProxy";
     private volatile android.hardware.radio.network.IRadioNetwork mNetworkProxy = null;
 
-    private static final int INDICATION_FILTERS_ALL_V1_2 =
+    private static final int INDICATION_FILTERS_ALL_V1_0 =
             android.hardware.radio.V1_5.IndicationFilter.SIGNAL_STRENGTH
                     | android.hardware.radio.V1_5.IndicationFilter.FULL_NETWORK_STATE
-                    | android.hardware.radio.V1_5.IndicationFilter.DATA_CALL_DORMANCY_CHANGED
+                    | android.hardware.radio.V1_5.IndicationFilter.DATA_CALL_DORMANCY_CHANGED;
+    private static final int INDICATION_FILTERS_ALL_V1_2 =
+            INDICATION_FILTERS_ALL_V1_0
                     | android.hardware.radio.V1_5.IndicationFilter.LINK_CAPACITY_ESTIMATE
                     | android.hardware.radio.V1_5.IndicationFilter.PHYSICAL_CHANNEL_CONFIG;
     private static final int INDICATION_FILTERS_ALL_V1_5 =
@@ -119,8 +121,11 @@ public class RadioNetworkProxy extends RadioServiceProxy {
             mNetworkProxy.getAllowedNetworkTypesBitmap(serial);
         } else if (mHalVersion.greaterOrEqual(RIL.RADIO_HAL_VERSION_1_6)) {
             ((android.hardware.radio.V1_6.IRadio) mRadioProxy).getAllowedNetworkTypesBitmap(serial);
+        } else if (mHalVersion.greaterOrEqual(RIL.RADIO_HAL_VERSION_1_4)) {
+            ((android.hardware.radio.V1_4.IRadio) mRadioProxy)
+                    .getPreferredNetworkTypeBitmap(serial);
         } else {
-            mRadioProxy.getPreferredNetworkTypeBitmap(serial);
+            mRadioProxy.getPreferredNetworkType(serial);
         }
     }
 
@@ -273,8 +278,10 @@ public class RadioNetworkProxy extends RadioServiceProxy {
             mNetworkProxy.getSignalStrength(serial);
         } else if (mHalVersion.greaterOrEqual(RIL.RADIO_HAL_VERSION_1_6)) {
             ((android.hardware.radio.V1_6.IRadio) mRadioProxy).getSignalStrength_1_6(serial);
+        } else if (mHalVersion.greaterOrEqual(RIL.RADIO_HAL_VERSION_1_4)) {
+            ((android.hardware.radio.V1_4.IRadio) mRadioProxy).getSignalStrength_1_4(serial);
         } else {
-            mRadioProxy.getSignalStrength_1_4(serial);
+            mRadioProxy.getSignalStrength(serial);
         }
     }
 
@@ -387,8 +394,12 @@ public class RadioNetworkProxy extends RadioServiceProxy {
     public void setPreferredNetworkTypeBitmap(int serial, int networkTypesBitmask)
             throws RemoteException {
         if (isEmpty() || mHalVersion.greaterOrEqual(RIL.RADIO_HAL_VERSION_1_6)) return;
-        mRadioProxy.setPreferredNetworkTypeBitmap(serial,
-                RILUtils.convertToHalRadioAccessFamily(networkTypesBitmask));
+        if (mHalVersion.greaterOrEqual(RIL.RADIO_HAL_VERSION_1_4)) {
+            ((android.hardware.radio.V1_4.IRadio) mRadioProxy).setPreferredNetworkTypeBitmap(serial,
+                    RILUtils.convertToHalRadioAccessFamily(networkTypesBitmask));
+        } else {
+            mRadioProxy.setPreferredNetworkType(serial, networkTypesBitmask);
+        }
     }
 
     /**
@@ -467,8 +478,11 @@ public class RadioNetworkProxy extends RadioServiceProxy {
         } else if (mHalVersion.greaterOrEqual(RIL.RADIO_HAL_VERSION_1_5)) {
             ((android.hardware.radio.V1_5.IRadio) mRadioProxy).setIndicationFilter_1_5(serial,
                     filter & INDICATION_FILTERS_ALL_V1_5);
+        } else if (mHalVersion.greaterOrEqual(RIL.RADIO_HAL_VERSION_1_2)) {
+            ((android.hardware.radio.V1_2.IRadio) mRadioProxy).setIndicationFilter_1_2(serial,
+                    filter & INDICATION_FILTERS_ALL_V1_2);
         } else {
-            mRadioProxy.setIndicationFilter_1_2(serial, filter & INDICATION_FILTERS_ALL_V1_2);
+            mRadioProxy.setIndicationFilter(serial, filter & INDICATION_FILTERS_ALL_V1_0);
         }
     }
 
@@ -490,7 +504,7 @@ public class RadioNetworkProxy extends RadioServiceProxy {
     public void setLinkCapacityReportingCriteria(int serial, int hysteresisMs, int hysteresisDlKbps,
             int hysteresisUlKbps, int[] thresholdsDlKbps, int[] thresholdsUlKbps, int ran)
             throws RemoteException {
-        if (isEmpty()) return;
+        if (isEmpty() || mHalVersion.less(RIL.RADIO_HAL_VERSION_1_2)) return;
         if (isAidl()) {
             mNetworkProxy.setLinkCapacityReportingCriteria(serial, hysteresisMs, hysteresisDlKbps,
                     hysteresisUlKbps, thresholdsDlKbps, thresholdsUlKbps,
@@ -505,7 +519,7 @@ public class RadioNetworkProxy extends RadioServiceProxy {
             if (ran == AccessNetworkConstants.AccessNetworkType.NGRAN) {
                 throw new RuntimeException("NGRAN unsupported on IRadio version: " + mHalVersion);
             }
-            mRadioProxy.setLinkCapacityReportingCriteria(
+            ((android.hardware.radio.V1_2.IRadio) mRadioProxy).setLinkCapacityReportingCriteria(
                     serial, hysteresisMs, hysteresisDlKbps, hysteresisUlKbps,
                     RILUtils.primitiveArrayToArrayList(thresholdsDlKbps),
                     RILUtils.primitiveArrayToArrayList(thresholdsUlKbps),
@@ -589,7 +603,7 @@ public class RadioNetworkProxy extends RadioServiceProxy {
      */
     public void setSignalStrengthReportingCriteria(int serial,
             @NonNull List<SignalThresholdInfo> signalThresholdInfos) throws RemoteException {
-        if (isEmpty()) return;
+        if (isEmpty() || mHalVersion.less(RIL.RADIO_HAL_VERSION_1_2)) return;
         if (isAidl()) {
             android.hardware.radio.network.SignalThresholdInfo[] halSignalThresholdsInfos =
             new android.hardware.radio.network.SignalThresholdInfo[signalThresholdInfos.size()];
@@ -608,12 +622,14 @@ public class RadioNetworkProxy extends RadioServiceProxy {
             }
         } else {
             for (SignalThresholdInfo signalThresholdInfo : signalThresholdInfos) {
-                mRadioProxy.setSignalStrengthReportingCriteria(serial,
-                        signalThresholdInfo.getHysteresisMs(),
-                        signalThresholdInfo.getHysteresisDb(),
-                        RILUtils.primitiveArrayToArrayList(signalThresholdInfo.getThresholds()),
-                        RILUtils.convertToHalAccessNetwork(
-                                signalThresholdInfo.getRadioAccessNetworkType()));
+                ((android.hardware.radio.V1_2.IRadio) mRadioProxy)
+                        .setSignalStrengthReportingCriteria(serial,
+                                signalThresholdInfo.getHysteresisMs(),
+                                signalThresholdInfo.getHysteresisDb(),
+                                RILUtils.primitiveArrayToArrayList(
+                                        signalThresholdInfo.getThresholds()),
+                                RILUtils.convertToHalAccessNetwork(
+                                        signalThresholdInfo.getRadioAccessNetworkType()));
             }
         }
     }
@@ -641,7 +657,7 @@ public class RadioNetworkProxy extends RadioServiceProxy {
      */
     public void setSystemSelectionChannels(int serial, List<RadioAccessSpecifier> specifiers)
             throws RemoteException {
-        if (isEmpty()) return;
+        if (isEmpty() || mHalVersion.less(RIL.RADIO_HAL_VERSION_1_3)) return;
         if (isAidl()) {
             mNetworkProxy.setSystemSelectionChannels(serial, !specifiers.isEmpty(),
                     specifiers.stream().map(RILUtils::convertToHalRadioAccessSpecifierAidl)
@@ -652,8 +668,8 @@ public class RadioNetworkProxy extends RadioServiceProxy {
                             .map(RILUtils::convertToHalRadioAccessSpecifier15)
                             .collect(Collectors.toCollection(ArrayList::new)));
         } else {
-            mRadioProxy.setSystemSelectionChannels(serial, !specifiers.isEmpty(),
-                    specifiers.stream()
+            ((android.hardware.radio.V1_3.IRadio) mRadioProxy).setSystemSelectionChannels(
+                    serial, !specifiers.isEmpty(), specifiers.stream()
                             .map(RILUtils::convertToHalRadioAccessSpecifier11)
                             .collect(Collectors.toCollection(ArrayList::new)));
         }
@@ -668,7 +684,7 @@ public class RadioNetworkProxy extends RadioServiceProxy {
      */
     public void startNetworkScan(int serial, NetworkScanRequest request,
             HalVersion overrideHalVersion, Message result) throws RemoteException {
-        if (isEmpty()) return;
+        if (isEmpty() || mHalVersion.less(RIL.RADIO_HAL_VERSION_1_1)) return;
         if (isAidl()) {
             android.hardware.radio.network.NetworkScanRequest halRequest =
                     new android.hardware.radio.network.NetworkScanRequest();
@@ -718,7 +734,7 @@ public class RadioNetworkProxy extends RadioServiceProxy {
             }
             ((android.hardware.radio.V1_5.IRadio) mRadioProxy).startNetworkScan_1_5(
                     serial, halRequest);
-        } else {
+        } else if (mHalVersion.greaterOrEqual(RIL.RADIO_HAL_VERSION_1_2)) {
             android.hardware.radio.V1_2.NetworkScanRequest halRequest =
                     new android.hardware.radio.V1_2.NetworkScanRequest();
             halRequest.type = request.getScanType();
@@ -739,7 +755,31 @@ public class RadioNetworkProxy extends RadioServiceProxy {
                 }
                 halRequest.specifiers.add(rasInHalFormat);
             }
-            mRadioProxy.startNetworkScan_1_4(serial, halRequest);
+
+            if (mHalVersion.greaterOrEqual(RIL.RADIO_HAL_VERSION_1_4)) {
+                ((android.hardware.radio.V1_4.IRadio) mRadioProxy).startNetworkScan_1_4(
+                        serial, halRequest);
+            } else {
+                ((android.hardware.radio.V1_2.IRadio) mRadioProxy).startNetworkScan_1_2(
+                        serial, halRequest);
+            }
+        } else {
+            android.hardware.radio.V1_1.NetworkScanRequest halRequest =
+                    new android.hardware.radio.V1_1.NetworkScanRequest();
+            halRequest.type = request.getScanType();
+            halRequest.interval = request.getSearchPeriodicity();
+            for (RadioAccessSpecifier ras : request.getSpecifiers()) {
+                android.hardware.radio.V1_1.RadioAccessSpecifier rasInHalFormat =
+                        RILUtils.convertToHalRadioAccessSpecifier11(ras);
+                if (rasInHalFormat == null) {
+                    AsyncResult.forMessage(result, null,
+                            CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                    result.sendToTarget();
+                    return;
+                }
+                halRequest.specifiers.add(rasInHalFormat);
+            }
+            ((android.hardware.radio.V1_1.IRadio) mRadioProxy).startNetworkScan(serial, halRequest);
         }
     }
 
@@ -749,11 +789,11 @@ public class RadioNetworkProxy extends RadioServiceProxy {
      * @throws RemoteException
      */
     public void stopNetworkScan(int serial) throws RemoteException {
-        if (isEmpty()) return;
+        if (isEmpty() || mHalVersion.less(RIL.RADIO_HAL_VERSION_1_1)) return;
         if (isAidl()) {
             mNetworkProxy.stopNetworkScan(serial);
         } else {
-            mRadioProxy.stopNetworkScan(serial);
+            ((android.hardware.radio.V1_1.IRadio) mRadioProxy).stopNetworkScan(serial);
         }
     }
 
diff --git a/src/java/com/android/internal/telephony/RadioResponse.java b/src/java/com/android/internal/telephony/RadioResponse.java
index ada45ec0f7..0bc29583fb 100644
--- a/src/java/com/android/internal/telephony/RadioResponse.java
+++ b/src/java/com/android/internal/telephony/RadioResponse.java
@@ -43,9 +43,11 @@ import android.telephony.AnomalyReporter;
 import android.telephony.BarringInfo;
 import android.telephony.CarrierRestrictionRules;
 import android.telephony.CellInfo;
+import android.telephony.LinkCapacityEstimate;
 import android.telephony.ModemActivityInfo;
 import android.telephony.NeighboringCellInfo;
 import android.telephony.NetworkScanRequest;
+import android.telephony.RadioAccessFamily;
 import android.telephony.RadioAccessSpecifier;
 import android.telephony.SignalStrength;
 import android.telephony.SubscriptionManager;
@@ -101,7 +103,7 @@ public class RadioResponse extends IRadioResponse.Stub {
      * @param cardStatus ICC card status as defined by CardStatus in types.hal
      */
     public void getIccCardStatusResponse(RadioResponseInfo responseInfo, CardStatus cardStatus) {
-        responseNotSupported(responseInfo);
+        responseIccCardStatus(responseInfo, cardStatus);
     }
 
     /**
@@ -110,7 +112,7 @@ public class RadioResponse extends IRadioResponse.Stub {
      */
     public void getIccCardStatusResponse_1_2(RadioResponseInfo responseInfo,
             android.hardware.radio.V1_2.CardStatus cardStatus) {
-        responseNotSupported(responseInfo);
+        responseIccCardStatus_1_2(responseInfo, cardStatus);
     }
 
     /**
@@ -119,7 +121,7 @@ public class RadioResponse extends IRadioResponse.Stub {
      */
     public void getIccCardStatusResponse_1_4(RadioResponseInfo responseInfo,
             android.hardware.radio.V1_4.CardStatus cardStatus) {
-        responseIccCardStatus(responseInfo, cardStatus);
+        responseIccCardStatus_1_4(responseInfo, cardStatus);
     }
 
     /**
@@ -206,7 +208,7 @@ public class RadioResponse extends IRadioResponse.Stub {
      */
     public void getCurrentCallsResponse(RadioResponseInfo responseInfo,
             ArrayList<android.hardware.radio.V1_0.Call> calls) {
-        responseNotSupported(responseInfo);
+        responseCurrentCalls(responseInfo, calls);
     }
 
     /**
@@ -215,7 +217,7 @@ public class RadioResponse extends IRadioResponse.Stub {
      */
     public void getCurrentCallsResponse_1_2(RadioResponseInfo responseInfo,
             ArrayList<android.hardware.radio.V1_2.Call> calls) {
-        responseCurrentCalls(responseInfo, calls);
+        responseCurrentCalls_1_2(responseInfo, calls);
     }
 
     /**
@@ -299,25 +301,27 @@ public class RadioResponse extends IRadioResponse.Stub {
 
     public void getSignalStrengthResponse(RadioResponseInfo responseInfo,
             android.hardware.radio.V1_0.SignalStrength sigStrength) {
-        responseNotSupported(responseInfo);
+        responseSignalStrength(responseInfo, sigStrength);
     }
 
     /**
      * @param responseInfo Response info struct containing response type, serial no. and error
      * @param signalStrength Current signal strength of camped/connected cells
      */
-    public void getSignalStrengthResponse_1_2(RadioResponseInfo responseInfo,
+    public void getSignalStrengthResponse_1_2(
+            RadioResponseInfo responseInfo,
             android.hardware.radio.V1_2.SignalStrength signalStrength) {
-        responseNotSupported(responseInfo);
+        responseSignalStrength_1_2(responseInfo, signalStrength);
     }
 
     /**
      * @param responseInfo Response info struct containing response type, serial no. and error
      * @param signalStrength Current signal strength of camped/connected cells
      */
-    public void getSignalStrengthResponse_1_4(RadioResponseInfo responseInfo,
+    public void getSignalStrengthResponse_1_4(
+            RadioResponseInfo responseInfo,
             android.hardware.radio.V1_4.SignalStrength signalStrength) {
-        responseSignalStrength(responseInfo, signalStrength);
+        responseSignalStrength_1_4(responseInfo, signalStrength);
     }
 
     /**
@@ -337,7 +341,14 @@ public class RadioResponse extends IRadioResponse.Stub {
      */
     public void getVoiceRegistrationStateResponse(RadioResponseInfo responseInfo,
             VoiceRegStateResult voiceRegResponse) {
-        responseNotSupported(responseInfo);
+        RILRequest rr = mRil.processResponse(responseInfo);
+
+        if (rr != null) {
+            if (responseInfo.error == RadioError.NONE) {
+                sendMessageResponse(rr.mResult, voiceRegResponse);
+            }
+            mRil.processResponseDone(rr, responseInfo, voiceRegResponse);
+        }
     }
 
     /**
@@ -411,7 +422,14 @@ public class RadioResponse extends IRadioResponse.Stub {
      */
     public void getDataRegistrationStateResponse(RadioResponseInfo responseInfo,
             DataRegStateResult dataRegResponse) {
-        responseNotSupported(responseInfo);
+        RILRequest rr = mRil.processResponse(responseInfo);
+
+        if (rr != null) {
+            if (responseInfo.error == RadioError.NONE) {
+                sendMessageResponse(rr.mResult, dataRegResponse);
+            }
+            mRil.processResponseDone(rr, responseInfo, dataRegResponse);
+        }
     }
 
     /**
@@ -421,7 +439,14 @@ public class RadioResponse extends IRadioResponse.Stub {
      */
     public void getDataRegistrationStateResponse_1_2(RadioResponseInfo responseInfo,
             android.hardware.radio.V1_2.DataRegStateResult dataRegResponse) {
-        responseNotSupported(responseInfo);
+        RILRequest rr = mRil.processResponse(responseInfo);
+
+        if (rr != null) {
+            if (responseInfo.error == RadioError.NONE) {
+                sendMessageResponse(rr.mResult, dataRegResponse);
+            }
+            mRil.processResponseDone(rr, responseInfo, dataRegResponse);
+        }
     }
 
     /**
@@ -559,7 +584,7 @@ public class RadioResponse extends IRadioResponse.Stub {
      */
     public void setupDataCallResponse(RadioResponseInfo responseInfo,
             android.hardware.radio.V1_0.SetupDataCallResult setupDataCallResult) {
-        responseNotSupported(responseInfo);
+        responseSetupDataCall(responseInfo, setupDataCallResult);
     }
 
     /**
@@ -787,7 +812,7 @@ public class RadioResponse extends IRadioResponse.Stub {
      * @param responseInfo Response info struct containing response type, serial no. and error
      */
     public void startNetworkScanResponse(RadioResponseInfo responseInfo) {
-        responseNotSupported(responseInfo);
+        responseScanStatus(responseInfo, null /*fallbackHalVersion*/);
     }
 
     /**
@@ -875,7 +900,7 @@ public class RadioResponse extends IRadioResponse.Stub {
      */
     public void getDataCallListResponse(RadioResponseInfo responseInfo,
             ArrayList<android.hardware.radio.V1_0.SetupDataCallResult> dataCallResultList) {
-        responseNotSupported(responseInfo);
+        responseDataCallList(responseInfo, dataCallResultList);
     }
 
     /**
@@ -898,6 +923,9 @@ public class RadioResponse extends IRadioResponse.Stub {
         responseDataCallList(responseInfo, dataCallResultList);
     }
 
+    public void sendOemRilRequestRawResponse(RadioResponseInfo responseInfo,
+            ArrayList<Byte> var2) {}
+
     /**
      * @param responseInfo Response info struct containing response type, serial no. and error
      */
@@ -970,7 +998,7 @@ public class RadioResponse extends IRadioResponse.Stub {
      * @param responseInfo Response info struct containing response type, serial no. and error
      */
     public void setPreferredNetworkTypeResponse(RadioResponseInfo responseInfo) {
-        responseNotSupported(responseInfo);
+        responseVoid(responseInfo);
     }
 
     /**
@@ -986,7 +1014,8 @@ public class RadioResponse extends IRadioResponse.Stub {
      * @param nwType RadioPreferredNetworkType defined in types.hal
      */
     public void getPreferredNetworkTypeResponse(RadioResponseInfo responseInfo, int nwType) {
-        responseNotSupported(responseInfo);
+        mRil.mAllowedNetworkTypesBitmask = RadioAccessFamily.getRafFromNetworkType(nwType);
+        responseInts(responseInfo, RadioAccessFamily.getRafFromNetworkType(nwType));
     }
 
     /**
@@ -997,6 +1026,7 @@ public class RadioResponse extends IRadioResponse.Stub {
      */
     public void getPreferredNetworkTypeBitmapResponse(
             RadioResponseInfo responseInfo, int halRadioAccessFamilyBitmap) {
+
         int networkTypeBitmask = RILUtils.convertHalNetworkTypeBitMask(halRadioAccessFamilyBitmap);
         mRil.mAllowedNetworkTypesBitmask = networkTypeBitmask;
         responseInts(responseInfo, networkTypeBitmask);
@@ -1305,7 +1335,7 @@ public class RadioResponse extends IRadioResponse.Stub {
 
     public void getCellInfoListResponse(RadioResponseInfo responseInfo,
             ArrayList<android.hardware.radio.V1_0.CellInfo> cellInfo) {
-        responseNotSupported(responseInfo);
+        responseCellInfoList(responseInfo, cellInfo);
     }
 
     /**
@@ -1314,7 +1344,7 @@ public class RadioResponse extends IRadioResponse.Stub {
      */
     public void getCellInfoListResponse_1_2(RadioResponseInfo responseInfo,
             ArrayList<android.hardware.radio.V1_2.CellInfo> cellInfo) {
-        responseNotSupported(responseInfo);
+        responseCellInfoList(responseInfo, cellInfo);
     }
 
     /**
@@ -1423,7 +1453,8 @@ public class RadioResponse extends IRadioResponse.Stub {
      * @param responseInfo Response info struct containing response type, serial no. and error
      * @param result IccIoResult as defined in types.hal
      */
-    public void iccTransmitApduLogicalChannelResponse(RadioResponseInfo responseInfo,
+    public void iccTransmitApduLogicalChannelResponse(
+            RadioResponseInfo responseInfo,
             android.hardware.radio.V1_0.IccIoResult result) {
         responseIccIo(responseInfo, result);
     }
@@ -1471,10 +1502,8 @@ public class RadioResponse extends IRadioResponse.Stub {
         responseVoid(responseInfo);
     }
 
-    /**
-     * @param responseInfo Response info struct containing response type, serial no. and error
-     */
-    public void getHardwareConfigResponse(RadioResponseInfo responseInfo,
+    public void getHardwareConfigResponse(
+            RadioResponseInfo responseInfo,
             ArrayList<android.hardware.radio.V1_0.HardwareConfig> config) {
         responseHardwareConfig(responseInfo, config);
     }
@@ -1548,7 +1577,7 @@ public class RadioResponse extends IRadioResponse.Stub {
      * @param statusInfo LceStatusInfo indicating LCE status
      */
     public void startLceServiceResponse(RadioResponseInfo responseInfo, LceStatusInfo statusInfo) {
-        responseNotSupported(responseInfo);
+        responseLceStatus(responseInfo, statusInfo);
     }
 
     /**
@@ -1556,11 +1585,11 @@ public class RadioResponse extends IRadioResponse.Stub {
      * @param statusInfo LceStatusInfo indicating LCE status
      */
     public void stopLceServiceResponse(RadioResponseInfo responseInfo, LceStatusInfo statusInfo) {
-        responseNotSupported(responseInfo);
+        responseLceStatus(responseInfo, statusInfo);
     }
 
     public void pullLceDataResponse(RadioResponseInfo responseInfo, LceDataInfo lceInfo) {
-        responseNotSupported(responseInfo);
+        responseLceData(responseInfo, lceInfo);
     }
 
     /**
@@ -1605,7 +1634,26 @@ public class RadioResponse extends IRadioResponse.Stub {
      *        if Length of allowed carriers list is 0, numAllowed = 0.
      */
     public void setAllowedCarriersResponse(RadioResponseInfo responseInfo, int numAllowed) {
-        responseNotSupported(responseInfo);
+        // The number of allowed carriers set correctly is not really useful. Even if one is
+        // missing, the operation has failed, as the list should be treated as a single
+        // configuration item. So, ignoring the value of numAllowed and considering only the
+        // value of the responseInfo.error.
+        int ret = TelephonyManager.SET_CARRIER_RESTRICTION_ERROR;
+        RILRequest rr = mRil.processResponse(responseInfo);
+        if (rr != null) {
+            mRil.riljLog("setAllowedCarriersResponse - error = " + responseInfo.error);
+
+            if (responseInfo.error == RadioError.NONE) {
+                ret = TelephonyManager.SET_CARRIER_RESTRICTION_SUCCESS;
+                sendMessageResponse(rr.mResult, ret);
+            } else if (responseInfo.error == RadioError.REQUEST_NOT_SUPPORTED) {
+                // Handle the case REQUEST_NOT_SUPPORTED as a valid response
+                responseInfo.error = RadioError.NONE;
+                ret = TelephonyManager.SET_CARRIER_RESTRICTION_NOT_SUPPORTED;
+                sendMessageResponse(rr.mResult, ret);
+            }
+            mRil.processResponseDone(rr, responseInfo, ret);
+        }
     }
 
     /**
@@ -1633,7 +1681,13 @@ public class RadioResponse extends IRadioResponse.Stub {
      */
     public void getAllowedCarriersResponse(RadioResponseInfo responseInfo, boolean allAllowed,
             CarrierRestrictions carriers) {
-        responseNotSupported(responseInfo);
+        CarrierRestrictionsWithPriority carrierRestrictions = new CarrierRestrictionsWithPriority();
+        carrierRestrictions.allowedCarriers = carriers.allowedCarriers;
+        carrierRestrictions.excludedCarriers = carriers.excludedCarriers;
+        carrierRestrictions.allowedCarriersPrioritized = true;
+
+        responseCarrierRestrictions(responseInfo, allAllowed, carrierRestrictions,
+                SimLockMultiSimPolicy.NO_MULTISIM_POLICY);
     }
 
     /**
@@ -1642,36 +1696,11 @@ public class RadioResponse extends IRadioResponse.Stub {
      * @param multiSimPolicy Policy for multi-sim devices.
      */
     public void getAllowedCarriersResponse_1_4(RadioResponseInfo responseInfo,
-            CarrierRestrictionsWithPriority carrierRestrictions, int multiSimPolicy) {
-        RILRequest rr = mRil.processResponse(responseInfo);
-        if (rr == null) {
-            return;
-        }
-
-        int policy = CarrierRestrictionRules.MULTISIM_POLICY_NONE;
-        if (multiSimPolicy == SimLockMultiSimPolicy.ONE_VALID_SIM_MUST_BE_PRESENT) {
-            policy = CarrierRestrictionRules.MULTISIM_POLICY_ONE_VALID_SIM_MUST_BE_PRESENT;
-        }
-
-        int carrierRestrictionDefault =
-                CarrierRestrictionRules.CARRIER_RESTRICTION_DEFAULT_NOT_ALLOWED;
-        if (!carrierRestrictions.allowedCarriersPrioritized) {
-            carrierRestrictionDefault = CarrierRestrictionRules.CARRIER_RESTRICTION_DEFAULT_ALLOWED;
-        }
-
-        CarrierRestrictionRules ret = CarrierRestrictionRules.newBuilder()
-                .setAllowedCarriers(RILUtils.convertHalCarrierList(
-                        carrierRestrictions.allowedCarriers))
-                .setExcludedCarriers(RILUtils.convertHalCarrierList(
-                        carrierRestrictions.excludedCarriers))
-                .setDefaultCarrierRestriction(carrierRestrictionDefault)
-                .setMultiSimPolicy(policy)
-                .build();
-
-        if (responseInfo.error == RadioError.NONE) {
-            sendMessageResponse(rr.mResult, ret);
-        }
-        mRil.processResponseDone(rr, responseInfo, ret);
+            CarrierRestrictionsWithPriority carrierRestrictions,
+            int multiSimPolicy) {
+        // The API in IRadio 1.4 does not support the flag allAllowed, so setting it to false, so
+        // that values in carrierRestrictions are used.
+        responseCarrierRestrictions(responseInfo, false, carrierRestrictions, multiSimPolicy);
     }
 
     /**
@@ -1706,7 +1735,7 @@ public class RadioResponse extends IRadioResponse.Stub {
      * @param responseInfo Response info struct containing response type, serial no. and error
      */
     public void setSimCardPowerResponse(RadioResponseInfo responseInfo) {
-        responseNotSupported(responseInfo);
+        responseVoid(responseInfo);
     }
 
     /**
@@ -1845,7 +1874,39 @@ public class RadioResponse extends IRadioResponse.Stub {
         }
     }
 
-    private void responseIccCardStatus(RadioResponseInfo responseInfo,
+    private void responseIccCardStatus(RadioResponseInfo responseInfo, CardStatus cardStatus) {
+        RILRequest rr = mRil.processResponse(responseInfo);
+
+        if (rr != null) {
+            IccCardStatus iccCardStatus = RILUtils.convertHalCardStatus(cardStatus);
+            mRil.riljLog("responseIccCardStatus: from HIDL: " + iccCardStatus);
+            if (responseInfo.error == RadioError.NONE) {
+                sendMessageResponse(rr.mResult, iccCardStatus);
+            }
+            mRil.processResponseDone(rr, responseInfo, iccCardStatus);
+        }
+    }
+
+    private void responseIccCardStatus_1_2(RadioResponseInfo responseInfo,
+            android.hardware.radio.V1_2.CardStatus cardStatus) {
+        RILRequest rr = mRil.processResponse(responseInfo);
+
+        if (rr != null) {
+            IccCardStatus iccCardStatus = RILUtils.convertHalCardStatus(cardStatus.base);
+            IccSlotPortMapping slotPortMapping = new IccSlotPortMapping();
+            slotPortMapping.mPhysicalSlotIndex = cardStatus.physicalSlotId;
+            iccCardStatus.mSlotPortMapping = slotPortMapping;
+            iccCardStatus.atr = cardStatus.atr;
+            iccCardStatus.iccid = cardStatus.iccid;
+            mRil.riljLog("responseIccCardStatus: from HIDL: " + iccCardStatus);
+            if (responseInfo.error == RadioError.NONE) {
+                sendMessageResponse(rr.mResult, iccCardStatus);
+            }
+            mRil.processResponseDone(rr, responseInfo, iccCardStatus);
+        }
+    }
+
+    private void responseIccCardStatus_1_4(RadioResponseInfo responseInfo,
             android.hardware.radio.V1_4.CardStatus cardStatus) {
         RILRequest rr = mRil.processResponse(responseInfo);
 
@@ -1974,12 +2035,52 @@ public class RadioResponse extends IRadioResponse.Stub {
     }
 
     private void responseCurrentCalls(RadioResponseInfo responseInfo,
+            ArrayList<android.hardware.radio.V1_0.Call> calls) {
+        RILRequest rr = mRil.processResponse(responseInfo);
+
+        if (rr != null) {
+            int num = calls.size();
+            ArrayList<DriverCall> dcCalls = new ArrayList<DriverCall>(num);
+            DriverCall dc;
+
+            for (int i = 0; i < num; i++) {
+                dc = RILUtils.convertToDriverCall(calls.get(i));
+
+                dcCalls.add(dc);
+
+                if (dc.isVoicePrivacy) {
+                    mRil.mVoicePrivacyOnRegistrants.notifyRegistrants();
+                    mRil.riljLog("InCall VoicePrivacy is enabled");
+                } else {
+                    mRil.mVoicePrivacyOffRegistrants.notifyRegistrants();
+                    mRil.riljLog("InCall VoicePrivacy is disabled");
+                }
+            }
+
+            Collections.sort(dcCalls);
+
+            if ((num == 0) && mRil.mTestingEmergencyCall.getAndSet(false)) {
+                if (mRil.mEmergencyCallbackModeRegistrant != null) {
+                    mRil.riljLog("responseCurrentCalls: call ended, testing emergency call,"
+                            + " notify ECM Registrants");
+                    mRil.mEmergencyCallbackModeRegistrant.notifyRegistrant();
+                }
+            }
+
+            if (responseInfo.error == RadioError.NONE) {
+                sendMessageResponse(rr.mResult, dcCalls);
+            }
+            mRil.processResponseDone(rr, responseInfo, dcCalls);
+        }
+    }
+
+    private void responseCurrentCalls_1_2(RadioResponseInfo responseInfo,
             ArrayList<android.hardware.radio.V1_2.Call> calls) {
         RILRequest rr = mRil.processResponse(responseInfo);
 
         if (rr != null) {
             int num = calls.size();
-            ArrayList<DriverCall> dcCalls = new ArrayList<>(num);
+            ArrayList<DriverCall> dcCalls = new ArrayList<DriverCall>(num);
             DriverCall dc;
 
             for (int i = 0; i < num; i++) {
@@ -2054,15 +2155,6 @@ public class RadioResponse extends IRadioResponse.Stub {
         }
     }
 
-    private void responseNotSupported(RadioResponseInfo responseInfo) {
-        RILRequest rr = mRil.processResponse(responseInfo);
-        if (rr != null) {
-            mRil.riljLog(RILUtils.requestToString(rr.mRequest) + "not supported on IRadio < 1.4");
-            responseInfo.error = RadioError.REQUEST_NOT_SUPPORTED;
-            mRil.processResponseDone(rr, responseInfo, null);
-        }
-    }
-
     private void responseVoid(RadioResponseInfo responseInfo) {
         RILRequest rr = mRil.processResponse(responseInfo);
 
@@ -2208,6 +2300,34 @@ public class RadioResponse extends IRadioResponse.Stub {
     }
 
     private void responseSignalStrength(
+            RadioResponseInfo responseInfo,
+            android.hardware.radio.V1_0.SignalStrength signalStrength) {
+        RILRequest rr = mRil.processResponse(responseInfo);
+
+        if (rr != null) {
+            SignalStrength ret = RILUtils.convertHalSignalStrength(signalStrength);
+            if (responseInfo.error == RadioError.NONE) {
+                sendMessageResponse(rr.mResult, ret);
+            }
+            mRil.processResponseDone(rr, responseInfo, ret);
+        }
+    }
+
+    private void responseSignalStrength_1_2(
+            RadioResponseInfo responseInfo,
+            android.hardware.radio.V1_2.SignalStrength signalStrength) {
+        RILRequest rr = mRil.processResponse(responseInfo);
+
+        if (rr != null) {
+            SignalStrength ret = RILUtils.convertHalSignalStrength(signalStrength);
+            if (responseInfo.error == RadioError.NONE) {
+                sendMessageResponse(rr.mResult, ret);
+            }
+            mRil.processResponseDone(rr, responseInfo, ret);
+        }
+    }
+
+    private void responseSignalStrength_1_4(
             RadioResponseInfo responseInfo,
             android.hardware.radio.V1_4.SignalStrength signalStrength) {
         RILRequest rr = mRil.processResponse(responseInfo);
@@ -2576,6 +2696,69 @@ public class RadioResponse extends IRadioResponse.Stub {
         }
     }
 
+    private void responseLceStatus(RadioResponseInfo responseInfo, LceStatusInfo statusInfo) {
+        RILRequest rr = mRil.processResponse(responseInfo);
+
+        if (rr != null) {
+            ArrayList<Integer> ret = new ArrayList<>();
+            ret.add(statusInfo.lceStatus);
+            ret.add(Byte.toUnsignedInt(statusInfo.actualIntervalMs));
+            if (responseInfo.error == RadioError.NONE) {
+                sendMessageResponse(rr.mResult, ret);
+            }
+            mRil.processResponseDone(rr, responseInfo, ret);
+        }
+    }
+
+    private void responseLceData(RadioResponseInfo responseInfo, LceDataInfo lceInfo) {
+        RILRequest rr = mRil.processResponse(responseInfo);
+
+        if (rr != null) {
+            List<LinkCapacityEstimate> ret = RILUtils.convertHalLceData(lceInfo);
+            if (responseInfo.error == RadioError.NONE) {
+                sendMessageResponse(rr.mResult, ret);
+            }
+            mRil.processResponseDone(rr, responseInfo, ret);
+        }
+    }
+
+    private void responseCarrierRestrictions(RadioResponseInfo responseInfo, boolean allAllowed,
+            CarrierRestrictionsWithPriority carriers, int multiSimPolicy) {
+        RILRequest rr = mRil.processResponse(responseInfo);
+        if (rr == null) {
+            return;
+        }
+        CarrierRestrictionRules ret;
+
+        if (allAllowed) {
+            ret = CarrierRestrictionRules.newBuilder().setAllCarriersAllowed().build();
+        } else {
+            int policy = CarrierRestrictionRules.MULTISIM_POLICY_NONE;
+            if (multiSimPolicy == SimLockMultiSimPolicy.ONE_VALID_SIM_MUST_BE_PRESENT) {
+                policy = CarrierRestrictionRules.MULTISIM_POLICY_ONE_VALID_SIM_MUST_BE_PRESENT;
+            }
+
+            int carrierRestrictionDefault =
+                    CarrierRestrictionRules.CARRIER_RESTRICTION_DEFAULT_NOT_ALLOWED;
+            if (!carriers.allowedCarriersPrioritized) {
+                carrierRestrictionDefault =
+                        CarrierRestrictionRules.CARRIER_RESTRICTION_DEFAULT_ALLOWED;
+            }
+
+            ret = CarrierRestrictionRules.newBuilder()
+                    .setAllowedCarriers(RILUtils.convertHalCarrierList(carriers.allowedCarriers))
+                    .setExcludedCarriers(RILUtils.convertHalCarrierList(carriers.excludedCarriers))
+                    .setDefaultCarrierRestriction(carrierRestrictionDefault)
+                    .setMultiSimPolicy(policy)
+                    .build();
+        }
+
+        if (responseInfo.error == RadioError.NONE) {
+            sendMessageResponse(rr.mResult, ret);
+        }
+        mRil.processResponseDone(rr, responseInfo, ret);
+    }
+
     /**
      * @param responseInfo Response info struct containing response type, serial number and error.
      */
diff --git a/src/java/com/android/internal/telephony/RadioServiceProxy.java b/src/java/com/android/internal/telephony/RadioServiceProxy.java
index 02fc751484..4257327330 100644
--- a/src/java/com/android/internal/telephony/RadioServiceProxy.java
+++ b/src/java/com/android/internal/telephony/RadioServiceProxy.java
@@ -19,13 +19,13 @@ package com.android.internal.telephony;
 import android.os.RemoteException;
 
 /**
- * A holder for IRadio services.
- * Use getHidl to get the HIDL IRadio service or getAidl to get the corresponding AIDL service.
+ * A holder for IRadio services. Use getHidl to get IRadio 1.0 and call the HIDL implementations or
+ * getAidl to get the AIDL service and call the AIDL implementations of the HAL APIs.
  */
 public abstract class RadioServiceProxy {
     boolean mIsAidl;
     HalVersion mHalVersion = RIL.RADIO_HAL_VERSION_UNKNOWN;
-    volatile android.hardware.radio.V1_4.IRadio mRadioProxy = null;
+    volatile android.hardware.radio.V1_0.IRadio mRadioProxy = null;
 
     /**
      * Whether RadioServiceProxy is an AIDL or HIDL implementation
@@ -40,7 +40,7 @@ public abstract class RadioServiceProxy {
      * @param halVersion Radio HAL version
      * @param radio      IRadio implementation
      */
-    public void setHidl(HalVersion halVersion, android.hardware.radio.V1_4.IRadio radio) {
+    public void setHidl(HalVersion halVersion, android.hardware.radio.V1_0.IRadio radio) {
         mHalVersion = halVersion;
         mRadioProxy = radio;
         mIsAidl = false;
@@ -50,7 +50,7 @@ public abstract class RadioServiceProxy {
      * Get the HIDL implementation of RadioServiceProxy
      * @return IRadio implementation
      */
-    public android.hardware.radio.V1_4.IRadio getHidl() {
+    public android.hardware.radio.V1_0.IRadio getHidl() {
         return mRadioProxy;
     }
 
diff --git a/src/java/com/android/internal/telephony/RadioSimProxy.java b/src/java/com/android/internal/telephony/RadioSimProxy.java
index 5265692167..7c8ee7b6ea 100644
--- a/src/java/com/android/internal/telephony/RadioSimProxy.java
+++ b/src/java/com/android/internal/telephony/RadioSimProxy.java
@@ -16,17 +16,22 @@
 
 package com.android.internal.telephony;
 
+import static com.android.internal.telephony.RILConstants.REQUEST_NOT_SUPPORTED;
+
+import android.os.AsyncResult;
+import android.os.Message;
 import android.os.RemoteException;
 import android.telephony.CarrierRestrictionRules;
 import android.telephony.ImsiEncryptionInfo;
 import android.telephony.Rlog;
+import android.telephony.TelephonyManager;
 
 import com.android.internal.telephony.uicc.IccCardApplicationStatus.PersoSubState;
 import com.android.internal.telephony.uicc.SimPhonebookRecord;
 
 /**
- * A holder for IRadioSim.
- * Use getAidl to get IRadioSim and call the AIDL implementations of the HAL APIs.
+ * A holder for IRadioSim. Use getHidl to get IRadio 1.0 and call the HIDL implementations or
+ * getAidl to get IRadioSim and call the AIDL implementations of the HAL APIs.
  */
 public class RadioSimProxy extends RadioServiceProxy {
     private static final String TAG = "RadioSimProxy";
@@ -155,8 +160,10 @@ public class RadioSimProxy extends RadioServiceProxy {
         if (isEmpty()) return;
         if (isAidl()) {
             mSimProxy.getAllowedCarriers(serial);
+        } else if (mHalVersion.greaterOrEqual(RIL.RADIO_HAL_VERSION_1_4)) {
+            ((android.hardware.radio.V1_4.IRadio) mRadioProxy).getAllowedCarriers_1_4(serial);
         } else {
-            mRadioProxy.getAllowedCarriers_1_4(serial);
+            mRadioProxy.getAllowedCarriers(serial);
         }
     }
 
@@ -514,10 +521,11 @@ public class RadioSimProxy extends RadioServiceProxy {
      * Call IRadioSim#setAllowedCarriers
      * @param serial Serial number of request
      * @param carrierRestrictionRules Allowed carriers
+     * @param result Result to return in case of error
      * @throws RemoteException
      */
-    public void setAllowedCarriers(int serial, CarrierRestrictionRules carrierRestrictionRules)
-            throws RemoteException {
+    public void setAllowedCarriers(int serial, CarrierRestrictionRules carrierRestrictionRules,
+            Message result) throws RemoteException {
         if (isEmpty()) return;
         if (isAidl()) {
             // Prepare structure with allowed list, excluded list and priority
@@ -533,7 +541,7 @@ public class RadioSimProxy extends RadioServiceProxy {
             mSimProxy.setAllowedCarriers(serial, carrierRestrictions,
                     RILUtils.convertToHalSimLockMultiSimPolicyAidl(
                             carrierRestrictionRules.getMultiSimPolicy()));
-        } else {
+        } else if (mHalVersion.greaterOrEqual(RIL.RADIO_HAL_VERSION_1_4)) {
             // Prepare structure with allowed list, excluded list and priority
             android.hardware.radio.V1_4.CarrierRestrictionsWithPriority carrierRestrictions =
                     new android.hardware.radio.V1_4.CarrierRestrictionsWithPriority();
@@ -544,9 +552,35 @@ public class RadioSimProxy extends RadioServiceProxy {
             carrierRestrictions.allowedCarriersPrioritized =
                     (carrierRestrictionRules.getDefaultCarrierRestriction()
                             == CarrierRestrictionRules.CARRIER_RESTRICTION_DEFAULT_NOT_ALLOWED);
-            mRadioProxy.setAllowedCarriers_1_4(serial, carrierRestrictions,
-                    RILUtils.convertToHalSimLockMultiSimPolicy(
+            ((android.hardware.radio.V1_4.IRadio) mRadioProxy).setAllowedCarriers_1_4(
+                    serial, carrierRestrictions, RILUtils.convertToHalSimLockMultiSimPolicy(
                             carrierRestrictionRules.getMultiSimPolicy()));
+        } else {
+            boolean isAllCarriersAllowed = carrierRestrictionRules.isAllCarriersAllowed();
+            boolean supported = (isAllCarriersAllowed
+                    || (carrierRestrictionRules.getExcludedCarriers().isEmpty()
+                    && (carrierRestrictionRules.getDefaultCarrierRestriction()
+                    == CarrierRestrictionRules.CARRIER_RESTRICTION_DEFAULT_NOT_ALLOWED)))
+                    && (RILUtils.convertToHalSimLockMultiSimPolicy(
+                    carrierRestrictionRules.getMultiSimPolicy())
+                    == android.hardware.radio.V1_4.SimLockMultiSimPolicy.NO_MULTISIM_POLICY);
+
+            if (!supported) {
+                // Feature is not supported by IRadio interface
+                if (result != null) {
+                    AsyncResult.forMessage(result, null,
+                            CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                    result.sendToTarget();
+                }
+                return;
+            }
+
+            // Prepare structure with allowed list
+            android.hardware.radio.V1_0.CarrierRestrictions carrierRestrictions =
+                    new android.hardware.radio.V1_0.CarrierRestrictions();
+            carrierRestrictions.allowedCarriers = RILUtils.convertToHalCarrierRestrictionList(
+                    carrierRestrictionRules.getAllowedCarriers());
+            mRadioProxy.setAllowedCarriers(serial, isAllCarriersAllowed, carrierRestrictions);
         }
     }
 
@@ -558,7 +592,7 @@ public class RadioSimProxy extends RadioServiceProxy {
      */
     public void setCarrierInfoForImsiEncryption(int serial, ImsiEncryptionInfo imsiEncryptionInfo)
             throws RemoteException {
-        if (isEmpty()) return;
+        if (isEmpty() || mHalVersion.less(RIL.RADIO_HAL_VERSION_1_1)) return;
         if (isAidl()) {
             android.hardware.radio.sim.ImsiEncryptionInfo halImsiInfo =
                     new android.hardware.radio.sim.ImsiEncryptionInfo();
@@ -601,7 +635,8 @@ public class RadioSimProxy extends RadioServiceProxy {
                 halImsiInfo.carrierKey.add(Byte.valueOf(b));
             }
 
-            mRadioProxy.setCarrierInfoForImsiEncryption(serial, halImsiInfo);
+            ((android.hardware.radio.V1_1.IRadio) mRadioProxy).setCarrierInfoForImsiEncryption(
+                    serial, halImsiInfo);
         }
     }
 
@@ -646,16 +681,35 @@ public class RadioSimProxy extends RadioServiceProxy {
      * Call IRadioSim#setSimCardPower
      * @param serial Serial number of request
      * @param state SIM state (power down, power up, pass through)
+     * @param result Result to return in case of error
      * @throws RemoteException
      */
-    public void setSimCardPower(int serial, int state) throws RemoteException {
+    public void setSimCardPower(int serial, int state, Message result) throws RemoteException {
         if (isEmpty()) return;
         if (isAidl()) {
             mSimProxy.setSimCardPower(serial, state);
         } else if (mHalVersion.greaterOrEqual(RIL.RADIO_HAL_VERSION_1_6)) {
             ((android.hardware.radio.V1_6.IRadio) mRadioProxy).setSimCardPower_1_6(serial, state);
-        } else {
-            mRadioProxy.setSimCardPower_1_1(serial, state);
+        } else if (mHalVersion.greaterOrEqual(RIL.RADIO_HAL_VERSION_1_1)) {
+            ((android.hardware.radio.V1_1.IRadio) mRadioProxy).setSimCardPower_1_1(serial, state);
+        } else {
+            switch (state) {
+                case TelephonyManager.CARD_POWER_DOWN: {
+                    mRadioProxy.setSimCardPower(serial, false);
+                    break;
+                }
+                case TelephonyManager.CARD_POWER_UP: {
+                    mRadioProxy.setSimCardPower(serial, true);
+                    break;
+                }
+                default: {
+                    if (result != null) {
+                        AsyncResult.forMessage(result, null,
+                                CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+                        result.sendToTarget();
+                    }
+                }
+            }
         }
     }
 
diff --git a/src/java/com/android/internal/telephony/RadioVoiceProxy.java b/src/java/com/android/internal/telephony/RadioVoiceProxy.java
index e57a61d81c..7f46424485 100644
--- a/src/java/com/android/internal/telephony/RadioVoiceProxy.java
+++ b/src/java/com/android/internal/telephony/RadioVoiceProxy.java
@@ -24,8 +24,8 @@ import android.telephony.emergency.EmergencyNumber;
 import java.util.ArrayList;
 
 /**
- * A holder for IRadioVoice.
- * Use getAidl to get IRadioVoice and call the AIDL implementations of the HAL APIs.
+ * A holder for IRadioVoice. Use getHidl to get IRadio 1.0 and call the HIDL implementations or
+ * getAidl to get IRadioVoice and call the AIDL implementations of the HAL APIs.
  */
 public class RadioVoiceProxy extends RadioServiceProxy {
     private static final String TAG = "RadioVoiceProxy";
@@ -153,7 +153,7 @@ public class RadioVoiceProxy extends RadioServiceProxy {
     public void emergencyDial(int serial, String address, EmergencyNumber emergencyNumberInfo,
             boolean hasKnownUserIntentEmergency, int clirMode, UUSInfo uusInfo)
             throws RemoteException {
-        if (isEmpty()) return;
+        if (isEmpty() || mHalVersion.less(RIL.RADIO_HAL_VERSION_1_4)) return;
         if (isAidl()) {
             mVoiceProxy.emergencyDial(serial,
                     RILUtils.convertToHalDialAidl(address, clirMode, uusInfo),
@@ -177,7 +177,7 @@ public class RadioVoiceProxy extends RadioServiceProxy {
                     emergencyNumberInfo.getEmergencyNumberSourceBitmask()
                             == EmergencyNumber.EMERGENCY_NUMBER_SOURCE_TEST);
         } else {
-            mRadioProxy.emergencyDial(serial,
+            ((android.hardware.radio.V1_4.IRadio) mRadioProxy).emergencyDial(serial,
                     RILUtils.convertToHalDial(address, clirMode, uusInfo),
                     emergencyNumberInfo.getEmergencyServiceCategoryBitmaskInternalDial(),
                     emergencyNumberInfo.getEmergencyUrns() != null
diff --git a/tests/telephonytests/src/com/android/internal/telephony/RILTest.java b/tests/telephonytests/src/com/android/internal/telephony/RILTest.java
index b285f0f8d2..c0e5d67a0d 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/RILTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/RILTest.java
@@ -142,7 +142,6 @@ import android.os.RemoteException;
 import android.os.WorkSource;
 import android.service.carrier.CarrierIdentifier;
 import android.telephony.AccessNetworkConstants;
-import android.telephony.CellConfigLte;
 import android.telephony.CellIdentityCdma;
 import android.telephony.CellIdentityGsm;
 import android.telephony.CellIdentityLte;
@@ -162,10 +161,11 @@ import android.telephony.CellSignalStrengthLte;
 import android.telephony.CellSignalStrengthNr;
 import android.telephony.CellSignalStrengthTdscdma;
 import android.telephony.CellSignalStrengthWcdma;
-import android.telephony.ClosedSubscriberGroupInfo;
 import android.telephony.NetworkScanRequest;
 import android.telephony.RadioAccessFamily;
 import android.telephony.RadioAccessSpecifier;
+import android.telephony.ServiceState;
+import android.telephony.SignalStrength;
 import android.telephony.SmsManager;
 import android.telephony.TelephonyManager;
 import android.telephony.data.ApnSetting;
@@ -225,10 +225,13 @@ public class RILTest extends TelephonyTest {
     private RadioSimProxy mSimProxy;
     private RadioModemProxy mRadioModemProxy;
 
+    private Map<Integer, HalVersion> mHalVersionV10 = new HashMap<>();
+    private Map<Integer, HalVersion> mHalVersionV11 = new HashMap<>();
+    private Map<Integer, HalVersion> mHalVersionV12 = new HashMap<>();
+    private Map<Integer, HalVersion> mHalVersionV13 = new HashMap<>();
     private Map<Integer, HalVersion> mHalVersionV14 = new HashMap<>();
     private Map<Integer, HalVersion> mHalVersionV15 = new HashMap<>();
     private Map<Integer, HalVersion> mHalVersionV16 = new HashMap<>();
-    private Map<Integer, HalVersion> mHalVersionV20 = new HashMap<>();
     private Map<Integer, HalVersion> mHalVersionV21 = new HashMap<>();
 
     private RIL mRILInstance;
@@ -245,21 +248,25 @@ public class RILTest extends TelephonyTest {
     private static final int CI = 268435456;
     private static final int CID = 65535;
     private static final int CQI = 2147483647;
-    private static final int CQI_TABLE_INDEX = 1;
     private static final int DBM = -74;
     private static final int EARFCN = 262140;
-    private static final ArrayList<Integer> BANDS = new ArrayList<>(Arrays.asList(1, 2));
+    private static final List<Integer> BANDS = Arrays.asList(1, 2);
     private static final int BANDWIDTH = 5000;
     private static final int ECIO = -124;
+    private static final String EMPTY_ALPHA_LONG = "";
+    private static final String EMPTY_ALPHA_SHORT = "";
     private static final int LAC = 65535;
     private static final int LATITUDE = 1292000;
     private static final int LONGITUDE = 1295000;
+    private static final int MCC = 120;
     private static final String MCC_STR = "120";
+    private static final int MNC = 260;
     private static final String MNC_STR = "260";
     private static final int NETWORK_ID = 65534;
     private static final int NRARFCN = 3279165;
     private static final int PCI = 503;
     private static final int PSC = 500;
+    private static final int RIL_TIMESTAMP_TYPE_OEM_RIL = 3;
     private static final int RSSNR = CellInfo.UNAVAILABLE;
     private static final int RSRP = -96;
     private static final int RSRQ = -10;
@@ -275,9 +282,11 @@ public class RILTest extends TelephonyTest {
     private static final int TIMING_ADVANCE = 4;
     private static final long TIMESTAMP = 215924934;
     private static final int UARFCN = 690;
-    private static final int CONNECTION_STATUS = CellInfo.CONNECTION_NONE;
-    private static final boolean ENDC_AVAILABLE = true;
-    private static final boolean REGISTERED = true;
+    private static final int TYPE_CDMA = 2;
+    private static final int TYPE_GSM = 1;
+    private static final int TYPE_LTE = 3;
+    private static final int TYPE_WCDMA = 4;
+    private static final int TYPE_TD_SCDMA = 5;
 
     private static final int PROFILE_ID = 0;
     private static final String APN = "apn";
@@ -294,6 +303,7 @@ public class RILTest extends TelephonyTest {
                     | TelephonyManager.NETWORK_TYPE_BITMASK_LTE);
     private static final int ROAMING_PROTOCOL = ApnSetting.PROTOCOL_IPV6;
     private static final int MTU = 1234;
+    private static final boolean PERSISTENT = true;
 
     private static final String[] ADDITIONAL_PLMNS = new String[] {"00101", "001001", "12345"};
 
@@ -349,13 +359,16 @@ public class RILTest extends TelephonyTest {
         doReturn(false).when(mRadioModemProxy).isEmpty();
         try {
             for (int service = RIL.MIN_SERVICE_IDX; service <= RIL.MAX_SERVICE_IDX; service++) {
+                mHalVersionV10.put(service, new HalVersion(1, 0));
+                mHalVersionV11.put(service, new HalVersion(1, 1));
+                mHalVersionV12.put(service, new HalVersion(1, 2));
+                mHalVersionV13.put(service, new HalVersion(1, 3));
                 mHalVersionV14.put(service, new HalVersion(1, 4));
                 mHalVersionV15.put(service, new HalVersion(1, 5));
                 mHalVersionV16.put(service, new HalVersion(1, 6));
-                mHalVersionV20.put(service, new HalVersion(2, 0));
                 mHalVersionV21.put(service, new HalVersion(2, 1));
             }
-            replaceInstance(RIL.class, "mHalVersion", mRILUnderTest, mHalVersionV14);
+            replaceInstance(RIL.class, "mHalVersion", mRILUnderTest, mHalVersionV10);
         } catch (Exception e) {
         }
     }
@@ -1596,694 +1609,460 @@ public class RILTest extends TelephonyTest {
         return respInfo;
     }
 
-    private android.hardware.radio.V1_2.CellIdentityOperatorNames getCellIdentityOperatorNames() {
-        android.hardware.radio.V1_2.CellIdentityOperatorNames operatorNames =
-                new android.hardware.radio.V1_2.CellIdentityOperatorNames();
-        operatorNames.alphaLong = ALPHA_LONG;
-        operatorNames.alphaShort = ALPHA_SHORT;
-
-        return operatorNames;
-    }
-
-    private android.hardware.radio.V1_2.CellIdentityLte getCellIdentityLte_1_2() {
-        android.hardware.radio.V1_0.CellIdentityLte cellIdentity0 =
-                new android.hardware.radio.V1_0.CellIdentityLte();
-        cellIdentity0.mcc = MCC_STR;
-        cellIdentity0.mnc = MNC_STR;
-        cellIdentity0.ci = CI;
-        cellIdentity0.pci = PCI;
-        cellIdentity0.tac = TAC;
-        cellIdentity0.earfcn = EARFCN;
-
-        android.hardware.radio.V1_2.CellIdentityLte cellIdentity =
-                new android.hardware.radio.V1_2.CellIdentityLte();
-        cellIdentity.base = cellIdentity0;
-        cellIdentity.operatorNames = getCellIdentityOperatorNames();
-        cellIdentity.bandwidth = BANDWIDTH;
-
-        return cellIdentity;
-    }
-
-    private android.hardware.radio.V1_0.LteSignalStrength getLteSignalStrength_1_0() {
-        android.hardware.radio.V1_0.LteSignalStrength signalStrength =
-                new android.hardware.radio.V1_0.LteSignalStrength();
-        signalStrength.signalStrength = RSSI_ASU;
-        signalStrength.rsrp = -RSRP;
-        signalStrength.rsrq = -RSRQ;
-        signalStrength.rssnr = RSSNR;
-        signalStrength.cqi = CQI;
-        signalStrength.timingAdvance = TIMING_ADVANCE;
-
-        return signalStrength;
-    }
-
-    private android.hardware.radio.V1_4.CellInfo getCellInfo_1_4ForLte() {
-        android.hardware.radio.V1_2.CellInfoLte cellInfo2 =
-                new android.hardware.radio.V1_2.CellInfoLte();
-        cellInfo2.cellIdentityLte = getCellIdentityLte_1_2();
-        cellInfo2.signalStrengthLte = getLteSignalStrength_1_0();
-
-        android.hardware.radio.V1_4.CellConfigLte cellConfig =
-                new android.hardware.radio.V1_4.CellConfigLte();
-        cellConfig.isEndcAvailable = ENDC_AVAILABLE;
-
-        android.hardware.radio.V1_4.CellInfoLte cellInfoLte =
-                new android.hardware.radio.V1_4.CellInfoLte();
-        cellInfoLte.base = cellInfo2;
-        cellInfoLte.cellConfig = cellConfig;
-
-        android.hardware.radio.V1_4.CellInfo cellInfo = new android.hardware.radio.V1_4.CellInfo();
-        cellInfo.isRegistered = REGISTERED;
-        cellInfo.connectionStatus = CONNECTION_STATUS;
-        cellInfo.info.lte(cellInfoLte);
-
-        return cellInfo;
-    }
-
     @Test
-    public void testConvertHalCellInfoList_1_4ForLte() {
+    public void testConvertHalCellInfoListForLTE() {
+        android.hardware.radio.V1_0.CellInfoLte lte = new android.hardware.radio.V1_0.CellInfoLte();
+        lte.cellIdentityLte.ci = CI;
+        lte.cellIdentityLte.pci = PCI;
+        lte.cellIdentityLte.tac = TAC;
+        lte.cellIdentityLte.earfcn = EARFCN;
+        lte.cellIdentityLte.mcc = MCC_STR;
+        lte.cellIdentityLte.mnc = MNC_STR;
+        lte.signalStrengthLte.signalStrength = RSSI_ASU;
+        lte.signalStrengthLte.rsrp = -RSRP;
+        lte.signalStrengthLte.rsrq = -RSRQ;
+        lte.signalStrengthLte.rssnr = RSSNR;
+        lte.signalStrengthLte.cqi = CQI;
+        lte.signalStrengthLte.timingAdvance = TIMING_ADVANCE;
+        android.hardware.radio.V1_0.CellInfo record = new android.hardware.radio.V1_0.CellInfo();
+        record.cellInfoType = TYPE_LTE;
+        record.registered = false;
+        record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
+        record.timeStamp = TIMESTAMP;
+        record.lte.add(lte);
         ArrayList<Object> records = new ArrayList<>();
-        records.add(getCellInfo_1_4ForLte());
+        records.add(record);
 
         ArrayList<CellInfo> ret = RILUtils.convertHalCellInfoList(records);
 
         assertEquals(1, ret.size());
         CellInfoLte cellInfoLte = (CellInfoLte) ret.get(0);
-        cellInfoLte.setTimeStamp(TIMESTAMP); // override the timestamp
-
-        CellIdentityLte cellIdentityLte = new CellIdentityLte(CI, PCI, TAC, EARFCN, new int[] {},
-                BANDWIDTH, MCC_STR, MNC_STR, ALPHA_LONG, ALPHA_SHORT, Collections.emptyList(),
-                null);
-        CellSignalStrengthLte cellSignalStrengthLte = new CellSignalStrengthLte(
+        CellInfoLte expected = new CellInfoLte();
+        expected.setRegistered(false);
+        expected.setTimeStamp(TIMESTAMP);
+        CellIdentityLte cil = new CellIdentityLte(CI, PCI, TAC, EARFCN, new int[] {},
+                Integer.MAX_VALUE, MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT,
+                Collections.emptyList(), null);
+        CellSignalStrengthLte css = new CellSignalStrengthLte(
                 RSSI, RSRP, RSRQ, RSSNR, CQI, TIMING_ADVANCE);
-        CellConfigLte cellConfigLte = new CellConfigLte(ENDC_AVAILABLE);
-        CellInfoLte expected = new CellInfoLte(CONNECTION_STATUS, REGISTERED, TIMESTAMP,
-                cellIdentityLte, cellSignalStrengthLte, cellConfigLte);
+        expected.setCellIdentity(cil);
+        expected.setCellSignalStrength(css);
+        expected.setCellConnectionStatus(CellInfo.CONNECTION_UNKNOWN);
+        cellInfoLte.setTimeStamp(TIMESTAMP); // override the timestamp
         assertEquals(expected, cellInfoLte);
     }
 
-    private android.hardware.radio.V1_5.OptionalCsgInfo getOptionalCsgInfo() {
-        android.hardware.radio.V1_5.ClosedSubscriberGroupInfo closedSubscriberGroupInfo =
-                new android.hardware.radio.V1_5.ClosedSubscriberGroupInfo();
-        closedSubscriberGroupInfo.csgIndication = CSG_INDICATION;
-        closedSubscriberGroupInfo.homeNodebName = HOME_NODEB_NAME;
-        closedSubscriberGroupInfo.csgIdentity = CSG_IDENTITY;
-
-        android.hardware.radio.V1_5.OptionalCsgInfo optionalCsgInfo =
-                new android.hardware.radio.V1_5.OptionalCsgInfo();
-        optionalCsgInfo.csgInfo(closedSubscriberGroupInfo);
-
-        return optionalCsgInfo;
-    }
+    @Test
+    public void testConvertHalCellInfoListForGSM() {
+        android.hardware.radio.V1_0.CellInfoGsm cellinfo =
+                new android.hardware.radio.V1_0.CellInfoGsm();
+        cellinfo.cellIdentityGsm.lac = LAC;
+        cellinfo.cellIdentityGsm.cid = CID;
+        cellinfo.cellIdentityGsm.bsic = BSIC;
+        cellinfo.cellIdentityGsm.arfcn = ARFCN;
+        cellinfo.cellIdentityGsm.mcc = MCC_STR;
+        cellinfo.cellIdentityGsm.mnc = MNC_STR;
+        cellinfo.signalStrengthGsm.signalStrength = RSSI_ASU;
+        cellinfo.signalStrengthGsm.bitErrorRate = BIT_ERROR_RATE;
+        cellinfo.signalStrengthGsm.timingAdvance = TIMING_ADVANCE;
+        android.hardware.radio.V1_0.CellInfo record = new android.hardware.radio.V1_0.CellInfo();
+        record.cellInfoType = TYPE_GSM;
+        record.registered = false;
+        record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
+        record.timeStamp = TIMESTAMP;
+        record.gsm.add(cellinfo);
+        ArrayList<Object> records = new ArrayList<>();
+        records.add(record);
 
-    private android.hardware.radio.V1_5.CellIdentityLte getCellIdentityLte_1_5() {
-        android.hardware.radio.V1_5.CellIdentityLte cellIdentity =
-                new android.hardware.radio.V1_5.CellIdentityLte();
-        cellIdentity.base = getCellIdentityLte_1_2();
-        cellIdentity.additionalPlmns = new ArrayList<>(Arrays.asList(ADDITIONAL_PLMNS));
-        cellIdentity.optionalCsgInfo = getOptionalCsgInfo();
-        cellIdentity.bands = BANDS;
+        ArrayList<CellInfo> ret = RILUtils.convertHalCellInfoList(records);
 
-        return cellIdentity;
+        assertEquals(1, ret.size());
+        CellInfoGsm cellInfoGsm = (CellInfoGsm) ret.get(0);
+        CellInfoGsm expected = new CellInfoGsm();
+        expected.setRegistered(false);
+        expected.setTimeStamp(TIMESTAMP);
+        CellIdentityGsm ci = new CellIdentityGsm(
+                LAC, CID, ARFCN, BSIC, MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT,
+                Collections.emptyList());
+        CellSignalStrengthGsm cs = new CellSignalStrengthGsm(
+                RSSI, BIT_ERROR_RATE, TIMING_ADVANCE);
+        expected.setCellIdentity(ci);
+        expected.setCellSignalStrength(cs);
+        expected.setCellConnectionStatus(CellInfo.CONNECTION_UNKNOWN);
+        cellInfoGsm.setTimeStamp(TIMESTAMP); // override the timestamp
+        assertEquals(expected, cellInfoGsm);
     }
 
     @Test
-    public void testConvertHalCellInfoList_1_5ForLte() {
-        android.hardware.radio.V1_5.CellInfoLte cellInfoLte =
-                new android.hardware.radio.V1_5.CellInfoLte();
-        cellInfoLte.cellIdentityLte = getCellIdentityLte_1_5();
-        cellInfoLte.signalStrengthLte = getLteSignalStrength_1_0();
-
-        android.hardware.radio.V1_5.CellInfo cellInfo = new android.hardware.radio.V1_5.CellInfo();
-        cellInfo.registered = REGISTERED;
-        cellInfo.connectionStatus = CONNECTION_STATUS;
-        cellInfo.ratSpecificInfo.lte(cellInfoLte);
-
+    public void testConvertHalCellInfoListForWcdma() {
+        android.hardware.radio.V1_0.CellInfoWcdma cellinfo =
+                new android.hardware.radio.V1_0.CellInfoWcdma();
+        cellinfo.cellIdentityWcdma.lac = LAC;
+        cellinfo.cellIdentityWcdma.cid = CID;
+        cellinfo.cellIdentityWcdma.psc = PSC;
+        cellinfo.cellIdentityWcdma.uarfcn = UARFCN;
+        cellinfo.cellIdentityWcdma.mcc = MCC_STR;
+        cellinfo.cellIdentityWcdma.mnc = MNC_STR;
+        cellinfo.signalStrengthWcdma.signalStrength = RSSI_ASU;
+        cellinfo.signalStrengthWcdma.bitErrorRate = BIT_ERROR_RATE;
+        android.hardware.radio.V1_0.CellInfo record = new android.hardware.radio.V1_0.CellInfo();
+        record.cellInfoType = TYPE_WCDMA;
+        record.registered = false;
+        record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
+        record.timeStamp = TIMESTAMP;
+        record.wcdma.add(cellinfo);
         ArrayList<Object> records = new ArrayList<>();
-        records.add(cellInfo);
+        records.add(record);
 
         ArrayList<CellInfo> ret = RILUtils.convertHalCellInfoList(records);
 
         assertEquals(1, ret.size());
-        CellInfoLte cil = (CellInfoLte) ret.get(0);
-        cil.setTimeStamp(TIMESTAMP); // override the timestamp
+        CellInfoWcdma cellInfoWcdma = (CellInfoWcdma) ret.get(0);
+        CellInfoWcdma expected = new CellInfoWcdma();
+        expected.setRegistered(false);
+        expected.setTimeStamp(TIMESTAMP);
+        CellIdentityWcdma ci = new CellIdentityWcdma(
+                LAC, CID, PSC, UARFCN, MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT,
+                Collections.emptyList(), null);
+        CellSignalStrengthWcdma cs = new CellSignalStrengthWcdma(
+                RSSI, BIT_ERROR_RATE, Integer.MAX_VALUE, Integer.MAX_VALUE);
+        expected.setCellIdentity(ci);
+        expected.setCellSignalStrength(cs);
+        expected.setCellConnectionStatus(CellInfo.CONNECTION_UNKNOWN);
+        cellInfoWcdma.setTimeStamp(TIMESTAMP); // override the timestamp
+        assertEquals(expected, cellInfoWcdma);
+    }
 
-        Set<String> additionalPlmns = new HashSet<>();
-        Collections.addAll(additionalPlmns, ADDITIONAL_PLMNS);
-        ClosedSubscriberGroupInfo closedSubscriberGroupInfo =
-                new ClosedSubscriberGroupInfo(CSG_INDICATION, HOME_NODEB_NAME, CSG_IDENTITY);
-        CellIdentityLte cellIdentityLte = new CellIdentityLte(CI, PCI, TAC, EARFCN,
-                BANDS.stream().mapToInt(i -> i).toArray(), BANDWIDTH, MCC_STR, MNC_STR, ALPHA_LONG,
-                ALPHA_SHORT, additionalPlmns, closedSubscriberGroupInfo);
-        CellSignalStrengthLte cellSignalStrengthLte = new CellSignalStrengthLte(
-                RSSI, RSRP, RSRQ, RSSNR, CQI, TIMING_ADVANCE);
-        CellInfoLte expected = new CellInfoLte(CONNECTION_STATUS, REGISTERED, TIMESTAMP,
-                cellIdentityLte, cellSignalStrengthLte, new CellConfigLte());
-        assertEquals(expected, cil);
+    private static void initializeCellIdentityTdscdma_1_2(
+            android.hardware.radio.V1_2.CellIdentityTdscdma cid) {
+        cid.base.lac = LAC;
+        cid.base.cid = CID;
+        cid.base.cpid = PSC;
+        cid.base.mcc = MCC_STR;
+        cid.base.mnc = MNC_STR;
+        cid.uarfcn = UARFCN;
+        cid.operatorNames.alphaLong = ALPHA_LONG;
+        cid.operatorNames.alphaShort = ALPHA_SHORT;
     }
 
     @Test
-    public void testConvertHalCellInfoList_1_6ForLte() {
-        android.hardware.radio.V1_6.LteSignalStrength signalStrength =
-                new android.hardware.radio.V1_6.LteSignalStrength();
-        signalStrength.base = getLteSignalStrength_1_0();
-        signalStrength.cqiTableIndex = CQI_TABLE_INDEX;
-
-        android.hardware.radio.V1_6.CellInfoLte cellInfoLte =
-                new android.hardware.radio.V1_6.CellInfoLte();
-        cellInfoLte.cellIdentityLte = getCellIdentityLte_1_5();
-        cellInfoLte.signalStrengthLte = signalStrength;
-
-        android.hardware.radio.V1_6.CellInfo cellInfo = new android.hardware.radio.V1_6.CellInfo();
-        cellInfo.registered = REGISTERED;
-        cellInfo.connectionStatus = CONNECTION_STATUS;
-        cellInfo.ratSpecificInfo.lte(cellInfoLte);
-
+    public void testConvertHalCellInfoListForTdscdma() {
+        android.hardware.radio.V1_2.CellInfoTdscdma cellinfo =
+                new android.hardware.radio.V1_2.CellInfoTdscdma();
+        initializeCellIdentityTdscdma_1_2(cellinfo.cellIdentityTdscdma);
+
+        cellinfo.signalStrengthTdscdma.signalStrength = RSSI_ASU;
+        cellinfo.signalStrengthTdscdma.bitErrorRate = BIT_ERROR_RATE;
+        cellinfo.signalStrengthTdscdma.rscp = RSCP_ASU;
+        android.hardware.radio.V1_2.CellInfo record = new android.hardware.radio.V1_2.CellInfo();
+        record.cellInfoType = TYPE_TD_SCDMA;
+        record.registered = false;
+        record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
+        record.timeStamp = TIMESTAMP;
+        record.tdscdma.add(cellinfo);
         ArrayList<Object> records = new ArrayList<>();
-        records.add(cellInfo);
+        records.add(record);
 
         ArrayList<CellInfo> ret = RILUtils.convertHalCellInfoList(records);
 
         assertEquals(1, ret.size());
-        CellInfoLte cil = (CellInfoLte) ret.get(0);
-        cil.setTimeStamp(TIMESTAMP); // override the timestamp
-
-        Set<String> additionalPlmns = new HashSet<>();
-        Collections.addAll(additionalPlmns, ADDITIONAL_PLMNS);
-        ClosedSubscriberGroupInfo closedSubscriberGroupInfo =
-                new ClosedSubscriberGroupInfo(CSG_INDICATION, HOME_NODEB_NAME, CSG_IDENTITY);
-        CellIdentityLte cellIdentityLte = new CellIdentityLte(CI, PCI, TAC, EARFCN,
-                BANDS.stream().mapToInt(i -> i).toArray(), BANDWIDTH, MCC_STR, MNC_STR, ALPHA_LONG,
-                ALPHA_SHORT, additionalPlmns, closedSubscriberGroupInfo);
-        CellSignalStrengthLte cellSignalStrengthLte = new CellSignalStrengthLte(
-                RSSI, RSRP, RSRQ, RSSNR, CQI_TABLE_INDEX, CQI, TIMING_ADVANCE);
-        CellInfoLte expected = new CellInfoLte(CONNECTION_STATUS, REGISTERED, TIMESTAMP,
-                cellIdentityLte, cellSignalStrengthLte, new CellConfigLte());
-        assertEquals(expected, cil);
+        CellInfoTdscdma cellInfoTdscdma = (CellInfoTdscdma) ret.get(0);
+        CellInfoTdscdma expected = new CellInfoTdscdma();
+        expected.setRegistered(false);
+        expected.setTimeStamp(TIMESTAMP);
+        expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
+        CellIdentityTdscdma ci = new CellIdentityTdscdma(
+                MCC_STR, MNC_STR, LAC, CID, PSC, UARFCN, ALPHA_LONG, ALPHA_SHORT,
+                Collections.emptyList(), null);
+        CellSignalStrengthTdscdma cs = new CellSignalStrengthTdscdma(
+                RSSI, BIT_ERROR_RATE, RSCP);
+        expected.setCellIdentity(ci);
+        expected.setCellSignalStrength(cs);
+        cellInfoTdscdma.setTimeStamp(TIMESTAMP); // override the timestamp
+        assertEquals(expected, cellInfoTdscdma);
     }
 
-    private android.hardware.radio.V1_2.CellIdentityGsm getCellIdentityGsm_1_2() {
-        android.hardware.radio.V1_0.CellIdentityGsm cellIdentity0 =
-                new android.hardware.radio.V1_0.CellIdentityGsm();
-        cellIdentity0.mcc = MCC_STR;
-        cellIdentity0.mnc = MNC_STR;
-        cellIdentity0.lac = LAC;
-        cellIdentity0.cid = CID;
-        cellIdentity0.arfcn = ARFCN;
-        cellIdentity0.bsic = BSIC;
+    @Test
+    public void testConvertHalCellInfoListForCdma() {
+        android.hardware.radio.V1_0.CellInfoCdma cellinfo =
+                new android.hardware.radio.V1_0.CellInfoCdma();
+        cellinfo.cellIdentityCdma.networkId = NETWORK_ID;
+        cellinfo.cellIdentityCdma.systemId = SYSTEM_ID;
+        cellinfo.cellIdentityCdma.baseStationId = BASESTATION_ID;
+        cellinfo.cellIdentityCdma.longitude = LONGITUDE;
+        cellinfo.cellIdentityCdma.latitude = LATITUDE;
+        cellinfo.signalStrengthCdma.dbm = -DBM;
+        cellinfo.signalStrengthCdma.ecio = -ECIO;
+        cellinfo.signalStrengthEvdo.dbm = -DBM;
+        cellinfo.signalStrengthEvdo.ecio = -ECIO;
+        cellinfo.signalStrengthEvdo.signalNoiseRatio = SIGNAL_NOISE_RATIO;
+        android.hardware.radio.V1_0.CellInfo record = new android.hardware.radio.V1_0.CellInfo();
+        record.cellInfoType = TYPE_CDMA;
+        record.registered = false;
+        record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
+        record.timeStamp = TIMESTAMP;
+        record.cdma.add(cellinfo);
+        ArrayList<Object> records = new ArrayList<>();
+        records.add(record);
 
-        android.hardware.radio.V1_2.CellIdentityGsm cellIdentity =
-                new android.hardware.radio.V1_2.CellIdentityGsm();
-        cellIdentity.base = cellIdentity0;
-        cellIdentity.operatorNames = getCellIdentityOperatorNames();
+        ArrayList<CellInfo> ret = RILUtils.convertHalCellInfoList(records);
 
-        return cellIdentity;
+        assertEquals(1, ret.size());
+        CellInfoCdma cellInfoCdma = (CellInfoCdma) ret.get(0);
+        CellInfoCdma expected = new CellInfoCdma();
+        expected.setRegistered(false);
+        expected.setTimeStamp(TIMESTAMP);
+        CellIdentityCdma ci = new CellIdentityCdma(
+                NETWORK_ID, SYSTEM_ID, BASESTATION_ID, LONGITUDE, LATITUDE,
+                EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
+        CellSignalStrengthCdma cs = new CellSignalStrengthCdma(
+                DBM, ECIO, DBM, ECIO, SIGNAL_NOISE_RATIO);
+        expected.setCellIdentity(ci);
+        expected.setCellSignalStrength(cs);
+        expected.setCellConnectionStatus(CellInfo.CONNECTION_UNKNOWN);
+        cellInfoCdma.setTimeStamp(TIMESTAMP); // override the timestamp
+        assertEquals(expected, cellInfoCdma);
     }
 
-    private android.hardware.radio.V1_0.GsmSignalStrength getGsmSignalStrength_1_0() {
-        android.hardware.radio.V1_0.GsmSignalStrength signalStrength =
-                new android.hardware.radio.V1_0.GsmSignalStrength();
-        signalStrength.signalStrength = RSSI_ASU;
-        signalStrength.bitErrorRate = BIT_ERROR_RATE;
-        signalStrength.timingAdvance = TIMING_ADVANCE;
+    @Test
+    public void testConvertHalCellInfoList_1_2ForLTE() {
+        ArrayList<CellInfo> ret = getCellInfoListForLTE(MCC_STR, MNC_STR, ALPHA_LONG, ALPHA_SHORT);
 
-        return signalStrength;
+        assertEquals(1, ret.size());
+        CellInfoLte cellInfoLte = (CellInfoLte) ret.get(0);
+        CellInfoLte expected = new CellInfoLte();
+        expected.setRegistered(false);
+        expected.setTimeStamp(TIMESTAMP);
+        CellIdentityLte cil = new CellIdentityLte(
+                CI, PCI, TAC, EARFCN, new int[] {}, BANDWIDTH, MCC_STR, MNC_STR,
+                ALPHA_LONG, ALPHA_SHORT, Collections.emptyList(), null);
+        CellSignalStrengthLte css = new CellSignalStrengthLte(
+                RSSI, RSRP, RSRQ, RSSNR, CQI, TIMING_ADVANCE);
+        expected.setCellIdentity(cil);
+        expected.setCellSignalStrength(css);
+        expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
+        cellInfoLte.setTimeStamp(TIMESTAMP); // override the timestamp
+        assertEquals(expected, cellInfoLte);
     }
 
     @Test
-    public void testConvertHalCellInfoList_1_4ForGsm() {
-        android.hardware.radio.V1_2.CellInfoGsm cellInfoGsm =
-                new android.hardware.radio.V1_2.CellInfoGsm();
-        cellInfoGsm.cellIdentityGsm = getCellIdentityGsm_1_2();
-        cellInfoGsm.signalStrengthGsm = getGsmSignalStrength_1_0();
-
-        android.hardware.radio.V1_4.CellInfo cellInfo = new android.hardware.radio.V1_4.CellInfo();
-        cellInfo.isRegistered = REGISTERED;
-        cellInfo.connectionStatus = CONNECTION_STATUS;
-        cellInfo.info.gsm(cellInfoGsm);
-
-        ArrayList<Object> records = new ArrayList<>();
-        records.add(cellInfo);
-
-        ArrayList<CellInfo> ret = RILUtils.convertHalCellInfoList(records);
+    public void testConvertHalCellInfoList_1_2_ForLTEWithEmptyOperatorInfo() {
+        ArrayList<CellInfo> ret = getCellInfoListForLTE(
+                MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
 
         assertEquals(1, ret.size());
-        CellInfoGsm cig = (CellInfoGsm) ret.get(0);
-        cig.setTimeStamp(TIMESTAMP); // override the timestamp
-
-        CellIdentityGsm cellIdentityGsm = new CellIdentityGsm(LAC, CID, ARFCN, BSIC, MCC_STR,
-                MNC_STR, ALPHA_LONG, ALPHA_SHORT, Collections.emptyList());
-        CellSignalStrengthGsm cellSignalStrengthGsm = new CellSignalStrengthGsm(
-                RSSI, BIT_ERROR_RATE, TIMING_ADVANCE);
-        CellInfoGsm expected = new CellInfoGsm(CONNECTION_STATUS, REGISTERED, TIMESTAMP,
-                cellIdentityGsm, cellSignalStrengthGsm);
-        assertEquals(expected, cig);
+        CellInfoLte cellInfoLte = (CellInfoLte) ret.get(0);
+        CellInfoLte expected = new CellInfoLte();
+        expected.setRegistered(false);
+        expected.setTimeStamp(TIMESTAMP);
+        CellIdentityLte cil = new CellIdentityLte(CI, PCI, TAC, EARFCN, new int[] {},
+                BANDWIDTH, MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT,
+                Collections.emptyList(), null);
+        CellSignalStrengthLte css = new CellSignalStrengthLte(
+                RSSI, RSRP, RSRQ, RSSNR, CQI, TIMING_ADVANCE);
+        expected.setCellIdentity(cil);
+        expected.setCellSignalStrength(css);
+        expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
+        cellInfoLte.setTimeStamp(TIMESTAMP); // override the timestamp
+        assertEquals(expected, cellInfoLte);
     }
 
-    private android.hardware.radio.V1_5.CellInfoGsm getCellInfoGsm_1_5() {
-        android.hardware.radio.V1_5.CellIdentityGsm cellIdentity =
-                new android.hardware.radio.V1_5.CellIdentityGsm();
-        cellIdentity.base = getCellIdentityGsm_1_2();
-        cellIdentity.additionalPlmns = new ArrayList<>(Arrays.asList(ADDITIONAL_PLMNS));
-
-        android.hardware.radio.V1_5.CellInfoGsm cellInfo =
-                new android.hardware.radio.V1_5.CellInfoGsm();
-        cellInfo.cellIdentityGsm = cellIdentity;
-        cellInfo.signalStrengthGsm = getGsmSignalStrength_1_0();
+    @Test
+    public void testConvertHalCellInfoList_1_2ForLTEWithEmptyMccMnc() {
+        // MCC/MNC will be set as INT_MAX if unknown
+        ArrayList<CellInfo> ret = getCellInfoListForLTE(
+                String.valueOf(Integer.MAX_VALUE), String.valueOf(Integer.MAX_VALUE),
+                ALPHA_LONG, ALPHA_SHORT);
 
-        return cellInfo;
+        assertEquals(1, ret.size());
+        CellInfoLte cellInfoLte = (CellInfoLte) ret.get(0);
+        CellInfoLte expected = new CellInfoLte();
+        expected.setRegistered(false);
+        expected.setTimeStamp(TIMESTAMP);
+        CellIdentityLte cil = new CellIdentityLte(
+                CI, PCI, TAC, EARFCN, new int[] {}, BANDWIDTH, null, null, ALPHA_LONG,
+                ALPHA_SHORT, Collections.emptyList(), null);
+        CellSignalStrengthLte css = new CellSignalStrengthLte(
+                RSSI, RSRP, RSRQ, RSSNR, CQI, TIMING_ADVANCE);
+        expected.setCellIdentity(cil);
+        expected.setCellSignalStrength(css);
+        expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
+        cellInfoLte.setTimeStamp(TIMESTAMP); // override the timestamp
+        assertEquals(expected, cellInfoLte);
     }
 
     @Test
-    public void testConvertHalCellInfoList_1_5ForGsm() {
-        android.hardware.radio.V1_5.CellInfo cellInfo = new android.hardware.radio.V1_5.CellInfo();
-        cellInfo.registered = REGISTERED;
-        cellInfo.connectionStatus = CONNECTION_STATUS;
-        cellInfo.ratSpecificInfo.gsm(getCellInfoGsm_1_5());
-
-        ArrayList<Object> records = new ArrayList<>();
-        records.add(cellInfo);
-
-        ArrayList<CellInfo> ret = RILUtils.convertHalCellInfoList(records);
+    public void testConvertHalCellInfoList_1_2ForGSM() {
+        ArrayList<CellInfo> ret = getCellInfoListForGSM(MCC_STR, MNC_STR, ALPHA_LONG, ALPHA_SHORT);
 
         assertEquals(1, ret.size());
         CellInfoGsm cellInfoGsm = (CellInfoGsm) ret.get(0);
-        cellInfoGsm.setTimeStamp(TIMESTAMP); // override the timestamp
-
-        Set<String> additionalPlmns = new HashSet<>();
-        Collections.addAll(additionalPlmns, ADDITIONAL_PLMNS);
-        CellIdentityGsm cellIdentityGsm = new CellIdentityGsm(LAC, CID, ARFCN, BSIC, MCC_STR,
-                MNC_STR, ALPHA_LONG, ALPHA_SHORT, additionalPlmns);
-        CellSignalStrengthGsm cellSignalStrengthGsm = new CellSignalStrengthGsm(
+        CellInfoGsm expected = new CellInfoGsm();
+        expected.setRegistered(false);
+        expected.setTimeStamp(TIMESTAMP);
+        CellIdentityGsm ci = new CellIdentityGsm(
+                LAC, CID, ARFCN, BSIC, MCC_STR, MNC_STR, ALPHA_LONG, ALPHA_SHORT,
+                Collections.emptyList());
+        CellSignalStrengthGsm cs = new CellSignalStrengthGsm(
                 RSSI, BIT_ERROR_RATE, TIMING_ADVANCE);
-        CellInfoGsm expected = new CellInfoGsm(CONNECTION_STATUS, REGISTERED, TIMESTAMP,
-                cellIdentityGsm, cellSignalStrengthGsm);
+        expected.setCellIdentity(ci);
+        expected.setCellSignalStrength(cs);
+        expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
+        cellInfoGsm.setTimeStamp(TIMESTAMP); // override the timestamp
         assertEquals(expected, cellInfoGsm);
     }
 
     @Test
-    public void testConvertHalCellInfoList_1_6ForGsm() {
-        android.hardware.radio.V1_6.CellInfo cellInfo = new android.hardware.radio.V1_6.CellInfo();
-        cellInfo.registered = REGISTERED;
-        cellInfo.connectionStatus = CONNECTION_STATUS;
-        cellInfo.ratSpecificInfo.gsm(getCellInfoGsm_1_5());
-
-        ArrayList<Object> records = new ArrayList<>();
-        records.add(cellInfo);
-
-        ArrayList<CellInfo> ret = RILUtils.convertHalCellInfoList(records);
+    public void testConvertHalCellInfoList_1_2ForGSMWithEmptyOperatorInfo() {
+        ArrayList<CellInfo> ret = getCellInfoListForGSM(
+                MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
 
         assertEquals(1, ret.size());
         CellInfoGsm cellInfoGsm = (CellInfoGsm) ret.get(0);
-        cellInfoGsm.setTimeStamp(TIMESTAMP); // override the timestamp
-
-        Set<String> additionalPlmns = new HashSet<>();
-        Collections.addAll(additionalPlmns, ADDITIONAL_PLMNS);
-        CellIdentityGsm cellIdentityGsm = new CellIdentityGsm(LAC, CID, ARFCN, BSIC, MCC_STR,
-                MNC_STR, ALPHA_LONG, ALPHA_SHORT, additionalPlmns);
-        CellSignalStrengthGsm cellSignalStrengthGsm = new CellSignalStrengthGsm(
+        CellInfoGsm expected = new CellInfoGsm();
+        expected.setRegistered(false);
+        expected.setTimeStamp(TIMESTAMP);
+        CellIdentityGsm ci = new CellIdentityGsm(
+                LAC, CID, ARFCN, BSIC, MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT,
+                Collections.emptyList());
+        CellSignalStrengthGsm cs = new CellSignalStrengthGsm(
                 RSSI, BIT_ERROR_RATE, TIMING_ADVANCE);
-        CellInfoGsm expected = new CellInfoGsm(CONNECTION_STATUS, REGISTERED, TIMESTAMP,
-                cellIdentityGsm, cellSignalStrengthGsm);
+        expected.setCellIdentity(ci);
+        expected.setCellSignalStrength(cs);
+        expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
+        cellInfoGsm.setTimeStamp(TIMESTAMP); // override the timestamp
         assertEquals(expected, cellInfoGsm);
     }
 
-    private android.hardware.radio.V1_2.CellIdentityWcdma getCellIdentityWcdma_1_2() {
-        android.hardware.radio.V1_0.CellIdentityWcdma cellIdentity0 =
-                new android.hardware.radio.V1_0.CellIdentityWcdma();
-        cellIdentity0.mcc = MCC_STR;
-        cellIdentity0.mnc = MNC_STR;
-        cellIdentity0.lac = LAC;
-        cellIdentity0.cid = CID;
-        cellIdentity0.psc = PSC;
-        cellIdentity0.uarfcn = UARFCN;
-
-        android.hardware.radio.V1_2.CellIdentityWcdma cellIdentity =
-                new android.hardware.radio.V1_2.CellIdentityWcdma();
-        cellIdentity.base = cellIdentity0;
-        cellIdentity.operatorNames = getCellIdentityOperatorNames();
-
-        return cellIdentity;
-    }
-
-    private android.hardware.radio.V1_2.WcdmaSignalStrength getWcdmaSignalStrength_1_2() {
-        android.hardware.radio.V1_0.WcdmaSignalStrength signalStrength0 =
-                new android.hardware.radio.V1_0.WcdmaSignalStrength();
-        signalStrength0.signalStrength = RSSI_ASU;
-        signalStrength0.bitErrorRate = BIT_ERROR_RATE;
-
-        android.hardware.radio.V1_2.WcdmaSignalStrength signalStrength =
-                new android.hardware.radio.V1_2.WcdmaSignalStrength();
-        signalStrength.base = signalStrength0;
-        signalStrength.rscp = RSCP_ASU;
-        signalStrength.ecno = ECNO_ASU;
-
-        return signalStrength;
-    }
-
     @Test
-    public void testConvertHalCellInfoList_1_4ForWcdma() {
-        android.hardware.radio.V1_2.CellInfoWcdma cellInfoWcdma =
-                new android.hardware.radio.V1_2.CellInfoWcdma();
-        cellInfoWcdma.cellIdentityWcdma = getCellIdentityWcdma_1_2();
-        cellInfoWcdma.signalStrengthWcdma = getWcdmaSignalStrength_1_2();
-
-        android.hardware.radio.V1_4.CellInfo cellInfo = new android.hardware.radio.V1_4.CellInfo();
-        cellInfo.isRegistered = REGISTERED;
-        cellInfo.connectionStatus = CONNECTION_STATUS;
-        cellInfo.info.wcdma(cellInfoWcdma);
-
-        ArrayList<Object> records = new ArrayList<>();
-        records.add(cellInfo);
-
-        ArrayList<CellInfo> ret = RILUtils.convertHalCellInfoList(records);
+    public void testConvertHalCellInfoList_1_2ForGSMWithEmptyMccMnc() {
+        // MCC/MNC will be set as INT_MAX if unknown
+        ArrayList<CellInfo> ret = getCellInfoListForGSM(
+                String.valueOf(Integer.MAX_VALUE), String.valueOf(Integer.MAX_VALUE),
+                ALPHA_LONG, ALPHA_SHORT);
 
         assertEquals(1, ret.size());
-        CellInfoWcdma ciw = (CellInfoWcdma) ret.get(0);
-        ciw.setTimeStamp(TIMESTAMP); // override the timestamp
-
-        CellIdentityWcdma cellIdentityWcdma = new CellIdentityWcdma(LAC, CID, PSC, UARFCN, MCC_STR,
-                MNC_STR, ALPHA_LONG, ALPHA_SHORT, Collections.emptyList(), null);
-        CellSignalStrengthWcdma cellSignalStrengthWcdma = new CellSignalStrengthWcdma(
-                RSSI, BIT_ERROR_RATE, RSCP, ECNO);
-        CellInfoWcdma expected = new CellInfoWcdma(CONNECTION_STATUS, REGISTERED, TIMESTAMP,
-                cellIdentityWcdma, cellSignalStrengthWcdma);
-        assertEquals(expected, ciw);
-    }
-
-    private android.hardware.radio.V1_5.CellInfoWcdma getCellInfoWcdma_1_5() {
-        android.hardware.radio.V1_5.CellIdentityWcdma cellIdentity =
-                new android.hardware.radio.V1_5.CellIdentityWcdma();
-        cellIdentity.base = getCellIdentityWcdma_1_2();
-        cellIdentity.additionalPlmns = new ArrayList<>(Arrays.asList(ADDITIONAL_PLMNS));
-        cellIdentity.optionalCsgInfo = getOptionalCsgInfo();
-
-        android.hardware.radio.V1_5.CellInfoWcdma cellInfo =
-                new android.hardware.radio.V1_5.CellInfoWcdma();
-        cellInfo.cellIdentityWcdma = cellIdentity;
-        cellInfo.signalStrengthWcdma = getWcdmaSignalStrength_1_2();
-
-        return cellInfo;
+        CellInfoGsm cellInfoGsm = (CellInfoGsm) ret.get(0);
+        CellInfoGsm expected = new CellInfoGsm();
+        expected.setRegistered(false);
+        expected.setTimeStamp(TIMESTAMP);
+        CellIdentityGsm ci = new CellIdentityGsm(
+                LAC, CID, ARFCN, BSIC, null, null, ALPHA_LONG, ALPHA_SHORT,
+                Collections.emptyList());
+        CellSignalStrengthGsm cs = new CellSignalStrengthGsm(
+                RSSI, BIT_ERROR_RATE, TIMING_ADVANCE);
+        expected.setCellIdentity(ci);
+        expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
+        expected.setCellSignalStrength(cs);
+        cellInfoGsm.setTimeStamp(TIMESTAMP); // override the timestamp
+        assertEquals(expected, cellInfoGsm);
     }
 
     @Test
-    public void testConvertHalCellInfoList_1_5ForWcdma() {
-        android.hardware.radio.V1_5.CellInfo cellInfo = new android.hardware.radio.V1_5.CellInfo();
-        cellInfo.registered = REGISTERED;
-        cellInfo.connectionStatus = CONNECTION_STATUS;
-        cellInfo.ratSpecificInfo.wcdma(getCellInfoWcdma_1_5());
-
-        ArrayList<Object> records = new ArrayList<>();
-        records.add(cellInfo);
-
-        ArrayList<CellInfo> ret = RILUtils.convertHalCellInfoList(records);
+    public void testConvertHalCellInfoList_1_2ForWcdma() {
+        ArrayList<CellInfo> ret = getCellInfoListForWcdma(
+                MCC_STR, MNC_STR, ALPHA_LONG, ALPHA_SHORT);
 
         assertEquals(1, ret.size());
         CellInfoWcdma cellInfoWcdma = (CellInfoWcdma) ret.get(0);
+        CellInfoWcdma expected = new CellInfoWcdma();
+        expected.setRegistered(false);
+        expected.setTimeStamp(TIMESTAMP);
+        CellIdentityWcdma ci = new CellIdentityWcdma(
+                LAC, CID, PSC, UARFCN, MCC_STR, MNC_STR, ALPHA_LONG, ALPHA_SHORT,
+                Collections.emptyList(), null);
+        CellSignalStrengthWcdma cs =
+                new CellSignalStrengthWcdma(RSSI, BIT_ERROR_RATE, RSCP, ECNO);
+        expected.setCellIdentity(ci);
+        expected.setCellSignalStrength(cs);
+        expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
         cellInfoWcdma.setTimeStamp(TIMESTAMP); // override the timestamp
-
-        Set<String> additionalPlmns = new HashSet<>();
-        Collections.addAll(additionalPlmns, ADDITIONAL_PLMNS);
-        ClosedSubscriberGroupInfo closedSubscriberGroupInfo =
-                new ClosedSubscriberGroupInfo(CSG_INDICATION, HOME_NODEB_NAME, CSG_IDENTITY);
-        CellIdentityWcdma cellIdentityWcdma = new CellIdentityWcdma(LAC, CID, PSC, UARFCN, MCC_STR,
-                MNC_STR, ALPHA_LONG, ALPHA_SHORT, additionalPlmns, closedSubscriberGroupInfo);
-        CellSignalStrengthWcdma cellSignalStrengthWcdma = new CellSignalStrengthWcdma(
-                RSSI, BIT_ERROR_RATE, RSCP, ECNO);
-        CellInfoWcdma expected = new CellInfoWcdma(CONNECTION_STATUS, REGISTERED, TIMESTAMP,
-                cellIdentityWcdma, cellSignalStrengthWcdma);
         assertEquals(expected, cellInfoWcdma);
     }
 
     @Test
-    public void testConvertHalCellInfoList_1_6ForWcdma() {
-        android.hardware.radio.V1_6.CellInfo cellInfo = new android.hardware.radio.V1_6.CellInfo();
-        cellInfo.registered = REGISTERED;
-        cellInfo.connectionStatus = CONNECTION_STATUS;
-        cellInfo.ratSpecificInfo.wcdma(getCellInfoWcdma_1_5());
-
-        ArrayList<Object> records = new ArrayList<>();
-        records.add(cellInfo);
-
-        ArrayList<CellInfo> ret = RILUtils.convertHalCellInfoList(records);
+    public void testConvertHalCellInfoList_1_2ForWcdmaWithEmptyOperatorInfo() {
+        ArrayList<CellInfo> ret = getCellInfoListForWcdma(
+                MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
 
         assertEquals(1, ret.size());
         CellInfoWcdma cellInfoWcdma = (CellInfoWcdma) ret.get(0);
-        cellInfoWcdma.setTimeStamp(TIMESTAMP); // override the timestamp
-
-        Set<String> additionalPlmns = new HashSet<>();
-        Collections.addAll(additionalPlmns, ADDITIONAL_PLMNS);
-        ClosedSubscriberGroupInfo closedSubscriberGroupInfo =
-                new ClosedSubscriberGroupInfo(CSG_INDICATION, HOME_NODEB_NAME, CSG_IDENTITY);
-        CellIdentityWcdma cellIdentityWcdma = new CellIdentityWcdma(LAC, CID, PSC, UARFCN, MCC_STR,
-                MNC_STR, ALPHA_LONG, ALPHA_SHORT, additionalPlmns, closedSubscriberGroupInfo);
-        CellSignalStrengthWcdma cellSignalStrengthWcdma = new CellSignalStrengthWcdma(
+        CellInfoWcdma expected = new CellInfoWcdma();
+        expected.setRegistered(false);
+        expected.setTimeStamp(TIMESTAMP);
+        CellIdentityWcdma ci = new CellIdentityWcdma(
+                LAC, CID, PSC, UARFCN, MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT,
+                Collections.emptyList(), null);
+        CellSignalStrengthWcdma cs = new CellSignalStrengthWcdma(
                 RSSI, BIT_ERROR_RATE, RSCP, ECNO);
-        CellInfoWcdma expected = new CellInfoWcdma(CONNECTION_STATUS, REGISTERED, TIMESTAMP,
-                cellIdentityWcdma, cellSignalStrengthWcdma);
+        expected.setCellIdentity(ci);
+        expected.setCellSignalStrength(cs);
+        expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
+        cellInfoWcdma.setTimeStamp(TIMESTAMP); // override the timestamp
         assertEquals(expected, cellInfoWcdma);
     }
 
-    private android.hardware.radio.V1_2.CellIdentityTdscdma getCellIdentityTdscdma_1_2() {
-        android.hardware.radio.V1_0.CellIdentityTdscdma cellIdentity0 =
-                new android.hardware.radio.V1_0.CellIdentityTdscdma();
-        cellIdentity0.mcc = MCC_STR;
-        cellIdentity0.mnc = MNC_STR;
-        cellIdentity0.lac = LAC;
-        cellIdentity0.cid = CID;
-        cellIdentity0.cpid = PSC;
-
-        android.hardware.radio.V1_2.CellIdentityTdscdma cellIdentity =
-                new android.hardware.radio.V1_2.CellIdentityTdscdma();
-        cellIdentity.base = cellIdentity0;
-        cellIdentity.uarfcn = UARFCN;
-        cellIdentity.operatorNames = getCellIdentityOperatorNames();
-
-        return cellIdentity;
-    }
-
-    private android.hardware.radio.V1_2.TdscdmaSignalStrength getTdscdmaSignalStrength_1_2() {
-        android.hardware.radio.V1_2.TdscdmaSignalStrength signalStrength =
-                new android.hardware.radio.V1_2.TdscdmaSignalStrength();
-        signalStrength.signalStrength = RSSI_ASU;
-        signalStrength.bitErrorRate = BIT_ERROR_RATE;
-        signalStrength.rscp = RSCP_ASU;
-
-        return signalStrength;
-    }
-
     @Test
-    public void testConvertHalCellInfoList_1_4ForTdscdma() {
-        android.hardware.radio.V1_2.CellInfoTdscdma cellInfoTdscdma =
-                new android.hardware.radio.V1_2.CellInfoTdscdma();
-        cellInfoTdscdma.cellIdentityTdscdma = getCellIdentityTdscdma_1_2();
-        cellInfoTdscdma.signalStrengthTdscdma = getTdscdmaSignalStrength_1_2();
-
-        android.hardware.radio.V1_4.CellInfo cellInfo = new android.hardware.radio.V1_4.CellInfo();
-        cellInfo.isRegistered = REGISTERED;
-        cellInfo.connectionStatus = CONNECTION_STATUS;
-        cellInfo.info.tdscdma(cellInfoTdscdma);
-
-        ArrayList<Object> records = new ArrayList<>();
-        records.add(cellInfo);
-
-        ArrayList<CellInfo> ret = RILUtils.convertHalCellInfoList(records);
+    public void testConvertHalCellInfoList_1_2ForWcdmaWithEmptyMccMnc() {
+        // MCC/MNC will be set as INT_MAX if unknown
+        ArrayList<CellInfo> ret = getCellInfoListForWcdma(null, null, ALPHA_LONG, ALPHA_SHORT);
 
         assertEquals(1, ret.size());
-        CellInfoTdscdma cit = (CellInfoTdscdma) ret.get(0);
-        cit.setTimeStamp(TIMESTAMP); // override the timestamp
-
-        CellIdentityTdscdma cellIdentityTdscdma = new CellIdentityTdscdma(
-                MCC_STR, MNC_STR, LAC, CID, PSC, UARFCN, ALPHA_LONG, ALPHA_SHORT,
+        CellInfoWcdma cellInfoWcdma = (CellInfoWcdma) ret.get(0);
+        CellInfoWcdma expected = new CellInfoWcdma();
+        expected.setRegistered(false);
+        expected.setTimeStamp(TIMESTAMP);
+        CellIdentityWcdma ci = new CellIdentityWcdma(
+                LAC, CID, PSC, UARFCN, null, null, ALPHA_LONG, ALPHA_SHORT,
                 Collections.emptyList(), null);
-        CellSignalStrengthTdscdma cellSignalStrengthTdscdma = new CellSignalStrengthTdscdma(
-                RSSI, BIT_ERROR_RATE, RSCP);
-        CellInfoTdscdma expected = new CellInfoTdscdma(CONNECTION_STATUS, REGISTERED, TIMESTAMP,
-                cellIdentityTdscdma, cellSignalStrengthTdscdma);
-        assertEquals(expected, cit);
-    }
-
-    private android.hardware.radio.V1_5.CellInfoTdscdma getCellInfoTdscdma_1_5() {
-        android.hardware.radio.V1_5.CellIdentityTdscdma cellIdentity =
-                new android.hardware.radio.V1_5.CellIdentityTdscdma();
-        cellIdentity.base = getCellIdentityTdscdma_1_2();
-        cellIdentity.additionalPlmns = new ArrayList<>(Arrays.asList(ADDITIONAL_PLMNS));
-        cellIdentity.optionalCsgInfo = getOptionalCsgInfo();
-
-        android.hardware.radio.V1_5.CellInfoTdscdma cellInfo =
-                new android.hardware.radio.V1_5.CellInfoTdscdma();
-        cellInfo.cellIdentityTdscdma = cellIdentity;
-        cellInfo.signalStrengthTdscdma = getTdscdmaSignalStrength_1_2();
-
-        return cellInfo;
-    }
-
-    @Test
-    public void testConvertHalCellInfoList_1_5ForTdscdma() {
-        android.hardware.radio.V1_5.CellInfo cellInfo = new android.hardware.radio.V1_5.CellInfo();
-        cellInfo.registered = REGISTERED;
-        cellInfo.connectionStatus = CONNECTION_STATUS;
-        cellInfo.ratSpecificInfo.tdscdma(getCellInfoTdscdma_1_5());
-
-        ArrayList<Object> records = new ArrayList<>();
-        records.add(cellInfo);
-
-        ArrayList<CellInfo> ret = RILUtils.convertHalCellInfoList(records);
-
-        assertEquals(1, ret.size());
-        CellInfoTdscdma cellInfoTdscdma = (CellInfoTdscdma) ret.get(0);
-        cellInfoTdscdma.setTimeStamp(TIMESTAMP); // override the timestamp
-
-        Set<String> additionalPlmns = new HashSet<>();
-        Collections.addAll(additionalPlmns, ADDITIONAL_PLMNS);
-        ClosedSubscriberGroupInfo closedSubscriberGroupInfo =
-                new ClosedSubscriberGroupInfo(CSG_INDICATION, HOME_NODEB_NAME, CSG_IDENTITY);
-        CellIdentityTdscdma cellIdentityTdscdma = new CellIdentityTdscdma(
-                MCC_STR, MNC_STR, LAC, CID, PSC, UARFCN, ALPHA_LONG, ALPHA_SHORT,
-                additionalPlmns, closedSubscriberGroupInfo);
-        CellSignalStrengthTdscdma cellSignalStrengthTdscdma = new CellSignalStrengthTdscdma(
-                RSSI, BIT_ERROR_RATE, RSCP);
-        CellInfoTdscdma expected = new CellInfoTdscdma(CONNECTION_STATUS, REGISTERED, TIMESTAMP,
-                cellIdentityTdscdma, cellSignalStrengthTdscdma);
-        assertEquals(expected, cellInfoTdscdma);
-    }
-
-    @Test
-    public void testConvertHalCellInfoList_1_6ForTdscdma() {
-        android.hardware.radio.V1_6.CellInfo cellInfo = new android.hardware.radio.V1_6.CellInfo();
-        cellInfo.registered = REGISTERED;
-        cellInfo.connectionStatus = CONNECTION_STATUS;
-        cellInfo.ratSpecificInfo.tdscdma(getCellInfoTdscdma_1_5());
-
-        ArrayList<Object> records = new ArrayList<>();
-        records.add(cellInfo);
-
-        ArrayList<CellInfo> ret = RILUtils.convertHalCellInfoList(records);
-
-        assertEquals(1, ret.size());
-        CellInfoTdscdma cellInfoTdscdma = (CellInfoTdscdma) ret.get(0);
-        cellInfoTdscdma.setTimeStamp(TIMESTAMP); // override the timestamp
-
-        Set<String> additionalPlmns = new HashSet<>();
-        Collections.addAll(additionalPlmns, ADDITIONAL_PLMNS);
-        ClosedSubscriberGroupInfo closedSubscriberGroupInfo =
-                new ClosedSubscriberGroupInfo(CSG_INDICATION, HOME_NODEB_NAME, CSG_IDENTITY);
-        CellIdentityTdscdma cellIdentityTdscdma = new CellIdentityTdscdma(
-                MCC_STR, MNC_STR, LAC, CID, PSC, UARFCN, ALPHA_LONG, ALPHA_SHORT,
-                additionalPlmns, closedSubscriberGroupInfo);
-        CellSignalStrengthTdscdma cellSignalStrengthTdscdma = new CellSignalStrengthTdscdma(
-                RSSI, BIT_ERROR_RATE, RSCP);
-        CellInfoTdscdma expected = new CellInfoTdscdma(CONNECTION_STATUS, REGISTERED, TIMESTAMP,
-                cellIdentityTdscdma, cellSignalStrengthTdscdma);
-        assertEquals(expected, cellInfoTdscdma);
-    }
-
-    private android.hardware.radio.V1_2.CellInfoCdma getCellInfoCdma_1_2() {
-        android.hardware.radio.V1_0.CellIdentityCdma cellIdentity0 =
-                new android.hardware.radio.V1_0.CellIdentityCdma();
-        cellIdentity0.networkId = NETWORK_ID;
-        cellIdentity0.systemId = SYSTEM_ID;
-        cellIdentity0.baseStationId = BASESTATION_ID;
-        cellIdentity0.longitude = LONGITUDE;
-        cellIdentity0.latitude = LATITUDE;
-
-        android.hardware.radio.V1_2.CellIdentityCdma cellIdentity =
-                new android.hardware.radio.V1_2.CellIdentityCdma();
-        cellIdentity.base = cellIdentity0;
-        cellIdentity.operatorNames = getCellIdentityOperatorNames();
-
-        android.hardware.radio.V1_0.CdmaSignalStrength cdmaSignalStrength =
-                new android.hardware.radio.V1_0.CdmaSignalStrength();
-        cdmaSignalStrength.dbm = -DBM;
-        cdmaSignalStrength.ecio = -ECIO;
-
-        android.hardware.radio.V1_0.EvdoSignalStrength evdoSignalStrength =
-                new android.hardware.radio.V1_0.EvdoSignalStrength();
-        evdoSignalStrength.dbm = -DBM;
-        evdoSignalStrength.ecio = -ECIO;
-        evdoSignalStrength.signalNoiseRatio = SIGNAL_NOISE_RATIO;
-
-        android.hardware.radio.V1_2.CellInfoCdma cellInfo =
-                new android.hardware.radio.V1_2.CellInfoCdma();
-        cellInfo.cellIdentityCdma = cellIdentity;
-        cellInfo.signalStrengthCdma = cdmaSignalStrength;
-        cellInfo.signalStrengthEvdo = evdoSignalStrength;
-
-        return cellInfo;
+        CellSignalStrengthWcdma cs = new CellSignalStrengthWcdma(
+                RSSI, BIT_ERROR_RATE, RSCP, ECNO);
+        expected.setCellIdentity(ci);
+        expected.setCellSignalStrength(cs);
+        expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
+        cellInfoWcdma.setTimeStamp(TIMESTAMP); // override the timestamp
+        assertEquals(expected, cellInfoWcdma);
     }
 
     @Test
-    public void testConvertHalCellInfoList_1_4ForCdma() {
-        android.hardware.radio.V1_4.CellInfo cellInfo = new android.hardware.radio.V1_4.CellInfo();
-        cellInfo.isRegistered = REGISTERED;
-        cellInfo.connectionStatus = CONNECTION_STATUS;
-        cellInfo.info.cdma(getCellInfoCdma_1_2());
-
-        ArrayList<Object> records = new ArrayList<>();
-        records.add(cellInfo);
-
-        ArrayList<CellInfo> ret = RILUtils.convertHalCellInfoList(records);
+    public void testConvertHalCellInfoList_1_2ForCdma() {
+        ArrayList<CellInfo> ret = getCellInfoListForCdma(ALPHA_LONG, ALPHA_SHORT);
 
         assertEquals(1, ret.size());
         CellInfoCdma cellInfoCdma = (CellInfoCdma) ret.get(0);
-        cellInfoCdma.setTimeStamp(TIMESTAMP); // override the timestamp
-
-        CellIdentityCdma cellIdentityCdma = new CellIdentityCdma(NETWORK_ID, SYSTEM_ID,
-                BASESTATION_ID, LONGITUDE, LATITUDE, ALPHA_LONG, ALPHA_SHORT);
-        CellSignalStrengthCdma cellSignalStrengthCdma = new CellSignalStrengthCdma(
+        CellInfoCdma expected = new CellInfoCdma();
+        expected.setRegistered(false);
+        expected.setTimeStamp(TIMESTAMP);
+        CellIdentityCdma ci = new CellIdentityCdma(
+                NETWORK_ID, SYSTEM_ID, BASESTATION_ID, LONGITUDE, LATITUDE,
+                ALPHA_LONG, ALPHA_SHORT);
+        CellSignalStrengthCdma cs = new CellSignalStrengthCdma(
                 DBM, ECIO, DBM, ECIO, SIGNAL_NOISE_RATIO);
-        CellInfoCdma expected = new CellInfoCdma(CONNECTION_STATUS, REGISTERED, TIMESTAMP,
-                cellIdentityCdma, cellSignalStrengthCdma);
-        assertEquals(expected, cellInfoCdma);
-    }
-
-    @Test
-    public void testConvertHalCellInfoList_1_5ForCdma() {
-        android.hardware.radio.V1_5.CellInfo cellInfo = new android.hardware.radio.V1_5.CellInfo();
-        cellInfo.registered = REGISTERED;
-        cellInfo.connectionStatus = CONNECTION_STATUS;
-        cellInfo.ratSpecificInfo.cdma(getCellInfoCdma_1_2());
-
-        ArrayList<Object> records = new ArrayList<>();
-        records.add(cellInfo);
-
-        ArrayList<CellInfo> ret = RILUtils.convertHalCellInfoList(records);
-
-        assertEquals(1, ret.size());
-        CellInfoCdma cellInfoCdma = (CellInfoCdma) ret.get(0);
+        expected.setCellIdentity(ci);
+        expected.setCellSignalStrength(cs);
+        expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
         cellInfoCdma.setTimeStamp(TIMESTAMP); // override the timestamp
-
-        CellIdentityCdma cellIdentityCdma = new CellIdentityCdma(NETWORK_ID, SYSTEM_ID,
-                BASESTATION_ID, LONGITUDE, LATITUDE, ALPHA_LONG, ALPHA_SHORT);
-        CellSignalStrengthCdma cellSignalStrengthCdma = new CellSignalStrengthCdma(
-                DBM, ECIO, DBM, ECIO, SIGNAL_NOISE_RATIO);
-        CellInfoCdma expected = new CellInfoCdma(CONNECTION_STATUS, REGISTERED, TIMESTAMP,
-                cellIdentityCdma, cellSignalStrengthCdma);
         assertEquals(expected, cellInfoCdma);
     }
 
     @Test
-    public void testConvertHalCellInfoList_1_6ForCdma() {
-        android.hardware.radio.V1_6.CellInfo cellInfo = new android.hardware.radio.V1_6.CellInfo();
-        cellInfo.registered = REGISTERED;
-        cellInfo.connectionStatus = CONNECTION_STATUS;
-        cellInfo.ratSpecificInfo.cdma(getCellInfoCdma_1_2());
-
-        ArrayList<Object> records = new ArrayList<>();
-        records.add(cellInfo);
-
-        ArrayList<CellInfo> ret = RILUtils.convertHalCellInfoList(records);
+    public void testConvertHalCellInfoList_1_2ForCdmaWithEmptyOperatorInfo() {
+        ArrayList<CellInfo> ret = getCellInfoListForCdma(EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
 
         assertEquals(1, ret.size());
         CellInfoCdma cellInfoCdma = (CellInfoCdma) ret.get(0);
-        cellInfoCdma.setTimeStamp(TIMESTAMP); // override the timestamp
-
-        CellIdentityCdma cellIdentityCdma = new CellIdentityCdma(NETWORK_ID, SYSTEM_ID,
-                BASESTATION_ID, LONGITUDE, LATITUDE, ALPHA_LONG, ALPHA_SHORT);
-        CellSignalStrengthCdma cellSignalStrengthCdma = new CellSignalStrengthCdma(
+        CellInfoCdma expected = new CellInfoCdma();
+        expected.setRegistered(false);
+        expected.setTimeStamp(TIMESTAMP);
+        CellIdentityCdma ci = new CellIdentityCdma(
+                NETWORK_ID, SYSTEM_ID, BASESTATION_ID, LONGITUDE, LATITUDE,
+                EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
+        CellSignalStrengthCdma cs = new CellSignalStrengthCdma(
                 DBM, ECIO, DBM, ECIO, SIGNAL_NOISE_RATIO);
-        CellInfoCdma expected = new CellInfoCdma(CONNECTION_STATUS, REGISTERED, TIMESTAMP,
-                cellIdentityCdma, cellSignalStrengthCdma);
+        expected.setCellIdentity(ci);
+        expected.setCellSignalStrength(cs);
+        expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
+        cellInfoCdma.setTimeStamp(TIMESTAMP); // override the timestamp
         assertEquals(expected, cellInfoCdma);
     }
 
@@ -2329,8 +2108,170 @@ public class RILTest extends TelephonyTest {
         assertEquals(expectedSignalStrength, signalStrengthNr);
     }
 
+    private static android.hardware.radio.V1_5.ClosedSubscriberGroupInfo getHalCsgInfo() {
+        android.hardware.radio.V1_5.ClosedSubscriberGroupInfo csgInfo =
+                new android.hardware.radio.V1_5.ClosedSubscriberGroupInfo();
+
+        csgInfo.csgIndication = CSG_INDICATION;
+        csgInfo.homeNodebName = HOME_NODEB_NAME;
+        csgInfo.csgIdentity = CSG_IDENTITY;
+
+        return csgInfo;
+    }
+
+    private static void initializeCellIdentityLte_1_5(
+            android.hardware.radio.V1_5.CellIdentityLte id,
+            boolean addAdditionalPlmns, boolean addCsgInfo) {
+
+        initializeCellIdentityLte_1_2(id.base);
+
+        if (addAdditionalPlmns) {
+            id.additionalPlmns = new ArrayList<>(
+                    Arrays.asList(ADDITIONAL_PLMNS));
+        }
+
+        if (addCsgInfo) {
+            id.optionalCsgInfo.csgInfo(getHalCsgInfo());
+        }
+    }
+
+    @Test
+    public void testCellIdentityLte_1_5_CsgInfo() {
+        android.hardware.radio.V1_5.CellIdentityLte halCellIdentity =
+                new android.hardware.radio.V1_5.CellIdentityLte();
+        initializeCellIdentityLte_1_5(halCellIdentity, false, true);
+
+        CellIdentityLte cellIdentity = RILUtils.convertHalCellIdentityLte(halCellIdentity);
+
+        assertEquals(CSG_INDICATION,
+                cellIdentity.getClosedSubscriberGroupInfo().getCsgIndicator());
+        assertEquals(HOME_NODEB_NAME,
+                cellIdentity.getClosedSubscriberGroupInfo().getHomeNodebName());
+        assertEquals(CSG_IDENTITY,
+                cellIdentity.getClosedSubscriberGroupInfo().getCsgIdentity());
+    }
+
+    @Test
+    public void testCellIdentityLte_1_5_MultiPlmn() {
+        android.hardware.radio.V1_5.CellIdentityLte halCellIdentity =
+                new android.hardware.radio.V1_5.CellIdentityLte();
+        initializeCellIdentityLte_1_5(halCellIdentity, true, false);
+
+        CellIdentityLte cellIdentity = RILUtils.convertHalCellIdentityLte(halCellIdentity);
+
+        Set<String> additionalPlmns = new HashSet<>();
+        Collections.addAll(additionalPlmns, ADDITIONAL_PLMNS);
+
+        assertEquals(cellIdentity.getAdditionalPlmns(), additionalPlmns);
+    }
+
+    private static void initializeCellIdentityWcdma_1_5(
+            android.hardware.radio.V1_5.CellIdentityWcdma id,
+            boolean addAdditionalPlmns, boolean addCsgInfo) {
+
+        initializeCellIdentityWcdma_1_2(id.base);
+
+        if (addAdditionalPlmns) {
+            id.additionalPlmns = new ArrayList<>(Arrays.asList(ADDITIONAL_PLMNS));
+        }
+
+        if (addCsgInfo) {
+            id.optionalCsgInfo.csgInfo(getHalCsgInfo());
+        }
+    }
+
+    @Test
+    public void testCellIdentityWcdma_1_5_CsgInfo() {
+        android.hardware.radio.V1_5.CellIdentityWcdma halCellIdentity =
+                new android.hardware.radio.V1_5.CellIdentityWcdma();
+        initializeCellIdentityWcdma_1_5(halCellIdentity, false, true);
+
+        CellIdentityWcdma cellIdentity = RILUtils.convertHalCellIdentityWcdma(halCellIdentity);
+
+        assertEquals(CSG_INDICATION,
+                cellIdentity.getClosedSubscriberGroupInfo().getCsgIndicator());
+        assertEquals(HOME_NODEB_NAME,
+                cellIdentity.getClosedSubscriberGroupInfo().getHomeNodebName());
+        assertEquals(CSG_IDENTITY,
+                cellIdentity.getClosedSubscriberGroupInfo().getCsgIdentity());
+    }
+
+    @Test
+    public void testCellIdentityWcdma_1_5_MultiPlmn() {
+        android.hardware.radio.V1_5.CellIdentityWcdma halCellIdentity =
+                new android.hardware.radio.V1_5.CellIdentityWcdma();
+        initializeCellIdentityWcdma_1_5(halCellIdentity, true, false);
+
+        CellIdentityWcdma cellIdentity = RILUtils.convertHalCellIdentityWcdma(halCellIdentity);
+
+        Set<String> additionalPlmns = new HashSet<>();
+        Collections.addAll(additionalPlmns, ADDITIONAL_PLMNS);
+
+        assertEquals(cellIdentity.getAdditionalPlmns(), additionalPlmns);
+    }
+
+    private static void initializeCellIdentityTdscdma_1_5(
+            android.hardware.radio.V1_5.CellIdentityTdscdma id,
+            boolean addAdditionalPlmns, boolean addCsgInfo) {
+
+        initializeCellIdentityTdscdma_1_2(id.base);
+
+        if (addAdditionalPlmns) {
+            id.additionalPlmns = new ArrayList<>(Arrays.asList(ADDITIONAL_PLMNS));
+        }
+
+        if (addCsgInfo) {
+            id.optionalCsgInfo.csgInfo(getHalCsgInfo());
+        }
+    }
+
+    @Test
+    public void testCellIdentityTdscdma_1_5_CsgInfo() {
+        android.hardware.radio.V1_5.CellIdentityTdscdma halCellIdentity =
+                new android.hardware.radio.V1_5.CellIdentityTdscdma();
+        initializeCellIdentityTdscdma_1_5(halCellIdentity, false, true);
+
+        CellIdentityTdscdma cellIdentity = RILUtils.convertHalCellIdentityTdscdma(halCellIdentity);
+
+        assertEquals(CSG_INDICATION,
+                cellIdentity.getClosedSubscriberGroupInfo().getCsgIndicator());
+        assertEquals(HOME_NODEB_NAME,
+                cellIdentity.getClosedSubscriberGroupInfo().getHomeNodebName());
+        assertEquals(CSG_IDENTITY,
+                cellIdentity.getClosedSubscriberGroupInfo().getCsgIdentity());
+    }
+
+    @Test
+    public void testCellIdentityTdscdma_1_5_MultiPlmn() {
+        android.hardware.radio.V1_5.CellIdentityTdscdma halCellIdentity =
+                new android.hardware.radio.V1_5.CellIdentityTdscdma();
+        initializeCellIdentityTdscdma_1_5(halCellIdentity, true, false);
+
+        CellIdentityTdscdma cellIdentity = RILUtils.convertHalCellIdentityTdscdma(halCellIdentity);
+
+        Set<String> additionalPlmns = new HashSet<>();
+        Collections.addAll(additionalPlmns, ADDITIONAL_PLMNS);
+
+        assertEquals(cellIdentity.getAdditionalPlmns(), additionalPlmns);
+    }
+
     @Test
     public void testConvertDataCallResult() {
+        // Test V1.0 SetupDataCallResult
+        android.hardware.radio.V1_0.SetupDataCallResult result10 =
+                new android.hardware.radio.V1_0.SetupDataCallResult();
+        result10.status = android.hardware.radio.V1_0.DataCallFailCause.NONE;
+        result10.suggestedRetryTime = -1;
+        result10.cid = 0;
+        result10.active = 2;
+        result10.type = "IPV4V6";
+        result10.ifname = "ifname";
+        result10.addresses = "10.0.2.15 2607:fb90:a620:651d:eabe:f8da:c107:44be/64";
+        result10.dnses = "10.0.2.3 fd00:976a::9";
+        result10.gateways = "10.0.2.15 fe80::2";
+        result10.pcscf = "fd00:976a:c206:20::6   fd00:976a:c206:20::9    fd00:976a:c202:1d::9";
+        result10.mtu = 1500;
+
         DataCallResponse response = new DataCallResponse.Builder()
                 .setCause(0)
                 .setRetryDurationMillis(-1L)
@@ -2356,6 +2297,8 @@ public class RILTest extends TelephonyTest {
                 .setTrafficDescriptors(new ArrayList<>())
                 .build();
 
+        assertEquals(response, RILUtils.convertHalDataCallResult(result10));
+
         // Test V1.4 SetupDataCallResult
         android.hardware.radio.V1_4.SetupDataCallResult result14 =
                 new android.hardware.radio.V1_4.SetupDataCallResult();
@@ -2592,7 +2535,11 @@ public class RILTest extends TelephonyTest {
         ArrayList<Object> records = new ArrayList<>();
 
         for (int i = 0; i < 5 /* arbitrary */; i++) {
-            android.hardware.radio.V1_4.CellInfo record = getCellInfo_1_4ForLte();
+            android.hardware.radio.V1_4.CellInfo record =
+                    new android.hardware.radio.V1_4.CellInfo();
+            record.info = new android.hardware.radio.V1_4.CellInfo.Info();
+            record.info.lte(new android.hardware.radio.V1_4.CellInfoLte());
+            initializeCellInfoLte_1_2(record.info.lte().base);
             record.info.lte().base.cellIdentityLte.base.ci += i; // make them marginally unique
 
             records.add(record);
@@ -2607,6 +2554,181 @@ public class RILTest extends TelephonyTest {
         }
     }
 
+    @Test
+    public void testCellInfoTimestamp_1_2() {
+        ArrayList<Object> records = new ArrayList<>();
+
+        for (int i = 0; i < 5 /* arbitrary */; i++) {
+            android.hardware.radio.V1_2.CellInfo record =
+                    new android.hardware.radio.V1_2.CellInfo();
+            record.cellInfoType = TYPE_LTE;
+            record.timeStamp = Long.MAX_VALUE;
+            record.registered = false;
+            record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
+            record.lte.add(new android.hardware.radio.V1_2.CellInfoLte());
+            initializeCellInfoLte_1_2(record.lte.get(0));
+            record.lte.get(0).cellIdentityLte.base.ci += i; // make them marginally unique
+
+            records.add(record);
+        }
+        List<CellInfo> cil = RILUtils.convertHalCellInfoList(records);
+
+        // Check that all timestamps are set to a valid number and are equal
+        final long ts = cil.get(0).getTimeStamp();
+        for (CellInfo ci : cil) {
+            assertTrue(ci.getTimeStamp() > 0 && ci.getTimeStamp() != Long.MAX_VALUE);
+            assertEquals(ci.getTimeStamp(), ts);
+        }
+    }
+
+    private static void initializeCellIdentityLte_1_2(
+            android.hardware.radio.V1_2.CellIdentityLte id) {
+        // 1.0 fields
+        id.base.mcc = MCC_STR;
+        id.base.mnc = MNC_STR;
+        id.base.ci = CI;
+        id.base.pci = PCI;
+        id.base.tac = TAC;
+        id.base.earfcn = EARFCN;
+
+        // 1.2 fields
+        id.bandwidth = BANDWIDTH;
+        id.operatorNames.alphaLong = ALPHA_LONG;
+        id.operatorNames.alphaShort = ALPHA_SHORT;
+    }
+
+    private static void initializeCellInfoLte_1_2(android.hardware.radio.V1_2.CellInfoLte lte) {
+        initializeCellIdentityLte_1_2(lte.cellIdentityLte);
+
+        lte.signalStrengthLte.signalStrength = RSSI_ASU;
+        lte.signalStrengthLte.rsrp = -RSRP;
+        lte.signalStrengthLte.rsrq = -RSRQ;
+        lte.signalStrengthLte.rssnr = RSSNR;
+        lte.signalStrengthLte.cqi = CQI;
+        lte.signalStrengthLte.timingAdvance = TIMING_ADVANCE;
+    }
+
+    private ArrayList<CellInfo> getCellInfoListForLTE(
+            String mcc, String mnc, String alphaLong, String alphaShort) {
+        android.hardware.radio.V1_2.CellInfoLte lte = new android.hardware.radio.V1_2.CellInfoLte();
+
+        initializeCellInfoLte_1_2(lte);
+        // Override the defaults for test-specific purposes
+        lte.cellIdentityLte.operatorNames.alphaLong = alphaLong;
+        lte.cellIdentityLte.operatorNames.alphaShort = alphaShort;
+        lte.cellIdentityLte.base.mcc = mcc;
+        lte.cellIdentityLte.base.mnc = mnc;
+
+        android.hardware.radio.V1_2.CellInfo record = new android.hardware.radio.V1_2.CellInfo();
+        record.cellInfoType = TYPE_LTE;
+        record.registered = false;
+        record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
+        record.timeStamp = TIMESTAMP;
+        record.lte.add(lte);
+        record.connectionStatus = 0;
+        ArrayList<Object> records = new ArrayList<>();
+        records.add(record);
+        return RILUtils.convertHalCellInfoList(records);
+    }
+
+    private ArrayList<CellInfo> getCellInfoListForGSM(
+            String mcc, String mnc, String alphaLong, String alphaShort) {
+        android.hardware.radio.V1_2.CellInfoGsm cellinfo =
+                new android.hardware.radio.V1_2.CellInfoGsm();
+        cellinfo.cellIdentityGsm.base.lac = LAC;
+        cellinfo.cellIdentityGsm.base.cid = CID;
+        cellinfo.cellIdentityGsm.base.bsic = BSIC;
+        cellinfo.cellIdentityGsm.base.arfcn = ARFCN;
+        cellinfo.cellIdentityGsm.base.mcc = mcc;
+        cellinfo.cellIdentityGsm.base.mnc = mnc;
+        cellinfo.cellIdentityGsm.operatorNames.alphaLong = alphaLong;
+        cellinfo.cellIdentityGsm.operatorNames.alphaShort = alphaShort;
+        cellinfo.signalStrengthGsm.signalStrength = RSSI_ASU;
+        cellinfo.signalStrengthGsm.bitErrorRate = BIT_ERROR_RATE;
+        cellinfo.signalStrengthGsm.timingAdvance = TIMING_ADVANCE;
+        android.hardware.radio.V1_2.CellInfo record = new android.hardware.radio.V1_2.CellInfo();
+        record.cellInfoType = TYPE_GSM;
+        record.registered = false;
+        record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
+        record.timeStamp = TIMESTAMP;
+        record.gsm.add(cellinfo);
+        record.connectionStatus = 0;
+        ArrayList<Object> records = new ArrayList<>();
+        records.add(record);
+
+        return RILUtils.convertHalCellInfoList(records);
+    }
+
+    private static void initializeCellIdentityWcdma_1_2(
+            android.hardware.radio.V1_2.CellIdentityWcdma cid) {
+        initializeCellIdentityWcdma_1_2(cid, MCC_STR, MNC_STR, ALPHA_LONG, ALPHA_SHORT);
+    }
+
+    private static void initializeCellIdentityWcdma_1_2(
+            android.hardware.radio.V1_2.CellIdentityWcdma cid,
+                String mcc, String mnc, String alphaLong, String alphaShort) {
+        cid.base.lac = LAC;
+        cid.base.cid = CID;
+        cid.base.psc = PSC;
+        cid.base.uarfcn = UARFCN;
+        cid.base.mcc = mcc;
+        cid.base.mnc = mnc;
+        cid.operatorNames.alphaLong = alphaLong;
+        cid.operatorNames.alphaShort = alphaShort;
+    }
+
+    private ArrayList<CellInfo> getCellInfoListForWcdma(
+            String mcc, String mnc, String alphaLong, String alphaShort) {
+        android.hardware.radio.V1_2.CellInfoWcdma cellinfo =
+                new android.hardware.radio.V1_2.CellInfoWcdma();
+        initializeCellIdentityWcdma_1_2(
+                cellinfo.cellIdentityWcdma, mcc, mnc, alphaLong, alphaShort);
+
+        cellinfo.signalStrengthWcdma.base.signalStrength = RSSI_ASU;
+        cellinfo.signalStrengthWcdma.base.bitErrorRate = BIT_ERROR_RATE;
+        cellinfo.signalStrengthWcdma.rscp = RSCP_ASU;
+        cellinfo.signalStrengthWcdma.ecno = ECNO_ASU;
+        android.hardware.radio.V1_2.CellInfo record = new android.hardware.radio.V1_2.CellInfo();
+        record.cellInfoType = TYPE_WCDMA;
+        record.registered = false;
+        record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
+        record.timeStamp = TIMESTAMP;
+        record.wcdma.add(cellinfo);
+        record.connectionStatus = 0;
+        ArrayList<Object> records = new ArrayList<>();
+        records.add(record);
+
+        return RILUtils.convertHalCellInfoList(records);
+    }
+
+    private ArrayList<CellInfo> getCellInfoListForCdma(String alphaLong, String alphaShort) {
+        android.hardware.radio.V1_2.CellInfoCdma cellinfo =
+                new android.hardware.radio.V1_2.CellInfoCdma();
+        cellinfo.cellIdentityCdma.base.networkId = NETWORK_ID;
+        cellinfo.cellIdentityCdma.base.systemId = SYSTEM_ID;
+        cellinfo.cellIdentityCdma.base.baseStationId = BASESTATION_ID;
+        cellinfo.cellIdentityCdma.base.longitude = LONGITUDE;
+        cellinfo.cellIdentityCdma.base.latitude = LATITUDE;
+        cellinfo.cellIdentityCdma.operatorNames.alphaLong = alphaLong;
+        cellinfo.cellIdentityCdma.operatorNames.alphaShort = alphaShort;
+        cellinfo.signalStrengthCdma.dbm = -DBM;
+        cellinfo.signalStrengthCdma.ecio = -ECIO;
+        cellinfo.signalStrengthEvdo.dbm = -DBM;
+        cellinfo.signalStrengthEvdo.ecio = -ECIO;
+        cellinfo.signalStrengthEvdo.signalNoiseRatio = SIGNAL_NOISE_RATIO;
+        android.hardware.radio.V1_2.CellInfo record = new android.hardware.radio.V1_2.CellInfo();
+        record.cellInfoType = TYPE_CDMA;
+        record.registered = false;
+        record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
+        record.timeStamp = TIMESTAMP;
+        record.cdma.add(cellinfo);
+        record.connectionStatus = 0;
+        ArrayList<Object> records = new ArrayList<>();
+        records.add(record);
+
+        return RILUtils.convertHalCellInfoList(records);
+    }
+
     @Test
     public void testSetupDataCall() throws Exception {
         ApnSetting apn = new ApnSetting.Builder()
@@ -2636,8 +2758,8 @@ public class RILTest extends TelephonyTest {
                 obtainMessage());
         ArgumentCaptor<DataProfile> dpiCaptor = ArgumentCaptor.forClass(DataProfile.class);
         verify(mDataProxy).setupDataCall(mSerialNumberCaptor.capture(),
-                eq(AccessNetworkConstants.AccessNetworkType.EUTRAN), dpiCaptor.capture(),
-                eq(false), anyInt(), any(), anyInt(), any(), any(), eq(true));
+                anyInt(), eq(AccessNetworkConstants.AccessNetworkType.EUTRAN), dpiCaptor.capture(),
+                eq(false), eq(false), anyInt(), any(), anyInt(), any(), any(), eq(true));
         verifyRILResponse(
                 mRILUnderTest, mSerialNumberCaptor.getValue(), RIL_REQUEST_SETUP_DATA_CALL);
         DataProfile dpi = dpiCaptor.getValue();
@@ -2655,6 +2777,46 @@ public class RILTest extends TelephonyTest {
         assertEquals(MTU, dpi.getMtu());
     }
 
+    @Test
+    public void testFixupSignalStrength10() {
+        final int gsmWcdmaRssiDbm = -65;
+
+        // Test the positive case where rat=UMTS and SignalStrength=GSM
+        doReturn(ServiceState.RIL_RADIO_TECHNOLOGY_UMTS)
+                .when(mServiceState).getRilVoiceRadioTechnology();
+
+        SignalStrength gsmSignalStrength = new SignalStrength(
+                new CellSignalStrengthCdma(),
+                new CellSignalStrengthGsm(gsmWcdmaRssiDbm, 1, CellInfo.UNAVAILABLE),
+                new CellSignalStrengthWcdma(), new CellSignalStrengthTdscdma(),
+                new CellSignalStrengthLte(), new CellSignalStrengthNr());
+        SignalStrength result = mRILUnderTest.fixupSignalStrength10(gsmSignalStrength);
+
+        assertTrue(result.getCellSignalStrengths(CellSignalStrengthGsm.class).isEmpty());
+        assertFalse(result.getCellSignalStrengths(CellSignalStrengthWcdma.class).isEmpty());
+
+        // Even though the dBm values are equal, the above checks ensure that the value has
+        // been migrated to WCDMA (with no change in the top-level getDbm() result).
+        assertEquals(result.getDbm(), gsmSignalStrength.getDbm());
+
+        // Test the no-op case where rat=GSM and SignalStrength=GSM
+        doReturn(ServiceState.RIL_RADIO_TECHNOLOGY_GSM)
+                .when(mServiceState).getRilVoiceRadioTechnology();
+        result = mRILUnderTest.fixupSignalStrength10(gsmSignalStrength);
+        assertEquals(result, gsmSignalStrength);
+
+        // Check that non-GSM non-WCDMA signal strengths are also passed through.
+        SignalStrength lteSignalStrength = new SignalStrength(
+                new CellSignalStrengthCdma(), new CellSignalStrengthGsm(),
+                new CellSignalStrengthWcdma(), new CellSignalStrengthTdscdma(),
+                new CellSignalStrengthLte(CellInfo.UNAVAILABLE,
+                        -120, -10, CellInfo.UNAVAILABLE, CellInfo.UNAVAILABLE,
+                        CellInfo.UNAVAILABLE), new CellSignalStrengthNr());
+        SignalStrength lteResult = mRILUnderTest.fixupSignalStrength10(lteSignalStrength);
+
+        assertEquals(lteResult, lteSignalStrength);
+    }
+
     @Test
     public void testCreateCarrierRestrictionList() {
         ArrayList<CarrierIdentifier> carriers = new ArrayList<>();
@@ -2698,7 +2860,7 @@ public class RILTest extends TelephonyTest {
 
         ArrayList<Carrier> result = RILUtils.convertToHalCarrierRestrictionList(carriers);
 
-        assertEquals(result, expected);
+        assertTrue(result.equals(expected));
     }
 
     @Test
@@ -2745,27 +2907,27 @@ public class RILTest extends TelephonyTest {
         verify(mSimProxy, never()).areUiccApplicationsEnabled(mSerialNumberCaptor.capture());
         // Sending message is handled by getRadioProxy when proxy is null.
         // areUiccApplicationsEnabled shouldn't explicitly send another callback.
-        assertNull(message.obj);
+        assertEquals(null, message.obj);
     }
 
     @Test
-    public void testSetGetCompatVersion() {
+    public void testSetGetCompatVersion() throws Exception {
         final int testRequest = RIL_REQUEST_GET_UICC_APPLICATIONS_ENABLEMENT;
 
         // getCompactVersion should return null before first setting
         assertNull(mRILUnderTest.getCompatVersion(testRequest));
 
         // first time setting any valid HalVersion will success
-        mRILUnderTest.setCompatVersion(testRequest, RIL.RADIO_HAL_VERSION_1_5);
-        assertEquals(RIL.RADIO_HAL_VERSION_1_5, mRILUnderTest.getCompatVersion(testRequest));
-
-        // try to set a lower HalVersion will success
         mRILUnderTest.setCompatVersion(testRequest, RIL.RADIO_HAL_VERSION_1_4);
         assertEquals(RIL.RADIO_HAL_VERSION_1_4, mRILUnderTest.getCompatVersion(testRequest));
 
+        // try to set a lower HalVersion will success
+        mRILUnderTest.setCompatVersion(testRequest, RIL.RADIO_HAL_VERSION_1_3);
+        assertEquals(RIL.RADIO_HAL_VERSION_1_3, mRILUnderTest.getCompatVersion(testRequest));
+
         // try to set a greater HalVersion will not success
-        mRILUnderTest.setCompatVersion(testRequest, RIL.RADIO_HAL_VERSION_1_6);
-        assertEquals(RIL.RADIO_HAL_VERSION_1_4, mRILUnderTest.getCompatVersion(testRequest));
+        mRILUnderTest.setCompatVersion(testRequest, RIL.RADIO_HAL_VERSION_1_5);
+        assertEquals(RIL.RADIO_HAL_VERSION_1_3, mRILUnderTest.getCompatVersion(testRequest));
     }
 
     @FlakyTest
@@ -2804,7 +2966,7 @@ public class RILTest extends TelephonyTest {
         Message message = obtainMessage();
         mRILUnderTest.getImei(message);
         AsyncResult ar = (AsyncResult) message.obj;
-        Assert.assertNull(ar.result);
+        Assert.assertEquals(null, ar.result);
         Assert.assertNotNull(ar.exception.getMessage());
         Assert.assertEquals("REQUEST_NOT_SUPPORTED", ar.exception.getMessage());
     }
@@ -2817,7 +2979,8 @@ public class RILTest extends TelephonyTest {
         Handler handler = new Handler(handlerThread.getLooper()) {
             public void handleMessage(Message msg) {
                 AsyncResult ar = (AsyncResult) msg.obj;
-                if (ar != null && ar.exception instanceof CommandException) {
+                if (ar != null && ar.exception != null
+                        && ar.exception instanceof CommandException) {
                     CommandException.Error err =
                             ((CommandException) (ar.exception)).getCommandError();
                     if (err == CommandException.Error.SYSTEM_ERR) {
@@ -2847,7 +3010,8 @@ public class RILTest extends TelephonyTest {
         Handler handler = new Handler(handlerThread.getLooper()) {
             public void handleMessage(Message msg) {
                 AsyncResult ar = (AsyncResult) msg.obj;
-                if (ar != null && ar.exception instanceof CommandException) {
+                if (ar != null && ar.exception != null
+                        && ar.exception instanceof CommandException) {
                     CommandException.Error err =
                             ((CommandException) (ar.exception)).getCommandError();
                     if (err == CommandException.Error.RADIO_NOT_AVAILABLE) {
diff --git a/tests/telephonytests/src/com/android/internal/telephony/SimulatedCommands.java b/tests/telephonytests/src/com/android/internal/telephony/SimulatedCommands.java
index e56b0a80a1..9f3483550e 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/SimulatedCommands.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/SimulatedCommands.java
@@ -18,10 +18,9 @@ package com.android.internal.telephony.test;
 
 import android.compat.annotation.UnsupportedAppUsage;
 import android.hardware.radio.RadioError;
-import android.hardware.radio.V1_2.VoiceRegStateResult;
-import android.hardware.radio.V1_4.DataRegStateResult;
-import android.hardware.radio.V1_4.PdpProtocolType;
-import android.hardware.radio.V1_4.SetupDataCallResult;
+import android.hardware.radio.V1_0.DataRegStateResult;
+import android.hardware.radio.V1_0.SetupDataCallResult;
+import android.hardware.radio.V1_0.VoiceRegStateResult;
 import android.hardware.radio.modem.ImeiInfo;
 import android.net.KeepalivePacketData;
 import android.net.LinkProperties;
@@ -593,7 +592,7 @@ public class SimulatedCommands extends BaseCommands
      */
     @Override
     public void getDataCallList(Message result) {
-        ArrayList<SetupDataCallResult> dcCallList = new ArrayList<>(0);
+        ArrayList<SetupDataCallResult> dcCallList = new ArrayList<SetupDataCallResult>(0);
         SimulatedCommandsVerifier.getInstance().getDataCallList(result);
         if (mSetupDataCallResult != null) {
             dcCallList.add(mSetupDataCallResult);
@@ -1060,10 +1059,10 @@ public class SimulatedCommands extends BaseCommands
         Object ret = mDataRegStateResult;
         if (ret == null) {
             ret = new DataRegStateResult();
-            ((DataRegStateResult) ret).base.regState = mDataRegState;
-            ((DataRegStateResult) ret).base.rat = mDataRadioTech;
-            ((DataRegStateResult) ret).base.maxDataCalls = mMaxDataCalls;
-            ((DataRegStateResult) ret).base.reasonDataDenied = mReasonForDenial;
+            ((DataRegStateResult) ret).regState = mDataRegState;
+            ((DataRegStateResult) ret).rat = mDataRadioTech;
+            ((DataRegStateResult) ret).maxDataCalls = mMaxDataCalls;
+            ((DataRegStateResult) ret).reasonDataDenied = mReasonForDenial;
         }
 
         resultSuccess(result, ret);
@@ -1224,17 +1223,17 @@ public class SimulatedCommands extends BaseCommands
         if (mSetupDataCallResult == null) {
             try {
                 mSetupDataCallResult = new SetupDataCallResult();
-                mSetupDataCallResult.cause = 0;
+                mSetupDataCallResult.status = 0;
                 mSetupDataCallResult.suggestedRetryTime = -1;
                 mSetupDataCallResult.cid = 1;
                 mSetupDataCallResult.active = 2;
-                mSetupDataCallResult.type = PdpProtocolType.IP;
+                mSetupDataCallResult.type = "IP";
                 mSetupDataCallResult.ifname = "rmnet_data7";
-                mSetupDataCallResult.addresses = new ArrayList<>(List.of("12.34.56.78"));
-                mSetupDataCallResult.dnses = new ArrayList<>(List.of("98.76.54.32"));
-                mSetupDataCallResult.gateways = new ArrayList<>(List.of("11.22.33.44"));
-                mSetupDataCallResult.pcscf = new ArrayList<>(List.of(
-                        "fd00:976a:c305:1d::8 fd00:976a:c202:1d::7 fd00:976a:c305:1d::5"));
+                mSetupDataCallResult.addresses = "12.34.56.78";
+                mSetupDataCallResult.dnses = "98.76.54.32";
+                mSetupDataCallResult.gateways = "11.22.33.44";
+                mSetupDataCallResult.pcscf =
+                        "fd00:976a:c305:1d::8 fd00:976a:c202:1d::7 fd00:976a:c305:1d::5";
                 mSetupDataCallResult.mtu = 1440;
             } catch (Exception e) {
                 Rlog.e(LOG_TAG, "setupDataCall: e=" + e);
-- 
2.34.1

