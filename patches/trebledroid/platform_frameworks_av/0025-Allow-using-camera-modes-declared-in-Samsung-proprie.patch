From f129bedb6eb9c46c591203670f4735df010576e1 Mon Sep 17 00:00:00 2001
From: Pierre-Hugues Husson <phh@phh.me>
Date: Sat, 10 Feb 2024 09:30:19 -0500
Subject: [PATCH 25/25] Allow using camera modes declared in Samsung
 proprietary values

---
 .../utils/SessionConfigurationUtils.cpp       | 79 +++++++++++++------
 1 file changed, 53 insertions(+), 26 deletions(-)

diff --git a/services/camera/libcameraservice/utils/SessionConfigurationUtils.cpp b/services/camera/libcameraservice/utils/SessionConfigurationUtils.cpp
index 89e75b3342d..bbf2f575929 100644
--- a/services/camera/libcameraservice/utils/SessionConfigurationUtils.cpp
+++ b/services/camera/libcameraservice/utils/SessionConfigurationUtils.cpp
@@ -166,35 +166,62 @@ bool roundBufferDimensionNearest(int32_t width, int32_t height,
 
     bool isJpegRDataSpace = (dataSpace == static_cast<android_dataspace_t>(
                 ::aidl::android::hardware::graphics::common::Dataspace::JPEG_R));
-    camera_metadata_ro_entry streamConfigs =
-            (isJpegRDataSpace) ? info.find(jpegRSizesTag) :
-            (dataSpace == HAL_DATASPACE_DEPTH) ? info.find(depthSizesTag) :
-            (dataSpace == static_cast<android_dataspace>(HAL_DATASPACE_HEIF)) ?
-            info.find(heicSizesTag) :
-            info.find(scalerSizesTag);
+    bool isDepth = dataSpace == HAL_DATASPACE_DEPTH;
+    bool isHeif = dataSpace == static_cast<android_dataspace>(HAL_DATASPACE_HEIF);
+    int32_t selectedTag = isJpegRDataSpace ? jpegRSizesTag :
+        isDepth ? depthSizesTag :
+        isHeif ? heicSizesTag : scalerSizesTag;
+
+    std::list<int32_t> tags = { selectedTag };
+    if (selectedTag == scalerSizesTag) {
+        sp<VendorTagDescriptor> vTags;
+        sp<VendorTagDescriptorCache> cache = VendorTagDescriptorCache::getGlobalVendorTagCache();
+        if (cache.get()) {
+            auto vendorId = const_cast<CameraMetadata*>(&info)->getVendorId(); // getVendorId is actually const...
+            cache->getVendorTagDescriptor(vendorId, &vTags);
+        }
+
+        std::list<std::string> vendorTags = {
+            "samsung.android.scaler.availablePictureStreamConfigurations",
+            "samsung.android.scaler.availablePreviewStreamConfigurations",
+            "samsung.android.scaler.availableThumbnailStreamConfigurations",
+        };
+        for(auto tagName: vendorTags) {
+            uint32_t vendorTag;
+            status_t tagStatus = info.getTagFromName(tagName.c_str(), vTags.get(), &vendorTag);
+            //ALOGE("Tag by name %s %d %x", tagName.c_str(), tagStatus, vendorTag);
+            if (tagStatus == OK)
+                tags.push_back(vendorTag);
+        }
+    }
 
     int32_t bestWidth = -1;
     int32_t bestHeight = -1;
-
-    // Iterate through listed stream configurations and find the one with the smallest euclidean
-    // distance from the given dimensions for the given format.
-    for (size_t i = 0; i < streamConfigs.count; i += 4) {
-        int32_t fmt = streamConfigs.data.i32[i];
-        int32_t w = streamConfigs.data.i32[i + 1];
-        int32_t h = streamConfigs.data.i32[i + 2];
-
-        // Ignore input/output type for now
-        if (fmt == format) {
-            if (w == width && h == height) {
-                bestWidth = width;
-                bestHeight = height;
-                break;
-            } else if (w <= ROUNDING_WIDTH_CAP && (bestWidth == -1 ||
-                    SessionConfigurationUtils::euclidDistSquare(w, h, width, height) <
-                    SessionConfigurationUtils::euclidDistSquare(bestWidth, bestHeight, width,
-                            height))) {
-                bestWidth = w;
-                bestHeight = h;
+    for(auto tag: tags) {
+        camera_metadata_ro_entry streamConfigs =
+            info.find(tag);
+
+
+        // Iterate through listed stream configurations and find the one with the smallest euclidean
+        // distance from the given dimensions for the given format.
+        for (size_t i = 0; i < streamConfigs.count; i += 4) {
+            int32_t fmt = streamConfigs.data.i32[i];
+            int32_t w = streamConfigs.data.i32[i + 1];
+            int32_t h = streamConfigs.data.i32[i + 2];
+
+            // Ignore input/output type for now
+            if (fmt == format) {
+                if (w == width && h == height) {
+                    bestWidth = width;
+                    bestHeight = height;
+                    break;
+                } else if (w <= ROUNDING_WIDTH_CAP && (bestWidth == -1 ||
+                        SessionConfigurationUtils::euclidDistSquare(w, h, width, height) <
+                        SessionConfigurationUtils::euclidDistSquare(bestWidth, bestHeight, width,
+                                height))) {
+                    bestWidth = w;
+                    bestHeight = h;
+                }
             }
         }
     }
-- 
2.34.1

