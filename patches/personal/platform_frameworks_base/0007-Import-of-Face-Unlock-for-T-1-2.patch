From 58eaa2850e30986b35b5fcd8afe0d494eb569427 Mon Sep 17 00:00:00 2001
From: jhenrique09 <jhsv09@gmail.com>
Date: Wed, 9 Feb 2022 22:16:43 -0300
Subject: [PATCH 7/7] Import of Face Unlock for T (1/2)

Change-Id: I0f8ab8ee816466e64f54dccd80de1a09e6c09d01
---
 core/java/android/provider/Settings.java      |   6 +
 core/res/res/values/config.xml                |  11 +
 core/res/res/values/strings.xml               |   6 +-
 core/res/res/values/symbols.xml               |   6 +
 .../validators/SecureSettingsValidators.java  |   1 +
 packages/SystemUI/Android.bp                  |   1 +
 .../SystemUI/res/values-pt-rBR/strings.xml    |   2 +-
 packages/SystemUI/res/values/strings.xml      |   3 +
 .../keyguard/KeyguardUpdateMonitor.java       |  92 +-
 .../privacy/AppOpsPrivacyItemMonitor.kt       |  10 +-
 .../KeyguardIndicationController.java         |  75 +-
 .../phone/BiometricUnlockController.java      |   2 +-
 .../statusbar/phone/KeyguardBouncer.java      |  12 +-
 .../phone/KeyguardBypassController.kt         |  36 +-
 .../phone/StatusBarKeyguardViewManager.java   |  54 +-
 .../systemui/wallet/ui/WalletActivity.java    |   4 +-
 services/core/Android.bp                      |   1 +
 .../server/biometrics/AuthSession.java        |   5 +
 .../server/biometrics/BiometricService.java   |  20 +-
 .../server/biometrics/PreAuthInfo.java        |   5 +
 .../sensors/BiometricScheduler.java           |  17 +-
 .../biometrics/sensors/face/FaceService.java  |   9 +
 .../sensors/face/custom/ArrayUtils.java       |  65 ++
 .../face/custom/BiometricTestSessionImpl.java | 165 ++++
 .../face/custom/CustomFaceProvider.java       | 848 ++++++++++++++++++
 .../face/custom/FaceAuthenticationClient.java | 141 +++
 .../sensors/face/custom/FaceEnrollClient.java | 101 +++
 .../custom/FaceGenerateChallengeClient.java   |  94 ++
 .../face/custom/FaceGetFeatureClient.java     |  88 ++
 .../custom/FaceInternalCleanupClient.java     |  49 +
 .../custom/FaceInternalEnumerateClient.java   |  50 ++
 .../face/custom/FaceRemovalClient.java        |  53 ++
 .../face/custom/FaceResetLockoutClient.java   |  71 ++
 .../custom/FaceRevokeChallengeClient.java     |  48 +
 .../face/custom/FaceSetFeatureClient.java     |  80 ++
 .../custom/FaceUpdateActiveUserClient.java    |  76 ++
 .../sensors/face/custom/TestHal.java          | 128 +++
 .../biometrics/sensors/face/hidl/Face10.java  |   2 +-
 .../fingerprint/hidl/Fingerprint21.java       |   2 +-
 .../hidl/Fingerprint21UdfpsMock.java          |   6 +-
 .../policy/PermissionPolicyService.java       |   8 +
 41 files changed, 2391 insertions(+), 62 deletions(-)
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/ArrayUtils.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/BiometricTestSessionImpl.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/CustomFaceProvider.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/FaceAuthenticationClient.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/FaceEnrollClient.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/FaceGenerateChallengeClient.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/FaceGetFeatureClient.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/FaceInternalCleanupClient.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/FaceInternalEnumerateClient.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/FaceRemovalClient.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/FaceResetLockoutClient.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/FaceRevokeChallengeClient.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/FaceSetFeatureClient.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/FaceUpdateActiveUserClient.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/TestHal.java

diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index c9fd1295a6e1..131291c898e9 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -10983,6 +10983,12 @@ public final class Settings {
         public static final String EXTRA_AUTOMATIC_POWER_SAVE_MODE =
                 "extra_automatic_power_save_mode";

+        /**
+         * Face Unlock Method
+         * @hide
+         */
+        public static final String FACE_UNLOCK_METHOD = "face_unlock_method";
+
         /**
          * These entries are considered common between the personal and the managed profile,
          * since the managed profile doesn't get to change them.
diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 0330de797d98..7de97254673b 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -5934,4 +5934,15 @@
          TODO(b/236022708) Move rear display state to device state config file
     -->
     <integer name="config_deviceStateRearDisplay">-1</integer>
+
+    <!-- Array containing custom error messages from vendor. -->
+    <string-array name="face_error_vendor" translatable="false">
+        <item>@string/face_unlock_disabled_idle</item>
+    </string-array>
+
+    <!-- Enable face auth only when swiping security view -->
+    <bool name="config_faceAuthOnlyOnSecurityView">false</bool>
+
+    <!-- Whether to cancel fingerprint operation if not idle -->
+    <bool name="config_fpCancelIfNotIdle">false</bool>
 </resources>
diff --git a/core/res/res/values/strings.xml b/core/res/res/values/strings.xml
index 8ffdbdd6f15b..27baac6b592a 100644
--- a/core/res/res/values/strings.xml
+++ b/core/res/res/values/strings.xml
@@ -1906,9 +1906,6 @@
     <!-- Subtitle shown on the system-provided biometric dialog, asking the user to authenticate with their face or screen lock credential (i.e. PIN, pattern, or password). [CHAR LIMIT=90] -->
     <string name="face_or_screen_lock_dialog_default_subtitle">Use your face or screen lock to continue</string>
 
-    <!-- Array containing custom error messages from vendor.  Vendor is expected to add and translate these strings -->
-    <string-array name="face_error_vendor">
-    </string-array>
     <!-- Default error message to use when face_error_vendor does not contain a message. [CHAR LIMIT=NONE] -->
     <string name="face_error_vendor_unknown">Something went wrong. Try again.</string>
 
@@ -6355,4 +6352,7 @@ ul.</string>
 
     <!-- Title for preference of the system default locale. [CHAR LIMIT=50]-->
     <string name="system_locale_title">System default</string>
+
+    <!-- Face unlock -->
+    <string name="face_unlock_disabled_idle">Face unlock disabled due to inactivity</string>
 </resources>
diff --git a/core/res/res/values/symbols.xml b/core/res/res/values/symbols.xml
index 6e574bd788a9..953944b00081 100644
--- a/core/res/res/values/symbols.xml
+++ b/core/res/res/values/symbols.xml
@@ -4854,4 +4854,10 @@
   <java-symbol type="dimen" name="status_bar_height_default" />
 
   <java-symbol type="bool" name="system_server_plays_face_haptics" />
+
+  <!-- Enable face auth only when swiping security view -->
+  <java-symbol type="bool" name="config_faceAuthOnlyOnSecurityView" />
+
+  <!-- Whether to cancel fingerprint operation if not idle -->
+  <java-symbol type="bool" name="config_fpCancelIfNotIdle" />
 </resources>
diff --git a/packages/SettingsProvider/src/android/provider/settings/validators/SecureSettingsValidators.java b/packages/SettingsProvider/src/android/provider/settings/validators/SecureSettingsValidators.java
index a39735ffe2c7..4684451066bd 100644
--- a/packages/SettingsProvider/src/android/provider/settings/validators/SecureSettingsValidators.java
+++ b/packages/SettingsProvider/src/android/provider/settings/validators/SecureSettingsValidators.java
@@ -347,5 +347,6 @@ public class SecureSettingsValidators {
         VALIDATORS.put(Secure.BLUETOOTH_LE_BROADCAST_PROGRAM_INFO, ANY_STRING_VALIDATOR);
         VALIDATORS.put(Secure.BLUETOOTH_LE_BROADCAST_CODE, ANY_STRING_VALIDATOR);
         VALIDATORS.put(Secure.BLUETOOTH_LE_BROADCAST_APP_SOURCE_NAME, ANY_STRING_VALIDATOR);
+        VALIDATORS.put(Secure.FACE_UNLOCK_METHOD, BOOLEAN_VALIDATOR);
     }
 }
diff --git a/packages/SystemUI/Android.bp b/packages/SystemUI/Android.bp
index 740127888c4b..01b71ff2bfad 100644
--- a/packages/SystemUI/Android.bp
+++ b/packages/SystemUI/Android.bp
@@ -126,6 +126,7 @@ android_library {
         "lottie",
         "LowLightDreamLib",
         "vendor.goodix.hardware.biometrics.fingerprint-V2.1-java",
+        "faceunlock_framework",
     ],
     manifest: "AndroidManifest.xml",
 
diff --git a/packages/SystemUI/res/values-pt-rBR/strings.xml b/packages/SystemUI/res/values-pt-rBR/strings.xml
index f85ab52b11b4..e64bc5ca8dbd 100644
--- a/packages/SystemUI/res/values-pt-rBR/strings.xml
+++ b/packages/SystemUI/res/values-pt-rBR/strings.xml
@@ -158,7 +158,7 @@
     <string name="biometric_dialog_last_password_attempt_before_wipe_profile" msgid="8538032972389729253">"Se você informar uma senha incorreta na próxima tentativa, seu perfil de trabalho e os dados dele serão excluídos."</string>
     <string name="fingerprint_dialog_touch_sensor" msgid="2817887108047658975">"Toque no sensor de impressão digital"</string>
     <string name="accessibility_fingerprint_dialog_fingerprint_icon" msgid="4465698996175640549">"Ícone de impressão digital"</string>
-    <string name="fingerprint_dialog_use_fingerprint_instead" msgid="6178228876763024452">"Não foi possível reconhecer o rosto Use a impressão digital."</string>
+    <string name="fingerprint_dialog_use_fingerprint_instead" msgid="6178228876763024452">"Não foi possível reconhecer o rosto, use a impressão digital."</string>
     <!-- no translation found for keyguard_face_failed_use_fp (7140293906176164263) -->
     <skip />
     <string name="keyguard_face_failed" msgid="9044619102286917151">"Rosto não reconhecido"</string>
diff --git a/packages/SystemUI/res/values/strings.xml b/packages/SystemUI/res/values/strings.xml
index 53f1227383b7..646c882d7832 100644
--- a/packages/SystemUI/res/values/strings.xml
+++ b/packages/SystemUI/res/values/strings.xml
@@ -2607,4 +2607,7 @@
 
     <!-- Time format for the Dream Time Complication for 24-hour time format [CHAR LIMIT=NONE] -->
     <string name="dream_time_complication_24_hr_time_format">kk:mm</string>
+
+    <!-- Face Unlock -->
+    <string name="face_unlock_recognizing">Recognizing face...</string>
 </resources>
diff --git a/packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java b/packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java
index 6eef3b33cf8f..bdc3d34741b7 100644
--- a/packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java
+++ b/packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java
@@ -81,6 +81,7 @@ import android.app.trust.TrustManager;
 import android.content.BroadcastReceiver;
 import android.content.ComponentName;
 import android.content.Context;
+import android.content.ContentResolver;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.pm.IPackageManager;
@@ -449,6 +450,13 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
 
     private static int sCurrentUser;
 
+    SettingsObserver mSettingsObserver;
+
+    private final boolean mFaceAuthOnlyOnSecurityView;
+    public static final int FACE_UNLOCK_BEHAVIOR_DEFAULT = 0;
+    public static final int FACE_UNLOCK_BEHAVIOR_SWIPE = 1;
+    private int mFaceUnlockBehavior = FACE_UNLOCK_BEHAVIOR_DEFAULT;
+
     public synchronized static void setCurrentUser(int currentUser) {
         sCurrentUser = currentUser;
     }
@@ -828,6 +836,9 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
 
     private void handleFingerprintAuthenticated(int authUserId, boolean isStrongBiometric) {
         Trace.beginSection("KeyGuardUpdateMonitor#handlerFingerPrintAuthenticated");
+        if (mOccludingAppRequestingFace){
+            requestFaceAuthOnOccludingApp(false);
+        }
         if (mHandler.hasCallbacks(mFpCancelNotReceived)) {
             mLogger.d("handleFingerprintAuthenticated()"
                     + " triggered while waiting for cancellation, removing watchdog");
@@ -1052,6 +1063,9 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
 
     private void handleFaceAuthenticated(int authUserId, boolean isStrongBiometric) {
         Trace.beginSection("KeyGuardUpdateMonitor#handlerFaceAuthenticated");
+        if (mOccludingAppRequestingFace){
+            requestFaceAuthOnOccludingApp(false);
+        }
         try {
             if (mGoingToSleep) {
                 mLogger.d("Aborted successful auth because device is going to sleep.");
@@ -1235,9 +1249,9 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
         final DevicePolicyManager dpm =
                 (DevicePolicyManager) mContext.getSystemService(Context.DEVICE_POLICY_SERVICE);
         // TODO(b/140035044)
-        return whitelistIpcs(() -> dpm != null && (dpm.getKeyguardDisabledFeatures(null, userId)
+        return dpm != null && (dpm.getKeyguardDisabledFeatures(null, userId)
                 & DevicePolicyManager.KEYGUARD_DISABLE_FACE) != 0
-                || isSimPinSecure());
+                || isSimPinSecure();
     }
 
     /**
@@ -1919,6 +1933,8 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
         mTelephonyListenerManager = telephonyListenerManager;
         mDeviceProvisioned = isDeviceProvisionedInSettingsDb();
         mStrongAuthTracker = new StrongAuthTracker(context, this::notifyStrongAuthStateChanged);
+        mFaceAuthOnlyOnSecurityView = mContext.getResources().getBoolean(
+                com.android.internal.R.bool.config_faceAuthOnlyOnSecurityView);
         mBackgroundExecutor = backgroundExecutor;
         mBroadcastDispatcher = broadcastDispatcher;
         mInteractionJankMonitor = interactionJankMonitor;
@@ -2191,6 +2207,8 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
         mContext.getContentResolver().registerContentObserver(
                 Settings.System.getUriFor(Settings.System.TIME_12_24),
                 false, mTimeFormatChangeObserver, UserHandle.USER_ALL);
+        mSettingsObserver = new SettingsObserver(mHandler);
+        mSettingsObserver.observe();
     }
 
     private void updateFaceEnrolled(int userId) {
@@ -2638,7 +2656,7 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
 
         // Only listen if this KeyguardUpdateMonitor belongs to the primary user. There is an
         // instance of KeyguardUpdateMonitor for each user but KeyguardUpdateMonitor is user-aware.
-        final boolean shouldListen =
+        boolean shouldListen =
                 (mBouncerFullyShown && !mGoingToSleep
                         || mAuthInterruptActive
                         || mOccludingAppRequestingFace
@@ -2653,6 +2671,10 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
                 && !faceAuthenticated
                 && !fpOrFaceIsLockedOut;
 
+        if (shouldListen && mFaceUnlockBehavior == FACE_UNLOCK_BEHAVIOR_SWIPE && !mBouncerFullyShown){
+            shouldListen = false;
+        }
+
         // Aggregate relevant fields for debug logging.
         maybeLogListenerModelData(
                 new KeyguardFaceListenModel(
@@ -2681,6 +2703,10 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
         return shouldListen;
     }
 
+    public int getFaceUnlockBehavior() {
+        return mFaceUnlockBehavior;
+    }
+
     private void maybeLogListenerModelData(KeyguardListenModel model) {
         mLogger.logKeyguardListenerModel(model);
 
@@ -2810,7 +2836,7 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
         return mIsUnlockWithFingerprintPossible.getOrDefault(userId, false);
     }
 
-    private boolean isUnlockWithFacePossible(int userId) {
+    public boolean isUnlockWithFacePossible(int userId) {
         return isFaceAuthEnabledForUser(userId) && !isFaceDisabled(userId);
     }
 
@@ -3160,6 +3186,7 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
         Assert.isMainThread();
         mLogger.logKeyguardVisibilityChanged(showing);
         mKeyguardIsVisible = showing;
+        mBouncerFullyShown = false;
 
         if (showing) {
             mSecureCameraLaunched = false;
@@ -3182,6 +3209,7 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
         mLogger.d("handleKeyguardReset");
         updateBiometricListeningState(BIOMETRIC_ACTION_UPDATE,
                 FACE_AUTH_UPDATED_KEYGUARD_RESET);
+        mBouncerFullyShown = false;
         mNeedsSlowUnlockTransition = resolveNeedsSlowUnlockTransition();
     }
 
@@ -3252,6 +3280,15 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
         }
     }
 
+    public void updateFaceListeningStateForBehavior(boolean fullyShow) {
+        if (mBouncerFullyShown != fullyShow){
+            mBouncerFullyShown = fullyShow;
+            if (mFaceUnlockBehavior == FACE_UNLOCK_BEHAVIOR_SWIPE){
+                updateFaceListeningState(BIOMETRIC_ACTION_UPDATE, FACE_AUTH_UPDATED_ON_FACE_AUTHENTICATED);
+            }
+        }
+    }
+
     /**
      * Handle {@link #MSG_REQUIRE_NFC_UNLOCK}
      */
@@ -3282,6 +3319,7 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
      * Handle {@link #MSG_REPORT_EMERGENCY_CALL_ACTION}
      */
     private void handleReportEmergencyCallAction() {
+        mBouncerFullyShown = false;
         Assert.isMainThread();
         for (int i = 0; i < mCallbacks.size(); i++) {
             KeyguardUpdateMonitorCallback cb = mCallbacks.get(i).get();
@@ -3676,6 +3714,48 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
         return BIOMETRIC_LOCKOUT_RESET_DELAY_MS;
     }
 
+    class SettingsObserver extends ContentObserver {
+        private ContentResolver mContentResolver;
+        SettingsObserver(Handler handler) {
+            super(handler);
+        }
+
+        void observe() {
+            mContentResolver = mContext.getContentResolver();
+            mContentResolver.registerContentObserver(Settings.Secure.getUriFor(
+                    Settings.Secure.FACE_UNLOCK_METHOD), false, this,
+                    UserHandle.USER_ALL);
+            updateSettings();
+        }
+
+        void unobserve(){
+            if (mContentResolver != null){
+                mContentResolver.unregisterContentObserver(this);
+            }
+        }
+
+        @Override
+        public void onChange(boolean selfChange) {
+            updateSettings();
+        }
+    }
+
+    private void updateSettings() {
+        ContentResolver resolver = mContext.getContentResolver();
+        updateFaceUnlockBehavior();
+    }
+
+    private void updateFaceUnlockBehavior() {
+        ContentResolver resolver = mContext.getContentResolver();
+        if (mFaceAuthOnlyOnSecurityView){
+            mFaceUnlockBehavior = FACE_UNLOCK_BEHAVIOR_SWIPE;
+        }else{
+            mFaceUnlockBehavior = Settings.Secure.getIntForUser(resolver,
+                Settings.Secure.FACE_UNLOCK_METHOD, FACE_UNLOCK_BEHAVIOR_DEFAULT,
+                UserHandle.USER_CURRENT);
+        }
+    }
+
     /**
      * Unregister all listeners.
      */
@@ -3697,6 +3777,10 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
             mContext.getContentResolver().unregisterContentObserver(mTimeFormatChangeObserver);
         }
 
+        if (mSettingsObserver != null) {
+            mSettingsObserver.unobserve();
+        }
+
         try {
             ActivityManager.getService().unregisterUserSwitchObserver(mUserSwitchObserver);
         } catch (RemoteException e) {
diff --git a/packages/SystemUI/src/com/android/systemui/privacy/AppOpsPrivacyItemMonitor.kt b/packages/SystemUI/src/com/android/systemui/privacy/AppOpsPrivacyItemMonitor.kt
index de34cd6b23ca..5b7f832afbaa 100644
--- a/packages/SystemUI/src/com/android/systemui/privacy/AppOpsPrivacyItemMonitor.kt
+++ b/packages/SystemUI/src/com/android/systemui/privacy/AppOpsPrivacyItemMonitor.kt
@@ -53,6 +53,9 @@ class AppOpsPrivacyItemMonitor @Inject constructor(
 
     @VisibleForTesting
     companion object {
+        val CAMERA_WHITELIST_PKG = arrayOf(
+            "org.pixelexperience.faceunlock",
+        )
         val OPS_MIC_CAMERA = intArrayOf(AppOpsManager.OP_CAMERA,
                 AppOpsManager.OP_PHONE_CALL_CAMERA, AppOpsManager.OP_RECORD_AUDIO,
                 AppOpsManager.OP_PHONE_CALL_MICROPHONE,
@@ -85,7 +88,8 @@ class AppOpsPrivacyItemMonitor @Inject constructor(
         ) {
             synchronized(lock) {
                 // Check if we care about this code right now
-                if (code in OPS_MIC_CAMERA && !micCameraAvailable) {
+                if (code in OPS_MIC_CAMERA && !micCameraAvailable
+                        || packageName in CAMERA_WHITELIST_PKG) {
                     return
                 }
                 if (code in OPS_LOCATION && !locationAvailable) {
@@ -213,6 +217,10 @@ class AppOpsPrivacyItemMonitor @Inject constructor(
             AppOpsManager.OP_RECORD_AUDIO -> PrivacyType.TYPE_MICROPHONE
             else -> return null
         }
+        if (type == PrivacyType.TYPE_CAMERA && !micCameraAvailable
+                || appOpItem.packageName in CAMERA_WHITELIST_PKG) {
+            return null
+        }
         val app = PrivacyApplication(appOpItem.packageName, appOpItem.uid)
         return PrivacyItem(type, app, appOpItem.timeStartedElapsed, appOpItem.isDisabled)
     }
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/KeyguardIndicationController.java b/packages/SystemUI/src/com/android/systemui/statusbar/KeyguardIndicationController.java
index 073ab8b16864..3dc26fe78a4e 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/KeyguardIndicationController.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/KeyguardIndicationController.java
@@ -40,6 +40,7 @@ import static com.android.systemui.keyguard.KeyguardIndicationRotateTextViewCont
 import static com.android.systemui.keyguard.KeyguardIndicationRotateTextViewController.INDICATION_TYPE_USER_LOCKED;
 import static com.android.systemui.keyguard.ScreenLifecycle.SCREEN_ON;
 import static com.android.systemui.plugins.FalsingManager.LOW_PENALTY;
+import static com.android.keyguard.KeyguardUpdateMonitor.FACE_UNLOCK_BEHAVIOR_SWIPE;
 
 import android.app.admin.DevicePolicyManager;
 import android.content.BroadcastReceiver;
@@ -129,6 +130,8 @@ public class KeyguardIndicationController {
     private static final int MSG_SHOW_ACTION_TO_UNLOCK = 2;
     private static final int MSG_HIDE_BIOMETRIC_MESSAGE = 3;
     private static final int MSG_RESET_ERROR_MESSAGE_ON_SCREEN_ON = 4;
+    private static final int MSG_SHOW_RECOGNIZING_FACE = 5;
+    private static final int MSG_HIDE_RECOGNIZING_FACE = 6;
     private static final long TRANSIENT_BIOMETRIC_ERROR_TIMEOUT = 1300;
     public static final long DEFAULT_HIDE_DELAY_MS =
             3500 + KeyguardIndicationTextView.Y_IN_DURATION;
@@ -184,6 +187,7 @@ public class KeyguardIndicationController {
     private final Set<Integer> mCoExFaceAcquisitionMsgIdsToShow;
     private final FaceHelpMessageDeferral mFaceAcquiredMessageDeferral;
     private boolean mInited;
+    private boolean mFaceDetectionRunning;
 
     private KeyguardUpdateMonitorCallback mUpdateMonitorCallback;
 
@@ -208,6 +212,15 @@ public class KeyguardIndicationController {
                 mBiometricErrorMessageToShowOnScreenOn = null;
             }
         }
+
+        @Override
+        public void onScreenTurnedOff() {
+            if (mFaceDetectionRunning) {
+                mFaceDetectionRunning = false;
+                mBiometricErrorMessageToShowOnScreenOn = null;
+                hideFaceUnlockRecognizingMessage();
+            }
+        }
     };
 
     /**
@@ -273,6 +286,11 @@ public class KeyguardIndicationController {
                     hideBiometricMessage();
                 } else if (msg.what == MSG_RESET_ERROR_MESSAGE_ON_SCREEN_ON) {
                     mBiometricErrorMessageToShowOnScreenOn = null;
+                } else if (msg.what == MSG_SHOW_RECOGNIZING_FACE){
+                    mBiometricErrorMessageToShowOnScreenOn = null;
+                    showFaceUnlockRecognizingMessage();
+                } else if (msg.what == MSG_HIDE_RECOGNIZING_FACE){
+                    hideFaceUnlockRecognizingMessage();
                 }
             }
         };
@@ -792,6 +810,47 @@ public class KeyguardIndicationController {
         }
     }
 
+    private void showFaceUnlockRecognizingMessage() {
+        if (mKeyguardUpdateMonitor.getFaceUnlockBehavior() == FACE_UNLOCK_BEHAVIOR_SWIPE){
+            return;
+        }
+
+        String faceUnlockMessage = mContext.getResources().getString(
+                                    R.string.face_unlock_recognizing);
+        mBiometricMessage = faceUnlockMessage;
+
+        mHandler.removeMessages(MSG_SHOW_ACTION_TO_UNLOCK);
+        mHandler.removeMessages(MSG_HIDE_BIOMETRIC_MESSAGE);
+
+        mRotateTextViewController.updateIndication(
+                INDICATION_TYPE_BIOMETRIC_MESSAGE,
+                new KeyguardIndication.Builder()
+                        .setMessage(mBiometricMessage)
+                        .setMinVisibilityMillis(6000L) // 6 seconds
+                        .setTextColor(mInitialTextColorState)
+                        .build(),
+                true
+        );
+
+        if (mDozing) {
+            updateDeviceEntryIndication(false);
+        }
+    }
+
+    private void hideFaceUnlockRecognizingMessage() {
+        if (mKeyguardUpdateMonitor.getFaceUnlockBehavior() == FACE_UNLOCK_BEHAVIOR_SWIPE){
+            return;
+        }
+
+        String faceUnlockMessage = mContext.getResources().getString(
+            R.string.face_unlock_recognizing);
+        if (mBiometricMessage != null && mBiometricMessage == faceUnlockMessage) {
+            mBiometricMessage = null;
+            mHandler.removeMessages(MSG_HIDE_BIOMETRIC_MESSAGE);
+            updateBiometricMessage();
+        }
+    }
+
     /**
      * Hides transient indication.
      */
@@ -1237,11 +1296,17 @@ public class KeyguardIndicationController {
         @Override
         public void onBiometricRunningStateChanged(boolean running,
                 BiometricSourceType biometricSourceType) {
-            if (running && biometricSourceType == FACE) {
-                // Let's hide any previous messages when authentication starts, otherwise
-                // multiple auth attempts would overlap.
-                hideBiometricMessage();
-                mBiometricErrorMessageToShowOnScreenOn = null;
+            if (biometricSourceType == BiometricSourceType.FACE) {
+                mFaceDetectionRunning = running;
+                if (running) {
+                    mHandler.removeMessages(MSG_HIDE_RECOGNIZING_FACE);
+                    mHandler.removeMessages(MSG_SHOW_RECOGNIZING_FACE);
+                    mHandler.sendEmptyMessageDelayed(MSG_SHOW_RECOGNIZING_FACE, 100);
+                }else{
+                    mHandler.removeMessages(MSG_SHOW_RECOGNIZING_FACE);
+                    mHandler.removeMessages(MSG_HIDE_RECOGNIZING_FACE);
+                    mHandler.sendEmptyMessageDelayed(MSG_HIDE_RECOGNIZING_FACE, 100);
+                }
             }
         }
 
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/BiometricUnlockController.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/BiometricUnlockController.java
index fe431377f854..0415ad9d3786 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/BiometricUnlockController.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/BiometricUnlockController.java
@@ -585,7 +585,7 @@ public class BiometricUnlockController extends KeyguardUpdateMonitorCallback imp
         boolean unlockingAllowed =
                 mUpdateMonitor.isUnlockingWithBiometricAllowed(isStrongBiometric);
         boolean deviceDreaming = mUpdateMonitor.isDreaming();
-        boolean bypass = mKeyguardBypassController.getBypassEnabled()
+        boolean bypass = mKeyguardBypassController.getBypassEnabledBiometric()
                 || mAuthController.isUdfpsFingerDown();
         if (!mUpdateMonitor.isDeviceInteractive()) {
             if (!mKeyguardViewController.isShowing()) {
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBouncer.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBouncer.java
index d61c51e76e86..6129eba1c69e 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBouncer.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBouncer.java
@@ -218,17 +218,7 @@ public class KeyguardBouncer {
 
             // Split up the work over multiple frames.
             DejankUtils.removeCallbacks(mResetRunnable);
-            if (mKeyguardStateController.isFaceAuthEnabled()
-                    && !mKeyguardUpdateMonitor.getCachedIsUnlockWithFingerprintPossible(
-                            KeyguardUpdateMonitor.getCurrentUser())
-                    && !needsFullscreenBouncer()
-                    && !mKeyguardUpdateMonitor.isFaceLockedOut()
-                    && !mKeyguardUpdateMonitor.userNeedsStrongAuth()
-                    && !mKeyguardBypassController.getBypassEnabled()) {
-                mHandler.postDelayed(mShowRunnable, BOUNCER_FACE_DELAY);
-            } else {
-                DejankUtils.postAfterTraversal(mShowRunnable);
-            }
+            DejankUtils.postAfterTraversal(mShowRunnable);
 
             mKeyguardStateController.notifyBouncerShowing(true /* showing */);
             dispatchStartingToShow();
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBypassController.kt b/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBypassController.kt
index b987f6815000..cc6cd1b59ce4 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBypassController.kt
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBypassController.kt
@@ -92,6 +92,10 @@ open class KeyguardBypassController : Dumpable, StackScrollAlgorithm.BypassContr
             notifyListeners()
         }
 
+    var bypassEnabledBiometric: Boolean = false
+
+    var faceUnlockMethod: Int = 0
+
     var bouncerShowing: Boolean = false
     var altBouncerShowing: Boolean = false
     var launchingAffordance: Boolean = false
@@ -132,13 +136,24 @@ open class KeyguardBypassController : Dumpable, StackScrollAlgorithm.BypassContr
             }
         })
 
-        val dismissByDefault = if (context.resources.getBoolean(
-                        com.android.internal.R.bool.config_faceAuthDismissesKeyguard)) 1 else 0
-        tunerService.addTunable(object : TunerService.Tunable {
-            override fun onTuningChanged(key: String?, newValue: String?) {
-                bypassEnabled = tunerService.getValue(key, dismissByDefault) != 0
-            }
-        }, Settings.Secure.FACE_UNLOCK_DISMISSES_KEYGUARD)
+        if (context.resources.getBoolean(
+                com.android.internal.R.bool.config_faceAuthOnlyOnSecurityView)){
+            bypassEnabledBiometric = false
+        }else{
+            tunerService.addTunable(object : TunerService.Tunable {
+                override fun onTuningChanged(key: String?, newValue: String?) {
+                    faceUnlockMethod = tunerService.getValue(key, 0)
+                }
+            }, Settings.Secure.FACE_UNLOCK_METHOD)
+            val dismissByDefault = if (context.resources.getBoolean(
+                            com.android.internal.R.bool.config_faceAuthDismissesKeyguard)) 1 else 0
+            tunerService.addTunable(object : TunerService.Tunable {
+                override fun onTuningChanged(key: String?, newValue: String?) {
+                    bypassEnabledBiometric = (faceUnlockMethod == 0 &&
+                        tunerService.getValue(key, dismissByDefault) != 0)
+                }
+            }, Settings.Secure.FACE_UNLOCK_DISMISSES_KEYGUARD)
+        }
         lockscreenUserManager.addUserChangedListener(
                 object : NotificationLockscreenUserManager.UserChangedListener {
                     override fun onUserChanged(userId: Int) {
@@ -158,8 +173,8 @@ open class KeyguardBypassController : Dumpable, StackScrollAlgorithm.BypassContr
         biometricSourceType: BiometricSourceType,
         isStrongBiometric: Boolean
     ): Boolean {
-        if (biometricSourceType == BiometricSourceType.FACE && bypassEnabled) {
-            val can = canBypass()
+        if (bypassEnabledBiometric) {
+            val can = biometricSourceType != BiometricSourceType.FACE || canBypass()
             if (!can && (isPulseExpanding || qSExpanded)) {
                 pendingUnlock = PendingUnlock(biometricSourceType, isStrongBiometric)
             }
@@ -183,7 +198,7 @@ open class KeyguardBypassController : Dumpable, StackScrollAlgorithm.BypassContr
      * If keyguard can be dismissed because of bypass.
      */
     fun canBypass(): Boolean {
-        if (bypassEnabled) {
+        if (bypassEnabledBiometric) {
             return when {
                 bouncerShowing -> true
                 altBouncerShowing -> true
@@ -209,6 +224,7 @@ open class KeyguardBypassController : Dumpable, StackScrollAlgorithm.BypassContr
             pw.println("  mPendingUnlock: $pendingUnlock")
         }
         pw.println("  bypassEnabled: $bypassEnabled")
+        pw.println("  bypassEnabledBiometric: $bypassEnabledBiometric")
         pw.println("  canBypass: ${canBypass()}")
         pw.println("  bouncerShowing: $bouncerShowing")
         pw.println("  altBouncerShowing: $altBouncerShowing")
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java
index ec7b8204b864..c26c341111fb 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java
@@ -29,6 +29,7 @@ import android.content.Context;
 import android.content.res.ColorStateList;
 import android.hardware.biometrics.BiometricSourceType;
 import android.os.Bundle;
+import android.os.Handler;
 import android.os.SystemClock;
 import android.os.Trace;
 import android.view.KeyEvent;
@@ -52,6 +53,7 @@ import com.android.keyguard.KeyguardUpdateMonitorCallback;
 import com.android.keyguard.KeyguardViewController;
 import com.android.keyguard.ViewMediatorCallback;
 import com.android.systemui.dagger.SysUISingleton;
+import com.android.systemui.dagger.qualifiers.Main;
 import com.android.systemui.dock.DockManager;
 import com.android.systemui.dreams.DreamOverlayStateController;
 import com.android.systemui.flags.FeatureFlags;
@@ -81,6 +83,7 @@ import com.android.systemui.statusbar.policy.ConfigurationController;
 import com.android.systemui.statusbar.policy.KeyguardStateController;
 import com.android.systemui.unfold.FoldAodAnimationController;
 import com.android.systemui.unfold.SysUIUnfoldComponent;
+import com.android.systemui.R;
 
 import java.io.PrintWriter;
 import java.util.ArrayList;
@@ -135,6 +138,7 @@ public class StatusBarKeyguardViewManager implements RemoteInputController.Callb
     private final BouncerViewDelegate mBouncerViewDelegate;
     private final Lazy<com.android.systemui.shade.ShadeController> mShadeController;
 
+    private boolean mBouncerVisible = false;
     private final BouncerExpansionCallback mExpansionCallback = new BouncerExpansionCallback() {
         private boolean mBouncerAnimating;
 
@@ -142,6 +146,7 @@ public class StatusBarKeyguardViewManager implements RemoteInputController.Callb
         public void onFullyShown() {
             mBouncerAnimating = false;
             updateStates();
+            showFaceRecognizingMessage();
         }
 
         @Override
@@ -178,6 +183,7 @@ public class StatusBarKeyguardViewManager implements RemoteInputController.Callb
                     .setBouncerShowingOverDream(
                             isVisible && mDreamOverlayStateController.isOverlayActive());
 
+            mBouncerVisible = isVisible;
             if (!isVisible) {
                 mCentralSurfaces.setBouncerHiddenFraction(KeyguardBouncer.EXPANSION_HIDDEN);
             }
@@ -252,6 +258,10 @@ public class StatusBarKeyguardViewManager implements RemoteInputController.Callb
     private KeyguardBypassController mBypassController;
     @Nullable private AlternateAuthInterceptor mAlternateAuthInterceptor;
 
+    private Handler mHandler;
+    private Handler mFaceRecognizingHandler;
+    private boolean mFaceRecognitionRunning = false;
+
     private final KeyguardUpdateMonitorCallback mUpdateMonitorCallback =
             new KeyguardUpdateMonitorCallback() {
         @Override
@@ -263,6 +273,28 @@ public class StatusBarKeyguardViewManager implements RemoteInputController.Callb
                 reset(true /* hideBouncerWhenShowing */);
             }
         }
+
+        @Override
+        public void onBiometricRunningStateChanged(boolean running,
+                BiometricSourceType biometricSourceType) {
+            if (biometricSourceType == BiometricSourceType.FACE &&
+                    mKeyguardUpdateManager.isUnlockWithFacePossible(mKeyguardUpdateManager.getCurrentUser())){
+                mFaceRecognitionRunning = running;
+                if (!mFaceRecognitionRunning){
+                    mFaceRecognizingHandler.removeCallbacksAndMessages(null);
+                }else{
+                    mFaceRecognizingHandler.postDelayed(() -> showFaceRecognizingMessage(), 100);
+                }
+            }
+        }
+
+        @Override
+        public void onBiometricAuthenticated(int userId, BiometricSourceType biometricSourceType,
+                boolean isStrongBiometric) {
+            if (biometricSourceType == BiometricSourceType.FACE) {
+                hideFaceRecognizingMessage();
+            }
+        }
     };
 
     @Inject
@@ -288,7 +320,9 @@ public class StatusBarKeyguardViewManager implements RemoteInputController.Callb
             FeatureFlags featureFlags,
             BouncerCallbackInteractor bouncerCallbackInteractor,
             BouncerInteractor bouncerInteractor,
-            BouncerView bouncerView) {
+            BouncerView bouncerView,
+            @Main Handler handler,
+            @Main Handler faceRecognizingHandler) {
         mContext = context;
         mViewMediatorCallback = callback;
         mLockPatternUtils = lockPatternUtils;
@@ -312,6 +346,8 @@ public class StatusBarKeyguardViewManager implements RemoteInputController.Callb
         mFoldAodAnimationController = sysUIUnfoldComponent
                 .map(SysUIUnfoldComponent::getFoldAodAnimationController).orElse(null);
         mIsModernBouncerEnabled = featureFlags.isEnabled(Flags.MODERN_BOUNCER);
+        mHandler = handler;
+        mFaceRecognizingHandler = faceRecognizingHandler;
     }
 
     @Override
@@ -637,6 +673,11 @@ public class StatusBarKeyguardViewManager implements RemoteInputController.Callb
             }
         }
         updateStates();
+        mHandler.postDelayed(() -> {
+            if (mBouncerVisible) {
+                mKeyguardUpdateManager.updateFaceListeningStateForBehavior(mBouncerVisible);
+            }
+        }, 100);
     }
 
     private boolean isWakeAndUnlocking() {
@@ -1301,6 +1342,17 @@ public class StatusBarKeyguardViewManager implements RemoteInputController.Callb
         }
     }
 
+    private void showFaceRecognizingMessage(){
+        if (mFaceRecognitionRunning &&
+                mKeyguardUpdateManager.isUnlockWithFacePossible(mKeyguardUpdateManager.getCurrentUser())) {
+            setKeyguardMessage(mContext.getString(R.string.face_unlock_recognizing), null);
+        }
+    }
+
+    private void hideFaceRecognizingMessage(){
+        setKeyguardMessage("", null);
+    }
+
     /** Display security message to relevant KeyguardMessageArea. */
     public void setKeyguardMessage(String message, ColorStateList colorState) {
         if (isShowingAlternateAuth()) {
diff --git a/packages/SystemUI/src/com/android/systemui/wallet/ui/WalletActivity.java b/packages/SystemUI/src/com/android/systemui/wallet/ui/WalletActivity.java
index d03148cee335..83def7645c13 100644
--- a/packages/SystemUI/src/com/android/systemui/wallet/ui/WalletActivity.java
+++ b/packages/SystemUI/src/com/android/systemui/wallet/ui/WalletActivity.java
@@ -209,14 +209,14 @@ public class WalletActivity extends ComponentActivity implements
                 true,
                 Utils.getColorAttrDefaultColor(
                         this, com.android.internal.R.attr.colorAccentPrimary));
-        mKeyguardViewManager.requestFace(true);
+        //mKeyguardViewManager.requestFace(true);
     }
 
     @Override
     protected void onPause() {
         super.onPause();
         mKeyguardViewManager.requestFp(false, -1);
-        mKeyguardViewManager.requestFace(false);
+        //mKeyguardViewManager.requestFace(false);
     }
 
     @Override
diff --git a/services/core/Android.bp b/services/core/Android.bp
index 604e1be0f03f..33456b2467ba 100644
--- a/services/core/Android.bp
+++ b/services/core/Android.bp
@@ -179,6 +179,7 @@ java_library_static {
         "vendor.samsung.hardware.biometrics.fingerprint-V3.0-java",
         "vendor.oplus.hardware.biometrics.fingerprint-V2.1-java",
         "vendor.oppo.hardware.biometrics.fingerprint-V2.1-java",
+        "faceunlock_framework",
     ],
     javac_shard_size: 50,
 }
diff --git a/services/core/java/com/android/server/biometrics/AuthSession.java b/services/core/java/com/android/server/biometrics/AuthSession.java
index 41ca13f5d5f5..2af0af945d3c 100644
--- a/services/core/java/com/android/server/biometrics/AuthSession.java
+++ b/services/core/java/com/android/server/biometrics/AuthSession.java
@@ -70,6 +70,8 @@ import java.util.List;
 import java.util.Random;
 import java.util.function.Function;
 
+import com.android.internal.util.custom.faceunlock.FaceUnlockUtils;
+
 /**
  * Class that defines the states of an authentication session invoked via
  * {@link android.hardware.biometrics.BiometricPrompt}, as well as all of the necessary
@@ -331,6 +333,9 @@ public final class AuthSession implements IBinder.DeathRecipient {
     }
 
     private boolean isConfirmationRequired(BiometricSensor sensor) {
+        if (sensor.modality == TYPE_FACE && FaceUnlockUtils.isFaceUnlockSupported()) {
+            return true;
+        }
         return sensor.confirmationSupported()
                 && (sensor.confirmationAlwaysRequired(mUserId)
                 || mPreAuthInfo.confirmationRequested);
diff --git a/services/core/java/com/android/server/biometrics/BiometricService.java b/services/core/java/com/android/server/biometrics/BiometricService.java
index 4767969bd3ed..4805d97c34cd 100644
--- a/services/core/java/com/android/server/biometrics/BiometricService.java
+++ b/services/core/java/com/android/server/biometrics/BiometricService.java
@@ -85,6 +85,8 @@ import java.util.Set;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.function.Supplier;
 
+import com.android.internal.util.custom.faceunlock.FaceUnlockUtils;
+
 /**
  * System service that arbitrates the modality for BiometricPrompt to use.
  */
@@ -214,10 +216,6 @@ public class BiometricService extends SystemService {
         private static final boolean DEFAULT_APP_ENABLED = true;
         private static final boolean DEFAULT_ALWAYS_REQUIRE_CONFIRMATION = false;
 
-        // Some devices that shipped before S already have face-specific settings. Instead of
-        // migrating, which is complicated, let's just keep using the existing settings.
-        private final boolean mUseLegacyFaceOnlySettings;
-
         // Only used for legacy face-only devices
         private final Uri FACE_UNLOCK_KEYGUARD_ENABLED =
                 Settings.Secure.getUriFor(Settings.Secure.FACE_UNLOCK_KEYGUARD_ENABLED);
@@ -257,18 +255,13 @@ public class BiometricService extends SystemService {
             final boolean hasFace = context.getPackageManager()
                     .hasSystemFeature(PackageManager.FEATURE_FACE);
 
-            // Use the legacy setting on face-only devices that shipped on or before Q
-            mUseLegacyFaceOnlySettings =
-                    Build.VERSION.DEVICE_INITIAL_SDK_INT <= Build.VERSION_CODES.Q
-                    && hasFace && !hasFingerprint;
-
             updateContentObserver();
         }
 
         public void updateContentObserver() {
             mContentResolver.unregisterContentObserver(this);
 
-            if (mUseLegacyFaceOnlySettings) {
+            if (FaceUnlockUtils.isFaceUnlockSupported()) {
                 mContentResolver.registerContentObserver(FACE_UNLOCK_KEYGUARD_ENABLED,
                         false /* notifyForDescendants */,
                         this /* observer */,
@@ -338,7 +331,7 @@ public class BiometricService extends SystemService {
 
         public boolean getEnabledOnKeyguard(int userId) {
             if (!mBiometricEnabledOnKeyguard.containsKey(userId)) {
-                if (mUseLegacyFaceOnlySettings) {
+                if (FaceUnlockUtils.isFaceUnlockSupported()) {
                     onChange(true /* selfChange */, FACE_UNLOCK_KEYGUARD_ENABLED, userId);
                 } else {
                     onChange(true /* selfChange */, BIOMETRIC_KEYGUARD_ENABLED, userId);
@@ -349,7 +342,7 @@ public class BiometricService extends SystemService {
 
         public boolean getEnabledForApps(int userId) {
             if (!mBiometricEnabledForApps.containsKey(userId)) {
-                if (mUseLegacyFaceOnlySettings) {
+                if (FaceUnlockUtils.isFaceUnlockSupported()) {
                     onChange(true /* selfChange */, FACE_UNLOCK_APP_ENABLED, userId);
                 } else {
                     onChange(true /* selfChange */, BIOMETRIC_APP_ENABLED, userId);
@@ -1323,9 +1316,6 @@ public class BiometricService extends SystemService {
     }
 
     private void dumpInternal(PrintWriter pw) {
-        pw.println("Legacy Settings: " + mSettingObserver.mUseLegacyFaceOnlySettings);
-        pw.println();
-
         pw.println("Sensors:");
         for (BiometricSensor sensor : mSensors) {
             pw.println(" " + sensor);
diff --git a/services/core/java/com/android/server/biometrics/PreAuthInfo.java b/services/core/java/com/android/server/biometrics/PreAuthInfo.java
index aec98f0ea426..b694746b69b7 100644
--- a/services/core/java/com/android/server/biometrics/PreAuthInfo.java
+++ b/services/core/java/com/android/server/biometrics/PreAuthInfo.java
@@ -42,6 +42,8 @@ import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
 import java.util.List;
 
+import com.android.internal.util.custom.faceunlock.FaceUnlockUtils;
+
 /**
  * Class representing the calling client's request. Additionally, derives/calculates
  * preliminary info that would be useful in helping serve this request. Note that generating
@@ -227,6 +229,9 @@ class PreAuthInfo {
 
     private static boolean isEnabledForApp(BiometricService.SettingObserver settingObserver,
             @BiometricAuthenticator.Modality int modality, int userId) {
+        if (modality == TYPE_FINGERPRINT && FaceUnlockUtils.isFaceUnlockSupported()){
+            return true;
+        }
         return settingObserver.getEnabledForApps(userId);
     }
 
diff --git a/services/core/java/com/android/server/biometrics/sensors/BiometricScheduler.java b/services/core/java/com/android/server/biometrics/sensors/BiometricScheduler.java
index 63609f77dc75..eca8937489ce 100644
--- a/services/core/java/com/android/server/biometrics/sensors/BiometricScheduler.java
+++ b/services/core/java/com/android/server/biometrics/sensors/BiometricScheduler.java
@@ -60,6 +60,9 @@ import java.util.function.Consumer;
 public class BiometricScheduler {
 
     private static final String BASE_TAG = "BiometricScheduler";
+
+    private boolean mCancel;
+
     // Number of recent operations to keep in our logs for dumpsys
     protected static final int LOG_NUM_RECENT_OPERATIONS = 50;
 
@@ -238,13 +241,16 @@ public class BiometricScheduler {
      * @param gestureAvailabilityDispatcher may be null if the sensor does not support gestures
      *                                      (such as fingerprint swipe).
      */
-    public BiometricScheduler(@NonNull String tag,
+    public BiometricScheduler(Context context, @NonNull String tag,
             @SensorType int sensorType,
             @Nullable GestureAvailabilityDispatcher gestureAvailabilityDispatcher) {
         this(tag, new Handler(Looper.getMainLooper()), sensorType, gestureAvailabilityDispatcher,
                 IBiometricService.Stub.asInterface(
                         ServiceManager.getService(Context.BIOMETRIC_SERVICE)),
                 LOG_NUM_RECENT_OPERATIONS, CoexCoordinator.getInstance());
+
+        mCancel = context.getResources().getBoolean(
+                com.android.internal.R.bool.config_fpCancelIfNotIdle);
     }
 
     @VisibleForTesting
@@ -258,8 +264,13 @@ public class BiometricScheduler {
 
     protected void startNextOperationIfIdle() {
         if (mCurrentOperation != null) {
-            Slog.v(getTag(), "Not idle, current operation: " + mCurrentOperation);
-            return;
+            if(mCancel) {
+               Slog.v(getTag(), "Not idle, cancelling current operation: " + mCurrentOperation);
+	       mCurrentOperation.cancel(mHandler, mInternalCallback);
+            } else {
+               Slog.v(getTag(), "Not idle, current operation: " + mCurrentOperation);
+               return;
+            }
         }
         if (mPendingOperations.isEmpty()) {
             Slog.d(getTag(), "No operations, returning to idle");
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/FaceService.java b/services/core/java/com/android/server/biometrics/sensors/face/FaceService.java
index 2e820574b435..ccbd10c8e8e3 100644
--- a/services/core/java/com/android/server/biometrics/sensors/face/FaceService.java
+++ b/services/core/java/com/android/server/biometrics/sensors/face/FaceService.java
@@ -25,6 +25,7 @@ import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.content.Context;
 import android.hardware.biometrics.BiometricManager;
+import android.hardware.biometrics.SensorProperties;
 import android.hardware.biometrics.BiometricsProtoEnums;
 import android.hardware.biometrics.IBiometricSensorReceiver;
 import android.hardware.biometrics.IBiometricService;
@@ -62,6 +63,7 @@ import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
 import com.android.server.biometrics.sensors.LockoutResetDispatcher;
 import com.android.server.biometrics.sensors.LockoutTracker;
 import com.android.server.biometrics.sensors.face.aidl.FaceProvider;
+import com.android.server.biometrics.sensors.face.custom.CustomFaceProvider;
 import com.android.server.biometrics.sensors.face.hidl.Face10;
 
 import java.io.FileDescriptor;
@@ -654,6 +656,12 @@ public class FaceService extends SystemService {
             }
         }
 
+        private void addCustomProviders() {
+            if (CustomFaceProvider.useCustomFaceUnlockService()) {
+                mServiceProviders.add(new CustomFaceProvider(getContext(), new FaceSensorPropertiesInternal(CustomFaceProvider.DEVICE_ID, SensorProperties.STRENGTH_WEAK, 1, new ArrayList(), 1, false, false, false), mLockoutResetDispatcher));
+            }
+        }
+
         @Override // Binder call
         public void registerAuthenticators(
                 @NonNull List<FaceSensorPropertiesInternal> hidlSensors) {
@@ -671,6 +679,7 @@ public class FaceService extends SystemService {
             handler.post(() -> {
                 addHidlProviders(hidlSensors);
                 addAidlProviders();
+                addCustomProviders();
 
                 final IBiometricService biometricService = IBiometricService.Stub.asInterface(
                         ServiceManager.getService(Context.BIOMETRIC_SERVICE));
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/ArrayUtils.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/ArrayUtils.java
new file mode 100644
index 000000000000..617781c0a08f
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/ArrayUtils.java
@@ -0,0 +1,65 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import java.util.ArrayList;
+
+public class ArrayUtils {
+    public static ArrayList<Byte> toByteArrayList(byte[] in) {
+        if (in == null) {
+            return null;
+        }
+        ArrayList<Byte> out = new ArrayList<>(in.length);
+        for (byte c : in) {
+            out.add(c);
+        }
+        return out;
+    }
+
+    public static ArrayList<Integer> toIntArrayList(int[] in) {
+        if (in == null) {
+            return null;
+        }
+        ArrayList<Integer> out = new ArrayList<>(in.length);
+        for (int c : in) {
+            out.add(c);
+        }
+        return out;
+    }
+
+    public static int[] toIntArray(ArrayList<Integer> in) {
+        if (in == null) {
+            return null;
+        }
+        int[] out = new int[in.size()];
+        for (int i = 0; i < in.size(); i++) {
+            out[i] = in.get(i);
+        }
+        return out;
+    }
+
+    public static byte[] toByteArray(ArrayList<Byte> in) {
+        if (in == null) {
+            return null;
+        }
+        byte[] out = new byte[in.size()];
+        for (int i = 0; i < in.size(); i++) {
+            out[i] = in.get(i);
+        }
+        return out;
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/BiometricTestSessionImpl.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/BiometricTestSessionImpl.java
new file mode 100644
index 000000000000..83e772b0e20b
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/BiometricTestSessionImpl.java
@@ -0,0 +1,165 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.hardware.biometrics.ITestSession;
+import android.hardware.biometrics.ITestSessionCallback;
+import android.hardware.face.Face;
+import android.hardware.face.FaceAuthenticationFrame;
+import android.hardware.face.FaceEnrollFrame;
+import android.hardware.face.IFaceServiceReceiver;
+import android.os.Binder;
+import android.os.RemoteException;
+import android.util.Slog;
+
+import com.android.server.biometrics.Utils;
+import com.android.server.biometrics.sensors.BaseClientMonitor;
+import com.android.server.biometrics.sensors.ClientMonitorCallback;
+import com.android.server.biometrics.sensors.face.FaceUtils;
+
+import java.util.List;
+import java.util.Random;
+
+public class BiometricTestSessionImpl extends ITestSession.Stub {
+    private static final String TAG = "BiometricTestSessionImpl";
+    private final ITestSessionCallback mCallback;
+    private final Context mContext;
+    private final CustomFaceProvider.HalResultController mHalResultController;
+    private final CustomFaceProvider mCustomFaceProvider;
+    private final int mSensorId;
+    private final IFaceServiceReceiver mReceiver = new IFaceServiceReceiver.Stub() {
+        @Override
+        public void onEnrollResult(Face face, int remaining) {
+        }
+
+        @Override
+        public void onAcquired(int acquiredInfo, int vendorCode) {
+        }
+
+        @Override
+        public void onAuthenticationSucceeded(Face face, int userId, boolean isStrongBiometric) {
+        }
+
+        @Override
+        public void onFaceDetected(int sensorId, int userId, boolean isStrongBiometric) {
+        }
+
+        @Override
+        public void onAuthenticationFailed() {
+        }
+
+        @Override
+        public void onError(int error, int vendorCode) {
+        }
+
+        @Override
+        public void onRemoved(Face face, int remaining) {
+        }
+
+        @Override
+        public void onFeatureSet(boolean success, int feature) {
+        }
+
+        @Override
+        public void onFeatureGet(boolean success, int[] features, boolean[] featureState) {
+        }
+
+        public void onChallengeGenerated(int sensorId, int userId, long challenge) {
+        }
+
+        @Override
+        public void onAuthenticationFrame(FaceAuthenticationFrame frame) {
+        }
+
+        @Override
+        public void onEnrollmentFrame(FaceEnrollFrame frame) {
+        }
+    };
+    private final Random mRandom = new Random();
+
+    public BiometricTestSessionImpl(Context context, int sensorId, ITestSessionCallback callback, CustomFaceProvider customFaceProvider, CustomFaceProvider.HalResultController halResultController) {
+        mContext = context;
+        mSensorId = sensorId;
+        mCallback = callback;
+        mCustomFaceProvider = customFaceProvider;
+        mHalResultController = halResultController;
+    }
+
+    public void setTestHalEnabled(boolean enabled) {
+        Utils.checkPermission(mContext, "android.permission.TEST_BIOMETRIC");
+        mCustomFaceProvider.setTestHalEnabled(enabled);
+    }
+
+    public void startEnroll(int userId) {
+        Utils.checkPermission(mContext, "android.permission.TEST_BIOMETRIC");
+        mCustomFaceProvider.scheduleEnroll(mSensorId, new Binder(), new byte[69], userId, mReceiver, mContext.getOpPackageName(), new int[0], null, false);
+    }
+
+    public void finishEnroll(int userId) {
+        Utils.checkPermission(mContext, "android.permission.TEST_BIOMETRIC");
+        mHalResultController.onEnrollResult(1, userId, 0);
+    }
+
+    public void acceptAuthentication(int userId) {
+        Utils.checkPermission(mContext, "android.permission.TEST_BIOMETRIC");
+        List<Face> faces = FaceUtils.getLegacyInstance(mSensorId).getBiometricsForUser(mContext, userId);
+        if (faces.isEmpty()) {
+            Slog.w(TAG, "No faces, returning");
+        } else {
+            mHalResultController.onAuthenticated(faces.get(0).getBiometricId(), userId, new byte[]{0});
+        }
+    }
+
+    public void rejectAuthentication(int userId) {
+        Utils.checkPermission(mContext, "android.permission.TEST_BIOMETRIC");
+        mHalResultController.onAuthenticated(0, userId, null);
+    }
+
+    public void notifyAcquired(int userId, int acquireInfo) {
+        Utils.checkPermission(mContext, "android.permission.TEST_BIOMETRIC");
+        mHalResultController.onAcquired(userId, acquireInfo, 0);
+    }
+
+    public void notifyError(int userId, int errorCode) {
+        Utils.checkPermission(mContext, "android.permission.TEST_BIOMETRIC");
+        mHalResultController.onError(errorCode, 0);
+    }
+
+    public void cleanupInternalState(int userId) {
+        Utils.checkPermission(mContext, "android.permission.TEST_BIOMETRIC");
+        mCustomFaceProvider.scheduleInternalCleanup(mSensorId, userId, new ClientMonitorCallback() {
+            @Override
+            public void onClientStarted(BaseClientMonitor clientMonitor) {
+                try {
+                    mCallback.onCleanupStarted(clientMonitor.getTargetUserId());
+                } catch (RemoteException e) {
+                    Slog.e(BiometricTestSessionImpl.TAG, "Remote exception", e);
+                }
+            }
+
+            @Override
+            public void onClientFinished(BaseClientMonitor clientMonitor, boolean success) {
+                try {
+                    mCallback.onCleanupFinished(clientMonitor.getTargetUserId());
+                } catch (RemoteException e) {
+                    Slog.e(BiometricTestSessionImpl.TAG, "Remote exception", e);
+                }
+            }
+        });
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/CustomFaceProvider.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/CustomFaceProvider.java
new file mode 100644
index 000000000000..0b0119970c06
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/CustomFaceProvider.java
@@ -0,0 +1,848 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.app.ActivityManager;
+import android.app.SynchronousUserSwitchObserver;
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.ServiceConnection;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.content.pm.UserInfo;
+import android.hardware.biometrics.BiometricsProtoEnums;
+import android.hardware.biometrics.IInvalidationCallback;
+import android.hardware.biometrics.ITestSession;
+import android.hardware.biometrics.ITestSessionCallback;
+import android.hardware.face.Face;
+import android.hardware.face.FaceSensorPropertiesInternal;
+import android.hardware.face.IFaceServiceReceiver;
+import android.os.Binder;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Looper;
+import android.os.RemoteException;
+import android.os.UserHandle;
+import android.os.UserManager;
+import android.provider.Settings;
+import android.util.Slog;
+import android.util.SparseArray;
+import android.util.proto.ProtoOutputStream;
+import android.view.Surface;
+
+import android.annotation.NonNull;
+
+import com.android.internal.util.custom.faceunlock.FaceUnlockUtils;
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.SensorServiceStateProto;
+import com.android.server.biometrics.SensorStateProto;
+import com.android.server.biometrics.UserStateProto;
+import com.android.server.biometrics.Utils;
+import com.android.server.biometrics.log.BiometricContext;
+import com.android.server.biometrics.log.BiometricLogger;
+import com.android.server.biometrics.sensors.AcquisitionClient;
+import com.android.server.biometrics.sensors.AuthenticationConsumer;
+import com.android.server.biometrics.sensors.BaseClientMonitor;
+import com.android.server.biometrics.sensors.ClientMonitorCallback;
+import com.android.server.biometrics.sensors.BiometricNotificationUtils;
+import com.android.server.biometrics.sensors.BiometricScheduler;
+import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
+import com.android.server.biometrics.sensors.EnumerateConsumer;
+import com.android.server.biometrics.sensors.ErrorConsumer;
+import com.android.server.biometrics.sensors.LockoutResetDispatcher;
+import com.android.server.biometrics.sensors.PerformanceTracker;
+import com.android.server.biometrics.sensors.RemovalConsumer;
+import com.android.server.biometrics.sensors.face.FaceUtils;
+import com.android.server.biometrics.sensors.face.LockoutHalImpl;
+import com.android.server.biometrics.sensors.face.ServiceProvider;
+import com.android.server.biometrics.sensors.face.UsageStats;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.FileDescriptor;
+import java.io.PrintWriter;
+import java.time.Clock;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.function.Supplier;
+
+public class CustomFaceProvider implements ServiceProvider {
+    public static final int DEVICE_ID = 1008;
+    private static final int ENROLL_TIMEOUT_SEC = 75;
+    private static final int GENERATE_CHALLENGE_COUNTER_TTL_MILLIS = 600000;
+    private static final int GENERATE_CHALLENGE_REUSE_INTERVAL_MILLIS = 60000;
+    private static final String TAG = CustomFaceProvider.class.getSimpleName();
+    public static Clock sSystemClock = Clock.systemUTC();
+    final SparseArray<IFaceService> mFaceServices;
+    private final Map<Integer, Long> mAuthenticatorIds;
+    private final Context mContext;
+    private final List<Long> mGeneratedChallengeCount;
+    private final HalResultController mHalResultController;
+    private final Handler mHandler;
+    private final Supplier<IFaceService> mLazyDaemon;
+    private final LockoutHalImpl mLockoutTracker;
+    private final BiometricScheduler mScheduler;
+    private final int mSensorId;
+    private final FaceSensorPropertiesInternal mSensorProperties;
+    private final UsageStats mUsageStats;
+    @NonNull
+    private final AtomicLong mRequestCounter = new AtomicLong(0);
+    private int mCurrentUserId;
+    private FaceGenerateChallengeClient mGeneratedChallengeCache;
+    private boolean mIsServiceBinding;
+    private TestHal mTestHal;
+    private boolean mTestHalEnabled;
+
+    private BiometricContext mBiometricContext;
+
+    CustomFaceProvider(Context context, FaceSensorPropertiesInternal sensorProps, LockoutResetDispatcher lockoutResetDispatcher, BiometricScheduler scheduler) {
+        mBiometricContext = BiometricContext.getInstance(context);
+        mTestHalEnabled = false;
+        mCurrentUserId = -10000;
+        mGeneratedChallengeCount = new ArrayList<>();
+        mGeneratedChallengeCache = null;
+        mFaceServices = new SparseArray<>();
+        mIsServiceBinding = false;
+        mSensorProperties = sensorProps;
+        mContext = context;
+        mSensorId = sensorProps.sensorId;
+        mScheduler = scheduler;
+        Handler handler = new Handler(Looper.getMainLooper());
+        mHandler = handler;
+        mUsageStats = new UsageStats(context);
+        mAuthenticatorIds = new HashMap<>();
+        mLazyDaemon = CustomFaceProvider.this::getDaemon;
+        LockoutHalImpl lockoutHalImpl = new LockoutHalImpl();
+        mLockoutTracker = lockoutHalImpl;
+        HalResultController halResultController = new HalResultController(sensorProps.sensorId, context, handler, scheduler, lockoutHalImpl, lockoutResetDispatcher);
+        mHalResultController = halResultController;
+        halResultController.setCallback(() -> {
+            mCurrentUserId = -10000;
+        });
+        mCurrentUserId = ActivityManager.getCurrentUser();
+        try {
+            ActivityManager.getService().registerUserSwitchObserver(new SynchronousUserSwitchObserver() {
+                public void onUserSwitching(int newUserId) {
+                    Slog.d(TAG, "user switch : newUserId = " + newUserId);
+                    mCurrentUserId = newUserId;
+                    if (getDaemon() == null) {
+                        bindFaceAuthService(mCurrentUserId);
+                    }
+                }
+            }, TAG);
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Unable to register user switch observer");
+        }
+        context.registerReceiver(new BroadcastReceiver() {
+            @Override
+            public void onReceive(Context context2, Intent intent) {
+                if (getDaemon() == null) {
+                    bindFaceAuthService(mCurrentUserId);
+                }
+            }
+        }, new IntentFilter("android.intent.action.USER_UNLOCKED"));
+    }
+
+    public CustomFaceProvider(Context context, FaceSensorPropertiesInternal sensorProps, LockoutResetDispatcher lockoutResetDispatcher) {
+        this(context, sensorProps, lockoutResetDispatcher, new BiometricScheduler(context, TAG, 0, null));
+    }
+
+    synchronized IFaceService getDaemon() {
+        if (mTestHalEnabled) {
+            if (mTestHal == null) {
+                mTestHal = new TestHal(mCurrentUserId, mContext, mSensorId);
+            }
+            try {
+                mTestHal.setCallback(mHalResultController);
+            } catch (RemoteException e) {
+                e.printStackTrace();
+            }
+            return mTestHal;
+        }
+        IFaceService service = getFaceService(mCurrentUserId);
+        if (service == null) {
+            bindFaceAuthService(mCurrentUserId);
+        }
+        return service;
+    }
+
+    @Override
+    public boolean containsSensor(int sensorId) {
+        return mSensorId == sensorId;
+    }
+
+    @Override
+    public List<FaceSensorPropertiesInternal> getSensorProperties() {
+        List<FaceSensorPropertiesInternal> properties = new ArrayList<>();
+        properties.add(mSensorProperties);
+        return properties;
+    }
+
+    @Override
+    public FaceSensorPropertiesInternal getSensorProperties(int sensorId) {
+        return mSensorProperties;
+    }
+
+    @Override
+    public List<Face> getEnrolledFaces(int sensorId, int userId) {
+        return FaceUtils.getLegacyInstance(mSensorId).getBiometricsForUser(mContext, userId);
+    }
+
+    @Override
+    public int getLockoutModeForUser(int sensorId, int userId) {
+        return mLockoutTracker.getLockoutModeForUser(userId);
+    }
+
+    @Override
+    public long getAuthenticatorId(int sensorId, int userId) {
+        return mAuthenticatorIds.getOrDefault(Integer.valueOf(userId), 0L).longValue();
+    }
+
+    @Override
+    public boolean isHardwareDetected(int sensorId) {
+        return getDaemon() != null;
+    }
+
+    private boolean isGeneratedChallengeCacheValid() {
+        return mGeneratedChallengeCache != null && sSystemClock.millis() - mGeneratedChallengeCache.getCreatedAt() < GENERATE_CHALLENGE_REUSE_INTERVAL_MILLIS;
+    }
+
+    private void incrementChallengeCount() {
+        mGeneratedChallengeCount.add(0, sSystemClock.millis());
+    }
+
+    private int decrementChallengeCount() {
+        mGeneratedChallengeCount.removeIf(aLong -> sSystemClock.millis() - aLong > GENERATE_CHALLENGE_COUNTER_TTL_MILLIS);
+        if (!mGeneratedChallengeCount.isEmpty()) {
+            mGeneratedChallengeCount.remove(0);
+        }
+        return mGeneratedChallengeCount.size();
+    }
+
+    @Override
+    public void scheduleGenerateChallenge(int sensorId, int userId, IBinder token, IFaceServiceReceiver receiver, String opPackageName) {
+        mHandler.post(() -> {
+            if (getDaemon() == null) {
+                bindFaceAuthService(mCurrentUserId);
+                try {
+                    receiver.onChallengeGenerated(sensorId, userId, 0);
+                } catch (RemoteException e) {
+                    e.printStackTrace();
+                }
+            } else {
+                incrementChallengeCount();
+                if (isGeneratedChallengeCacheValid()) {
+                    Slog.d(TAG, "Current challenge is cached and will be reused");
+                    mGeneratedChallengeCache.reuseResult(receiver);
+                    return;
+                }
+                scheduleUpdateActiveUserWithoutHandler(userId);
+                final FaceGenerateChallengeClient client = new FaceGenerateChallengeClient(mContext, mLazyDaemon, token, new ClientMonitorCallbackConverter(receiver), userId, opPackageName, mSensorId, createLogger(BiometricsProtoEnums.ACTION_UNKNOWN, BiometricsProtoEnums.CLIENT_UNKNOWN), mBiometricContext, sSystemClock.millis());
+                mGeneratedChallengeCache = client;
+                mScheduler.scheduleClientMonitor(client, new ClientMonitorCallback() {
+                    @Override
+                    public void onClientStarted(BaseClientMonitor clientMonitor) {
+                        if (client != clientMonitor) {
+                            Slog.e(TAG, "scheduleGenerateChallenge onClientStarted, mismatched client. Expecting: " + client + ", received: " + clientMonitor);
+                        }
+                    }
+                });
+            }
+        });
+    }
+
+    @Override
+    public void scheduleRevokeChallenge(int sensorId, int userId, IBinder token, String opPackageName, long challenge) {
+        mHandler.post(() -> {
+            if (getDaemon() == null) {
+                bindFaceAuthService(mCurrentUserId);
+                return;
+            }
+            if (!(decrementChallengeCount() == 0)) {
+                Slog.w(TAG, "scheduleRevokeChallenge skipped - challenge still in use: " + mGeneratedChallengeCount);
+                return;
+            }
+            Slog.d(TAG, "scheduleRevokeChallenge executing - no active clients");
+            mGeneratedChallengeCache = null;
+            final FaceRevokeChallengeClient client = new FaceRevokeChallengeClient(mContext, mLazyDaemon, token, userId, opPackageName, mSensorId, createLogger(BiometricsProtoEnums.ACTION_UNKNOWN, BiometricsProtoEnums.CLIENT_UNKNOWN), mBiometricContext);
+            mScheduler.scheduleClientMonitor(client, new ClientMonitorCallback() {
+                @Override
+                public void onClientFinished(BaseClientMonitor clientMonitor, boolean success) {
+                    if (client != clientMonitor) {
+                        Slog.e(TAG, "scheduleRevokeChallenge, mismatched client.Expecting: " + client + ", received: " + clientMonitor);
+                    }
+                }
+            });
+        });
+    }
+
+    @Override
+    public long scheduleEnroll(int sensorId, IBinder token, byte[] hardwareAuthToken, int userId, IFaceServiceReceiver receiver, String opPackageName, int[] disabledFeatures, Surface previewSurface, boolean debugConsent) {
+        final long id = mRequestCounter.incrementAndGet();
+        mHandler.post(() -> {
+            if (getDaemon() == null) {
+                bindFaceAuthService(mCurrentUserId);
+                try {
+                    receiver.onError(2, 0);
+                } catch (RemoteException e) {
+                    e.printStackTrace();
+                }
+            } else {
+                scheduleUpdateActiveUserWithoutHandler(userId);
+                BiometricNotificationUtils.cancelReEnrollNotification(mContext);
+                final FaceEnrollClient client = new FaceEnrollClient(mContext, mLazyDaemon, token, new ClientMonitorCallbackConverter(receiver), userId, hardwareAuthToken, opPackageName, FaceUtils.getLegacyInstance(mSensorId), disabledFeatures, ENROLL_TIMEOUT_SEC, previewSurface, mSensorId, createLogger(BiometricsProtoEnums.ACTION_ENROLL, BiometricsProtoEnums.CLIENT_UNKNOWN), mBiometricContext);
+                mScheduler.scheduleClientMonitor(client, new ClientMonitorCallback() {
+                    @Override
+                    public void onClientFinished(BaseClientMonitor clientMonitor, boolean success) {
+                        if (success) {
+                            scheduleUpdateActiveUserWithoutHandler(client.getTargetUserId());
+                        }
+                    }
+                });
+            }
+        });
+        return id;
+    }
+
+    @Override
+    public void cancelEnrollment(int sensorId, IBinder token, long requestId) {
+        mHandler.post(() -> mScheduler.cancelEnrollment(token, requestId));
+    }
+
+    @Override
+    public long scheduleFaceDetect(int sensorId, IBinder token, int userId, ClientMonitorCallbackConverter callback, String opPackageName, int statsClient) {
+        throw new IllegalStateException("Face detect not supported by IBiometricsFace@1.0. Did youforget to check the supportsFaceDetection flag?");
+    }
+
+    @Override
+    public void cancelFaceDetect(int sensorId, IBinder token, long requestId) {
+        throw new IllegalStateException("Face detect not supported by IBiometricsFace@1.0. Did youforget to check the supportsFaceDetection flag?");
+    }
+
+    @Override
+    public long scheduleAuthenticate(int sensorId, IBinder token, long operationId,
+                                     int userId, int cookie, ClientMonitorCallbackConverter receiver,
+                                     String opPackageName, boolean restricted, int statsClient,
+                                     boolean allowBackgroundAuthentication, boolean isKeyguardBypassEnabled) {
+        final long id = mRequestCounter.incrementAndGet();
+        scheduleAuthenticate(sensorId, token, operationId, userId, cookie, receiver,
+                opPackageName, id, restricted, statsClient,
+                allowBackgroundAuthentication, isKeyguardBypassEnabled);
+        return id;
+    }
+
+    @Override
+    public void scheduleAuthenticate(int sensorId, IBinder token, long operationId, int userId, int cookie, ClientMonitorCallbackConverter receiver, String opPackageName, long requestId, boolean restricted, int statsClient, boolean allowBackgroundAuthentication, boolean isKeyguardBypassEnabled) {
+        mHandler.post(() -> {
+            if (getDaemon() == null) {
+                bindFaceAuthService(mCurrentUserId);
+                try {
+                    receiver.onError(DEVICE_ID, 0, 1, 0);
+                } catch (RemoteException e) {
+                    e.printStackTrace();
+                }
+            } else {
+                scheduleUpdateActiveUserWithoutHandler(userId);
+                mScheduler.scheduleClientMonitor(new FaceAuthenticationClient(mContext, mLazyDaemon, token, requestId, receiver, userId, operationId, restricted, opPackageName, cookie, false, mSensorId, createLogger(BiometricsProtoEnums.ACTION_AUTHENTICATE, statsClient), mBiometricContext, Utils.isStrongBiometric(mSensorId), mLockoutTracker, mUsageStats, allowBackgroundAuthentication));
+            }
+        });
+    }
+
+    @Override
+    public void cancelAuthentication(int sensorId, IBinder token, long requestId) {
+        mHandler.post(() -> mScheduler.cancelAuthenticationOrDetection(token, requestId));
+    }
+
+    @Override
+    public void scheduleRemove(int sensorId, IBinder token, int faceId, int userId, IFaceServiceReceiver receiver, String opPackageName) {
+        mHandler.post(() -> {
+            if (getDaemon() == null) {
+                bindFaceAuthService(mCurrentUserId);
+                try {
+                    receiver.onError(1, 0);
+                } catch (RemoteException e) {
+                    e.printStackTrace();
+                }
+            } else {
+                scheduleUpdateActiveUserWithoutHandler(userId);
+                mScheduler.scheduleClientMonitor(new FaceRemovalClient(mContext, mLazyDaemon, token, new ClientMonitorCallbackConverter(receiver), faceId, userId, opPackageName, FaceUtils.getLegacyInstance(mSensorId), mSensorId, createLogger(BiometricsProtoEnums.ACTION_REMOVE, BiometricsProtoEnums.CLIENT_UNKNOWN), mBiometricContext, mAuthenticatorIds));
+            }
+        });
+    }
+
+    @Override
+    public void scheduleRemoveAll(int sensorId, IBinder token, int userId, IFaceServiceReceiver receiver, String opPackageName) {
+        mHandler.post(() -> {
+            if (getDaemon() == null) {
+                bindFaceAuthService(mCurrentUserId);
+                try {
+                    receiver.onError(1, 0);
+                } catch (RemoteException e) {
+                    e.printStackTrace();
+                }
+            } else {
+                scheduleUpdateActiveUserWithoutHandler(userId);
+                mScheduler.scheduleClientMonitor(new FaceRemovalClient(mContext, mLazyDaemon, token, new ClientMonitorCallbackConverter(receiver), 0, userId, opPackageName, FaceUtils.getLegacyInstance(mSensorId), mSensorId, createLogger(BiometricsProtoEnums.ACTION_REMOVE, BiometricsProtoEnums.CLIENT_UNKNOWN), mBiometricContext, mAuthenticatorIds));
+            }
+        });
+    }
+
+    @Override
+    public void scheduleResetLockout(int sensorId, int userId, byte[] hardwareAuthToken) {
+        mHandler.post(() -> {
+            if (getDaemon() == null) {
+                bindFaceAuthService(mCurrentUserId);
+            } else if (getEnrolledFaces(sensorId, userId).isEmpty()) {
+                Slog.w(TAG, "Ignoring lockout reset, no templates enrolled for user: " + userId);
+            } else {
+                scheduleUpdateActiveUserWithoutHandler(userId);
+                mScheduler.scheduleClientMonitor(new FaceResetLockoutClient(mContext, mLazyDaemon, userId, mContext.getOpPackageName(), mSensorId, createLogger(BiometricsProtoEnums.ACTION_UNKNOWN, BiometricsProtoEnums.CLIENT_UNKNOWN), mBiometricContext, hardwareAuthToken));
+            }
+        });
+    }
+
+    @Override
+    public void scheduleSetFeature(int sensorId, IBinder token, int userId, int feature, boolean enabled, byte[] hardwareAuthToken, IFaceServiceReceiver receiver, String opPackageName) {
+        mHandler.post(() -> {
+            if (getDaemon() == null) {
+                bindFaceAuthService(mCurrentUserId);
+                return;
+            }
+            List<Face> faces = getEnrolledFaces(sensorId, userId);
+            if (faces.isEmpty()) {
+                Slog.w(TAG, "Ignoring setFeature, no templates enrolled for user: " + userId);
+                return;
+            }
+            scheduleUpdateActiveUserWithoutHandler(userId);
+            mScheduler.scheduleClientMonitor(new FaceSetFeatureClient(mContext, mLazyDaemon, token, new ClientMonitorCallbackConverter(receiver), userId, opPackageName, mSensorId, BiometricLogger.ofUnknown(mContext), mBiometricContext, feature, enabled, hardwareAuthToken, faces.get(0).getBiometricId()));
+        });
+    }
+
+    @Override
+    public void scheduleGetFeature(int sensorId, IBinder token, int userId, int feature, ClientMonitorCallbackConverter listener, String opPackageName) {
+        mHandler.post(() -> {
+            if (getDaemon() == null) {
+                bindFaceAuthService(mCurrentUserId);
+                if (listener != null) {
+                    try {
+                        listener.onError(DEVICE_ID, 0, 1, 0);
+                    } catch (RemoteException e) {
+                        e.printStackTrace();
+                    }
+                }
+            } else {
+                List<Face> faces = getEnrolledFaces(sensorId, userId);
+                if (faces.isEmpty()) {
+                    Slog.w(TAG, "Ignoring getFeature, no templates enrolled for user: " + userId);
+                    return;
+                }
+                scheduleUpdateActiveUserWithoutHandler(userId);
+                final FaceGetFeatureClient client = new FaceGetFeatureClient(mContext, mLazyDaemon, token, listener, userId, opPackageName, mSensorId, BiometricLogger.ofUnknown(mContext), mBiometricContext, feature, faces.get(0).getBiometricId());
+                mScheduler.scheduleClientMonitor(client, new ClientMonitorCallback() {
+                    @Override
+                    public void onClientFinished(BaseClientMonitor clientMonitor, boolean success) {
+                        if (success && feature == 1) {
+                            final int settingsValue = client.getValue() ? 1 : 0;
+                            Slog.d(TAG, "Updating attention value for user: " + userId + " to value: " + settingsValue);
+                            Settings.Secure.putIntForUser(mContext.getContentResolver(), "face_unlock_attention_required", settingsValue, userId);
+                        }
+                    }
+                });
+            }
+        });
+    }
+
+    void scheduleInternalCleanup(int userId, ClientMonitorCallback callback) {
+        mHandler.post(() -> {
+            scheduleUpdateActiveUserWithoutHandler(userId);
+            List<Face> enrolledList = getEnrolledFaces(mSensorId, userId);
+            String opPackageName = mContext.getOpPackageName();
+            mScheduler.scheduleClientMonitor(new FaceInternalCleanupClient(mContext, mLazyDaemon, userId, opPackageName, mSensorId, createLogger(BiometricsProtoEnums.ACTION_ENUMERATE, BiometricsProtoEnums.CLIENT_UNKNOWN), mBiometricContext, enrolledList, FaceUtils.getLegacyInstance(mSensorId), mAuthenticatorIds), callback);
+        });
+    }
+
+    @Override
+    public void scheduleInternalCleanup(int sensorId, int userId, ClientMonitorCallback callback) {
+        scheduleInternalCleanup(userId, callback);
+    }
+
+    @Override
+    public void scheduleInvalidateAuthenticatorId(int i, int i1, IInvalidationCallback iInvalidationCallback) {
+        ServiceProvider.super.scheduleInvalidateAuthenticatorId(i, i1, iInvalidationCallback);
+    }
+
+    @Override
+    public void startPreparedClient(int sensorId, int cookie) {
+        mHandler.post(() -> mScheduler.startPreparedClient(cookie));
+    }
+
+    @Override
+    public void dumpProtoState(int sensorId, ProtoOutputStream proto, boolean clearSchedulerBuffer) {
+        final long sensorToken = proto.start(SensorServiceStateProto.SENSOR_STATES);
+
+        proto.write(SensorStateProto.SENSOR_ID, mSensorProperties.sensorId);
+        proto.write(SensorStateProto.MODALITY, SensorStateProto.FACE);
+        proto.write(SensorStateProto.CURRENT_STRENGTH,
+                Utils.getCurrentStrength(mSensorProperties.sensorId));
+        proto.write(SensorStateProto.SCHEDULER, mScheduler.dumpProtoState(clearSchedulerBuffer));
+
+        for (UserInfo user : UserManager.get(mContext).getUsers()) {
+            final int userId = user.getUserHandle().getIdentifier();
+
+            final long userToken = proto.start(SensorStateProto.USER_STATES);
+            proto.write(UserStateProto.USER_ID, userId);
+            proto.write(UserStateProto.NUM_ENROLLED, FaceUtils.getLegacyInstance(mSensorId)
+                    .getBiometricsForUser(mContext, userId).size());
+            proto.end(userToken);
+        }
+
+        proto.write(SensorStateProto.RESET_LOCKOUT_REQUIRES_HARDWARE_AUTH_TOKEN,
+                mSensorProperties.resetLockoutRequiresHardwareAuthToken);
+        proto.write(SensorStateProto.RESET_LOCKOUT_REQUIRES_CHALLENGE,
+                mSensorProperties.resetLockoutRequiresChallenge);
+
+        proto.end(sensorToken);
+    }
+
+    @Override
+    public void dumpProtoMetrics(int sensorId, FileDescriptor fd) {
+    }
+
+    @Override
+    public void dumpInternal(int sensorId, PrintWriter pw) {
+        PerformanceTracker performanceTracker =
+                PerformanceTracker.getInstanceForSensorId(mSensorId);
+
+        JSONObject dump = new JSONObject();
+        try {
+            dump.put("service", TAG);
+
+            JSONArray sets = new JSONArray();
+            for (UserInfo user : UserManager.get(mContext).getUsers()) {
+                final int userId = user.getUserHandle().getIdentifier();
+                final int c = FaceUtils.getLegacyInstance(mSensorId)
+                        .getBiometricsForUser(mContext, userId).size();
+                JSONObject set = new JSONObject();
+                set.put("id", userId);
+                set.put("count", c);
+                set.put("accept", performanceTracker.getAcceptForUser(userId));
+                set.put("reject", performanceTracker.getRejectForUser(userId));
+                set.put("acquire", performanceTracker.getAcquireForUser(userId));
+                set.put("lockout", performanceTracker.getTimedLockoutForUser(userId));
+                set.put("permanentLockout", performanceTracker.getPermanentLockoutForUser(userId));
+                // cryptoStats measures statistics about secure face transactions
+                // (e.g. to unlock password storage, make secure purchases, etc.)
+                set.put("acceptCrypto", performanceTracker.getAcceptCryptoForUser(userId));
+                set.put("rejectCrypto", performanceTracker.getRejectCryptoForUser(userId));
+                set.put("acquireCrypto", performanceTracker.getAcquireCryptoForUser(userId));
+                sets.put(set);
+            }
+
+            dump.put("prints", sets);
+        } catch (JSONException e) {
+            Slog.e(TAG, "dump formatting failure", e);
+        }
+        pw.println(dump);
+        pw.println("HAL deaths since last reboot: " + performanceTracker.getHALDeathCount());
+
+        mScheduler.dump(pw);
+        mUsageStats.print(pw);
+    }
+
+    private void scheduleLoadAuthenticatorIds() {
+        mHandler.post(() -> {
+            for (UserInfo user : UserManager.get(mContext).getAliveUsers()) {
+                int targetUserId = user.id;
+                if (!mAuthenticatorIds.containsKey(Integer.valueOf(targetUserId))) {
+                    scheduleUpdateActiveUserWithoutHandler(targetUserId);
+                }
+            }
+        });
+    }
+
+    void scheduleUpdateActiveUserWithoutHandler(final int targetUserId) {
+        mScheduler.scheduleClientMonitor(new FaceUpdateActiveUserClient(mContext, mLazyDaemon, targetUserId, mContext.getOpPackageName(), mSensorId, createLogger(BiometricsProtoEnums.ACTION_UNKNOWN, BiometricsProtoEnums.CLIENT_UNKNOWN), mBiometricContext, mCurrentUserId, !getEnrolledFaces(mSensorId, targetUserId).isEmpty(), mAuthenticatorIds), new ClientMonitorCallback() {
+            @Override
+            public void onClientFinished(BaseClientMonitor clientMonitor, boolean success) {
+                if (success) {
+                    mCurrentUserId = targetUserId;
+                }
+            }
+        });
+    }
+
+    private boolean isFaceServiceEnabled() {
+        if (!FaceUnlockUtils.isFaceUnlockSupported()) {
+            return false;
+        }
+        PackageManager pm = mContext.getPackageManager();
+        ResolveInfo info = pm.resolveService(FaceUnlockUtils.getServiceIntent(), 131072);
+        return info != null && info.serviceInfo.isEnabled();
+    }
+
+    public static boolean useCustomFaceUnlockService() {
+        return FaceUnlockUtils.isFaceUnlockSupported();
+    }
+
+    private IFaceService getFaceService(int userId) {
+        if (userId == -10000) {
+            scheduleUpdateActiveUserWithoutHandler(ActivityManager.getCurrentUser());
+        }
+        return mFaceServices.get(mCurrentUserId);
+    }
+
+    void bindFaceAuthService(int userId) {
+        Slog.d(TAG, "bindFaceAuthService " + userId);
+        if (!isFaceServiceEnabled()) {
+            Slog.d(TAG, "FaceService disabled");
+        } else if (mIsServiceBinding) {
+            Slog.d(TAG, "FaceService is binding");
+        } else {
+            if (userId != -10000 && getFaceService(userId) == null) {
+                try {
+                    Intent intent = FaceUnlockUtils.getServiceIntent();
+                    boolean result = mContext.bindServiceAsUser(intent, new FaceServiceConnection(userId), 1, UserHandle.of(userId));
+                    if (result) {
+                        mIsServiceBinding = true;
+                    }
+                } catch (SecurityException e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+    }
+
+    @Override
+    public void dumpHal(int sensorId, FileDescriptor fd, String[] args) {
+    }
+
+    protected void setTestHalEnabled(boolean enabled) {
+        mTestHalEnabled = enabled;
+    }
+
+    @Override
+    public ITestSession createTestSession(int sensorId, ITestSessionCallback callback, String opPackageName) {
+        return new BiometricTestSessionImpl(mContext, mSensorId, callback, this, mHalResultController);
+    }
+
+    public static class HalResultController extends com.android.internal.util.custom.faceunlock.IFaceServiceReceiver.Stub {
+        private final Context mContext;
+        private final Handler mHandler;
+        private final LockoutResetDispatcher mLockoutResetDispatcher;
+        private final LockoutHalImpl mLockoutTracker;
+        private final BiometricScheduler mScheduler;
+        private final int mSensorId;
+        private Callback mCallback;
+
+        HalResultController(int sensorId, Context context, Handler handler, BiometricScheduler scheduler, LockoutHalImpl lockoutTracker, LockoutResetDispatcher lockoutResetDispatcher) {
+            mSensorId = sensorId;
+            mContext = context;
+            mHandler = handler;
+            mScheduler = scheduler;
+            mLockoutTracker = lockoutTracker;
+            mLockoutResetDispatcher = lockoutResetDispatcher;
+        }
+
+        public void setCallback(Callback callback) {
+            mCallback = callback;
+        }
+
+        public void onEnrollResult(int faceId, int userId, int remaining) {
+            mHandler.post(() -> {
+                Face face = new Face(FaceUtils.getLegacyInstance(mSensorId).getUniqueName(mContext, userId), faceId, DEVICE_ID);
+                BaseClientMonitor client = mScheduler.getCurrentClient();
+                if (!(client instanceof FaceEnrollClient)) {
+                    Slog.e(TAG, "onEnrollResult for non-enroll client: " + Utils.getClientName(client));
+                    return;
+                }
+                ((FaceEnrollClient) client).onEnrollResult(face, remaining);
+            });
+        }
+
+        public void onAuthenticated(int faceId, int userId, byte[] token) {
+            mHandler.post(() -> {
+                BaseClientMonitor client = mScheduler.getCurrentClient();
+                if (!(client instanceof AuthenticationConsumer)) {
+                    Slog.e(TAG, "onAuthenticated for non-authentication consumer: " + Utils.getClientName(client));
+                    return;
+                }
+                ((AuthenticationConsumer) client).onAuthenticated(new Face("", faceId, DEVICE_ID), faceId != 0, ArrayUtils.toByteArrayList(token));
+            });
+        }
+
+        public void onAcquired(int userId, int acquiredInfo, int vendorCode) {
+            mHandler.post(() -> {
+                BaseClientMonitor client = mScheduler.getCurrentClient();
+                if (!(client instanceof AcquisitionClient)) {
+                    Slog.e(TAG, "onAcquired for non-acquire client: " + Utils.getClientName(client));
+                    return;
+                }
+                final AcquisitionClient<?> acquisitionClient =
+                        (AcquisitionClient<?>) client;
+                acquisitionClient.onAcquired(acquiredInfo, vendorCode);
+            });
+        }
+
+        public void onError(int error, int vendorCode) {
+            mHandler.post(() -> {
+                BaseClientMonitor client = mScheduler.getCurrentClient();
+                String log = "handleError, client: " +
+                        (client != null ? client.getOwnerString() : null) +
+                        ", error: " +
+                        error +
+                        ", vendorCode: " +
+                        vendorCode;
+                Slog.d(TAG, log);
+                if (!(client instanceof ErrorConsumer)) {
+                    Slog.e(TAG, "onError for non-error consumer: " + Utils.getClientName(client));
+                    return;
+                }
+                ((ErrorConsumer) client).onError(error, vendorCode);
+                if (error == 1) {
+                    Slog.e(TAG, "Got ERROR_HW_UNAVAILABLE");
+                    if (mCallback != null) {
+                        mCallback.onHardwareUnavailable();
+                    }
+                }
+            });
+        }
+
+        public void onRemoved(int[] removed, int userId) {
+            mHandler.post(() -> {
+                BaseClientMonitor client = mScheduler.getCurrentClient();
+                if (!(client instanceof RemovalConsumer)) {
+                    Slog.e(TAG, "onRemoved for non-removal consumer: " + Utils.getClientName(client));
+                    return;
+                }
+                RemovalConsumer removalConsumer = (RemovalConsumer) client;
+                if (removed.length > 0) {
+                    for (int i = 0; i < removed.length; i++) {
+                        int id = removed[i];
+                        Face face = new Face("", id, DEVICE_ID);
+                        int remaining = (removed.length - i) - 1;
+                        Slog.d(TAG, "Removed, faceId: " + id + ", remaining: " + remaining);
+                        removalConsumer.onRemoved(face, remaining);
+                    }
+                } else {
+                    removalConsumer.onRemoved(null, 0);
+                }
+                Settings.Secure.putIntForUser(mContext.getContentResolver(), "face_unlock_re_enroll", 0, -2);
+            });
+        }
+
+        public void onEnumerate(int[] faceIds, int userId) {
+            mHandler.post(() -> {
+                BaseClientMonitor client = mScheduler.getCurrentClient();
+                if (!(client instanceof EnumerateConsumer)) {
+                    Slog.e(TAG, "onEnumerate for non-enumerate consumer: " + Utils.getClientName(client));
+                    return;
+                }
+                EnumerateConsumer enumerateConsumer = (EnumerateConsumer) client;
+                if (faceIds.length > 0) {
+                    for (int i = 0; i < faceIds.length; i++) {
+                        enumerateConsumer.onEnumerationResult(new Face("", faceIds[i], DEVICE_ID), (faceIds.length - i) - 1);
+                    }
+                    return;
+                }
+                enumerateConsumer.onEnumerationResult(null, 0);
+            });
+        }
+
+        public void onLockoutChanged(long duration) {
+            mHandler.post(() -> {
+                int lockoutMode;
+                Slog.d(TAG, "onLockoutChanged: " + duration);
+                if (duration == 0) {
+                    lockoutMode = 0;
+                } else if (duration == -1 || duration == Long.MAX_VALUE) {
+                    lockoutMode = 2;
+                } else {
+                    lockoutMode = 1;
+                }
+                mLockoutTracker.setCurrentUserLockoutMode(lockoutMode);
+                if (duration == 0) {
+                    mLockoutResetDispatcher.notifyLockoutResetCallbacks(mSensorId);
+                }
+            });
+        }
+
+        public interface Callback {
+            void onHardwareUnavailable();
+        }
+    }
+
+    class FaceServiceConnection implements ServiceConnection {
+        private final int mUserId;
+
+        public FaceServiceConnection(int userId) {
+            mUserId = userId;
+        }
+
+        @Override
+        public void onServiceConnected(ComponentName className, IBinder service) {
+            Slog.d(TAG, "FaceService connected : " + mUserId);
+            IFaceService faceService = IFaceService.Stub.asInterface(service);
+            if (faceService != null) {
+                synchronized (mFaceServices) {
+                    try {
+                        faceService.setCallback(mHalResultController);
+                        mFaceServices.put(mUserId, faceService);
+                        mHandler.post(() -> {
+                            scheduleInternalCleanup(mUserId, null);
+                            scheduleGetFeature(mSensorId, new Binder(), mUserId, 1, null, mContext.getOpPackageName());
+                        });
+                    } catch (RemoteException e) {
+                        e.printStackTrace();
+                    }
+                    mIsServiceBinding = false;
+                }
+            }
+        }
+
+        @Override
+        public void onServiceDisconnected(ComponentName className) {
+            Slog.d(TAG, "FaceService disconnected : " + mUserId);
+            mFaceServices.remove(mUserId);
+            mIsServiceBinding = false;
+            if (mUserId == mCurrentUserId) {
+                mHandler.postDelayed(() -> {
+                    BaseClientMonitor client = mScheduler.getCurrentClient();
+                    if (client instanceof ErrorConsumer) {
+                        ((ErrorConsumer) client).onError(5, 0);
+                    }
+                    bindFaceAuthService(mUserId);
+                    mScheduler.recordCrashState();
+                    mScheduler.reset();
+                }, 100);
+            }
+            mContext.unbindService(this);
+        }
+    }
+
+    private BiometricLogger createLogger(int statsAction, int statsClient) {
+        return new BiometricLogger(mContext, BiometricsProtoEnums.MODALITY_FACE,
+                statsAction, statsClient);
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceAuthenticationClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceAuthenticationClient.java
new file mode 100644
index 000000000000..5c01d7b20f6a
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceAuthenticationClient.java
@@ -0,0 +1,141 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.res.Resources;
+import android.hardware.biometrics.BiometricAuthenticator;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.provider.Settings;
+import android.util.Slog;
+
+import com.android.internal.R;
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.Utils;
+import com.android.server.biometrics.sensors.AuthenticationClient;
+import com.android.server.biometrics.sensors.BiometricNotificationUtils;
+import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
+import com.android.server.biometrics.sensors.LockoutTracker;
+import com.android.server.biometrics.sensors.face.UsageStats;
+import com.android.server.biometrics.log.BiometricContext;
+import com.android.server.biometrics.log.BiometricLogger;
+
+import java.util.ArrayList;
+import java.util.function.Supplier;
+
+class FaceAuthenticationClient extends AuthenticationClient<IFaceService> {
+    private static final String TAG = "FaceAuthenticationClient";
+    private final int[] mBiometricPromptIgnoreList;
+    private final int[] mBiometricPromptIgnoreListVendor;
+    private final ContentResolver mContentResolver;
+    private final boolean mCustomHaptics;
+    private final int[] mKeyguardIgnoreList;
+    private final int[] mKeyguardIgnoreListVendor;
+    private final UsageStats mUsageStats;
+    private int mLastAcquire;
+
+    FaceAuthenticationClient(Context context, Supplier<IFaceService> lazyDaemon, IBinder token, long requestId, ClientMonitorCallbackConverter listener, int targetUserId, long operationId, boolean restricted, String owner, int cookie, boolean requireConfirmation, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext, boolean isStrongBiometric, LockoutTracker lockoutTracker, UsageStats usageStats, boolean allowBackgroundAuthentication) {
+        super(context, lazyDaemon, token, listener, targetUserId, operationId, restricted, owner, cookie, requireConfirmation, sensorId, biometricLogger, biometricContext, isStrongBiometric, null /* taskStackListener */, lockoutTracker, allowBackgroundAuthentication, true, false);
+        mUsageStats = usageStats;
+        setRequestId(requestId);
+        Resources resources = getContext().getResources();
+        mBiometricPromptIgnoreList = resources.getIntArray(
+                R.array.config_face_acquire_biometricprompt_ignorelist);
+        mBiometricPromptIgnoreListVendor = resources.getIntArray(
+                R.array.config_face_acquire_vendor_biometricprompt_ignorelist);
+        mKeyguardIgnoreList = resources.getIntArray(
+                R.array.config_face_acquire_keyguard_ignorelist);
+        mKeyguardIgnoreListVendor = resources.getIntArray(
+                R.array.config_face_acquire_vendor_keyguard_ignorelist);
+        ContentResolver contentResolver = context.getContentResolver();
+        mContentResolver = contentResolver;
+        mCustomHaptics = Settings.Global.getInt(contentResolver, "face_custom_success_error", 0) == 1;
+    }
+
+    @Override
+    protected void startHalOperation() {
+        try {
+            getFreshDaemon().authenticate(mOperationId);
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Remote exception when requesting auth", e);
+            onError(1, 0);
+            mCallback.onClientFinished(this, false);
+        }
+    }
+
+    @Override
+    protected void handleLifecycleAfterAuth(boolean authenticated) {
+    }
+
+    @Override
+    protected void stopHalOperation() {
+        try {
+            getFreshDaemon().cancel();
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Remote exception when requesting cancel", e);
+            onError(1, 0);
+            mCallback.onClientFinished(this, false);
+        }
+    }
+
+    @Override
+    public boolean wasUserDetected() {
+        return mLastAcquire != 11 && mLastAcquire != 21;
+    }
+
+    @Override
+    public void onAuthenticated(BiometricAuthenticator.Identifier identifier, boolean authenticated, ArrayList<Byte> token) {
+        super.onAuthenticated(identifier, authenticated, token);
+        mUsageStats.addEvent(new UsageStats.AuthenticationEvent(getStartTimeMs(), System.currentTimeMillis() - getStartTimeMs(), authenticated, 0, 0, getTargetUserId()));
+        mCallback.onClientFinished(this, true);
+    }
+
+    @Override
+    public void onError(int error, int vendorCode) {
+        mUsageStats.addEvent(new UsageStats.AuthenticationEvent(getStartTimeMs(), System.currentTimeMillis() - getStartTimeMs(), false, error, vendorCode, getTargetUserId()));
+        if (error == 16) {
+            BiometricNotificationUtils.showReEnrollmentNotification(getContext());
+        }
+        super.onError(error, vendorCode);
+    }
+
+    private int[] getAcquireIgnorelist() {
+        return isBiometricPrompt() ? mBiometricPromptIgnoreList : mKeyguardIgnoreList;
+    }
+
+    private int[] getAcquireVendorIgnorelist() {
+        return isBiometricPrompt() ? mBiometricPromptIgnoreListVendor : mKeyguardIgnoreListVendor;
+    }
+
+    private boolean shouldSend(int acquireInfo, int vendorCode) {
+        if (acquireInfo == 22) {
+            return !Utils.listContains(getAcquireVendorIgnorelist(), vendorCode);
+        }
+        return !Utils.listContains(getAcquireIgnorelist(), acquireInfo);
+    }
+
+    @Override
+    public void onAcquired(int acquireInfo, int vendorCode) {
+        mLastAcquire = acquireInfo;
+        if (acquireInfo == 13) {
+            BiometricNotificationUtils.showReEnrollmentNotification(getContext());
+        }
+        onAcquiredInternal(acquireInfo, vendorCode, shouldSend(acquireInfo, vendorCode));
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceEnrollClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceEnrollClient.java
new file mode 100644
index 000000000000..6272ce7ec32c
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceEnrollClient.java
@@ -0,0 +1,101 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.hardware.face.Face;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.util.Slog;
+import android.view.Surface;
+
+import com.android.internal.R;
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.Utils;
+import com.android.server.biometrics.sensors.BiometricUtils;
+import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
+import com.android.server.biometrics.sensors.EnrollClient;
+import com.android.server.biometrics.log.BiometricContext;
+import com.android.server.biometrics.log.BiometricLogger;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.function.Supplier;
+
+class FaceEnrollClient extends EnrollClient<IFaceService> {
+    private static final String TAG = "FaceEnrollClient";
+    private final int[] mDisabledFeatures;
+    private final int[] mEnrollIgnoreList = getContext().getResources().getIntArray(R.array.config_face_acquire_enroll_ignorelist);
+    private final int[] mEnrollIgnoreListVendor = getContext().getResources().getIntArray(R.array.config_face_acquire_vendor_enroll_ignorelist);
+    private final Surface mPreviewSurface;
+
+    FaceEnrollClient(Context context, Supplier<IFaceService> lazyDaemon, IBinder token, ClientMonitorCallbackConverter listener, int userId, byte[] hardwareAuthToken, String owner, BiometricUtils<Face> utils, int[] disabledFeatures, int timeoutSec, Surface previewSurface, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext) {
+        super(context, lazyDaemon, token, listener, userId, hardwareAuthToken, owner, utils, timeoutSec, sensorId, false /* shouldVibrate */, biometricLogger, biometricContext);
+        mDisabledFeatures = Arrays.copyOf(disabledFeatures, disabledFeatures.length);
+        mPreviewSurface = previewSurface;
+    }
+
+    @Override
+    protected boolean hasReachedEnrollmentLimit() {
+        if (mBiometricUtils.getBiometricsForUser(getContext(), getTargetUserId()).size() < getContext().getResources().getInteger(R.integer.config_faceMaxTemplatesPerUser)) {
+            return false;
+        }
+        Slog.w(TAG, "Too many faces registered, user: " + getTargetUserId());
+        return true;
+    }
+
+    @Override
+    public void onAcquired(int acquireInfo, int vendorCode) {
+        boolean shouldSend;
+        if (acquireInfo == 22) {
+            shouldSend = !Utils.listContains(mEnrollIgnoreListVendor, vendorCode);
+        } else {
+            shouldSend = !Utils.listContains(mEnrollIgnoreList, acquireInfo);
+        }
+        onAcquiredInternal(acquireInfo, vendorCode, shouldSend);
+    }
+
+    @Override
+    protected void startHalOperation() {
+        ArrayList<Byte> token = new ArrayList<>();
+        for (byte b : mHardwareAuthToken) {
+            token.add(b);
+        }
+        ArrayList<Integer> disabledFeatures = new ArrayList<>();
+        for (int disabledFeature : mDisabledFeatures) {
+            disabledFeatures.add(disabledFeature);
+        }
+        try {
+            getFreshDaemon().enroll(ArrayUtils.toByteArray(token), mTimeoutSec, ArrayUtils.toIntArray(disabledFeatures));
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Remote exception when requesting enroll", e);
+            onError(2, 0);
+            mCallback.onClientFinished(this, false);
+        }
+    }
+
+    @Override
+    protected void stopHalOperation() {
+        try {
+            getFreshDaemon().cancel();
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Remote exception when requesting cancel", e);
+            onError(1, 0);
+            mCallback.onClientFinished(this, false);
+        }
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceGenerateChallengeClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceGenerateChallengeClient.java
new file mode 100644
index 000000000000..44c4e6809c07
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceGenerateChallengeClient.java
@@ -0,0 +1,94 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.hardware.face.IFaceServiceReceiver;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.util.Slog;
+
+import com.android.internal.util.Preconditions;
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.sensors.BaseClientMonitor;
+import com.android.server.biometrics.sensors.ClientMonitorCallback;
+import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
+import com.android.server.biometrics.sensors.GenerateChallengeClient;
+import com.android.server.biometrics.log.BiometricContext;
+import com.android.server.biometrics.log.BiometricLogger;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.Supplier;
+
+class FaceGenerateChallengeClient extends GenerateChallengeClient<IFaceService> {
+    static final int CHALLENGE_TIMEOUT_SEC = 600;
+    private static final ClientMonitorCallback EMPTY_CALLBACK = new ClientMonitorCallback() {
+    };
+    private static final String TAG = "FaceGenerateChallengeClient";
+    private final long mCreatedAt;
+    private Long mChallengeResult;
+    private List<IFaceServiceReceiver> mWaiting = new ArrayList();
+
+    FaceGenerateChallengeClient(Context context, Supplier<IFaceService> lazyDaemon, IBinder token, ClientMonitorCallbackConverter listener, int userId, String owner, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext, long now) {
+        super(context, lazyDaemon, token, listener, userId, owner, sensorId, biometricLogger, biometricContext);
+        mCreatedAt = now;
+    }
+
+    @Override
+    protected void startHalOperation() {
+        mChallengeResult = null;
+        try {
+            try {
+                mChallengeResult = getFreshDaemon().generateChallenge(600);
+                sendChallengeResult(getListener(), mCallback);
+                for (IFaceServiceReceiver receiver : mWaiting) {
+                    sendChallengeResult(new ClientMonitorCallbackConverter(receiver), EMPTY_CALLBACK);
+                }
+            } catch (RemoteException e) {
+                Slog.e(TAG, "generateChallenge failed", e);
+                mCallback.onClientFinished(this, false);
+            }
+        } finally {
+            mWaiting = null;
+        }
+    }
+
+    public long getCreatedAt() {
+        return mCreatedAt;
+    }
+
+    public void reuseResult(IFaceServiceReceiver receiver) {
+        List<IFaceServiceReceiver> list = mWaiting;
+        if (list != null) {
+            list.add(receiver);
+        } else {
+            sendChallengeResult(new ClientMonitorCallbackConverter(receiver), EMPTY_CALLBACK);
+        }
+    }
+
+    private void sendChallengeResult(ClientMonitorCallbackConverter receiver, ClientMonitorCallback ownerCallback) {
+        Preconditions.checkState(mChallengeResult != null, "result not available");
+        try {
+            receiver.onChallengeGenerated(getSensorId(), getTargetUserId(), mChallengeResult);
+            ownerCallback.onClientFinished(this, true);
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Remote exception", e);
+            ownerCallback.onClientFinished(this, false);
+        }
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceGetFeatureClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceGetFeatureClient.java
new file mode 100644
index 000000000000..901bf581fa13
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceGetFeatureClient.java
@@ -0,0 +1,88 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.util.Slog;
+
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.sensors.BaseClientMonitor;
+import com.android.server.biometrics.sensors.ClientMonitorCallback;
+import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
+import com.android.server.biometrics.sensors.HalClientMonitor;
+import com.android.server.biometrics.log.BiometricContext;
+import com.android.server.biometrics.log.BiometricLogger;
+
+import java.util.function.Supplier;
+
+public class FaceGetFeatureClient extends HalClientMonitor<IFaceService> {
+    private static final String TAG = "FaceGetFeatureClient";
+    private final int mFaceId;
+    private final int mFeature;
+    private boolean mValue;
+
+    FaceGetFeatureClient(Context context, Supplier<IFaceService> lazyDaemon, IBinder token, ClientMonitorCallbackConverter listener, int userId, String owner, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext, int feature, int faceId) {
+        super(context, lazyDaemon, token, listener, userId, owner, 0, sensorId, biometricLogger, biometricContext);
+        mFeature = feature;
+        mFaceId = faceId;
+    }
+
+    @Override
+    public void unableToStart() {
+        try {
+            if (getListener() != null) {
+                getListener().onFeatureGet(false, new int[0], new boolean[0]);
+            }
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Unable to send error", e);
+        }
+    }
+
+    @Override
+    public void start(ClientMonitorCallback callback) {
+        super.start(callback);
+        startHalOperation();
+    }
+
+    @Override
+    protected void startHalOperation() {
+        try {
+            boolean result = getFreshDaemon().getFeature(mFeature, mFaceId);
+            int[] features = {mFeature};
+            boolean[] featureState = {result};
+            mValue = result;
+            if (getListener() != null) {
+                getListener().onFeatureGet(result, features, featureState);
+            }
+            mCallback.onClientFinished(this, true);
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Unable to getFeature", e);
+            mCallback.onClientFinished(this, false);
+        }
+    }
+
+    public boolean getValue() {
+        return mValue;
+    }
+
+    @Override
+    public int getProtoEnum() {
+        return 9;
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceInternalCleanupClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceInternalCleanupClient.java
new file mode 100644
index 000000000000..662886d79ca5
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceInternalCleanupClient.java
@@ -0,0 +1,49 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.hardware.face.Face;
+import android.os.IBinder;
+
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.sensors.BiometricUtils;
+import com.android.server.biometrics.sensors.InternalCleanupClient;
+import com.android.server.biometrics.sensors.InternalEnumerateClient;
+import com.android.server.biometrics.sensors.RemovalClient;
+import com.android.server.biometrics.log.BiometricContext;
+import com.android.server.biometrics.log.BiometricLogger;
+
+import java.util.List;
+import java.util.Map;
+import java.util.function.Supplier;
+
+class FaceInternalCleanupClient extends InternalCleanupClient<Face, IFaceService> {
+    FaceInternalCleanupClient(Context context, Supplier<IFaceService> lazyDaemon, int userId, String owner, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext, List<Face> enrolledList, BiometricUtils<Face> utils, Map<Integer, Long> authenticatorIds) {
+        super(context, lazyDaemon, userId, owner, sensorId, biometricLogger, biometricContext, enrolledList, utils, authenticatorIds);
+    }
+
+    @Override
+    protected InternalEnumerateClient<IFaceService> getEnumerateClient(Context context, Supplier<IFaceService> lazyDaemon, IBinder token, int userId, String owner, List<Face> enrolledList, BiometricUtils<Face> utils, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext) {
+        return new FaceInternalEnumerateClient(context, lazyDaemon, token, userId, owner, enrolledList, utils, sensorId, biometricLogger, biometricContext);
+    }
+
+    @Override
+    protected RemovalClient<Face, IFaceService> getRemovalClient(Context context, Supplier<IFaceService> lazyDaemon, IBinder token, int biometricId, int userId, String owner, BiometricUtils<Face> utils, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext, Map<Integer, Long> authenticatorIds) {
+        return new FaceRemovalClient(context, lazyDaemon, token, null, biometricId, userId, owner, utils, sensorId, biometricLogger, biometricContext, authenticatorIds);
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceInternalEnumerateClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceInternalEnumerateClient.java
new file mode 100644
index 000000000000..68b1d3b1f055
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceInternalEnumerateClient.java
@@ -0,0 +1,50 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.hardware.face.Face;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.util.Slog;
+
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.sensors.BiometricUtils;
+import com.android.server.biometrics.sensors.InternalEnumerateClient;
+import com.android.server.biometrics.log.BiometricContext;
+import com.android.server.biometrics.log.BiometricLogger;
+
+import java.util.List;
+import java.util.function.Supplier;
+
+class FaceInternalEnumerateClient extends InternalEnumerateClient<IFaceService> {
+    private static final String TAG = "FaceInternalEnumerateClient";
+
+    FaceInternalEnumerateClient(Context context, Supplier<IFaceService> lazyDaemon, IBinder token, int userId, String owner, List<Face> enrolledList, BiometricUtils<Face> utils, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext) {
+        super(context, lazyDaemon, token, userId, owner, enrolledList, utils, sensorId, biometricLogger, biometricContext);
+    }
+
+    @Override
+    protected void startHalOperation() {
+        try {
+            getFreshDaemon().enumerate();
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Remote exception when requesting enumerate", e);
+            mCallback.onClientFinished(this, false);
+        }
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceRemovalClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceRemovalClient.java
new file mode 100644
index 000000000000..61a7976fc0c6
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceRemovalClient.java
@@ -0,0 +1,53 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.hardware.face.Face;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.util.Slog;
+
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.sensors.BiometricUtils;
+import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
+import com.android.server.biometrics.sensors.RemovalClient;
+import com.android.server.biometrics.log.BiometricContext;
+import com.android.server.biometrics.log.BiometricLogger;
+
+import java.util.Map;
+import java.util.function.Supplier;
+
+class FaceRemovalClient extends RemovalClient<Face, IFaceService> {
+    private static final String TAG = "FaceRemovalClient";
+    private final int mBiometricId;
+
+    FaceRemovalClient(Context context, Supplier<IFaceService> lazyDaemon, IBinder token, ClientMonitorCallbackConverter listener, int biometricId, int userId, String owner, BiometricUtils<Face> utils, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext, Map<Integer, Long> authenticatorIds) {
+        super(context, lazyDaemon, token, listener, userId, owner, utils, sensorId, biometricLogger, biometricContext, authenticatorIds);
+        mBiometricId = biometricId;
+    }
+
+    @Override
+    protected void startHalOperation() {
+        try {
+            getFreshDaemon().remove(mBiometricId);
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Remote exception when requesting remove", e);
+            mCallback.onClientFinished(this, false);
+        }
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceResetLockoutClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceResetLockoutClient.java
new file mode 100644
index 000000000000..5915f81056f5
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceResetLockoutClient.java
@@ -0,0 +1,71 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.os.RemoteException;
+import android.util.Slog;
+
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.sensors.BaseClientMonitor;
+import com.android.server.biometrics.sensors.ClientMonitorCallback;
+import com.android.server.biometrics.sensors.HalClientMonitor;
+import com.android.server.biometrics.log.BiometricContext;
+import com.android.server.biometrics.log.BiometricLogger;
+
+import java.util.function.Supplier;
+
+class FaceResetLockoutClient extends HalClientMonitor<IFaceService> {
+    private static final String TAG = "FaceResetLockoutClient";
+    private final byte[] mHardwareAuthToken;
+
+    FaceResetLockoutClient(Context context, Supplier<IFaceService> lazyDaemon, int userId, String owner, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext, byte[] hardwareAuthToken) {
+        super(context, lazyDaemon, null, null, userId, owner, 0, sensorId, biometricLogger, biometricContext);
+        mHardwareAuthToken = hardwareAuthToken.clone();
+    }
+
+    @Override
+    public void unableToStart() {
+    }
+
+    @Override
+    public void start(ClientMonitorCallback callback) {
+        super.start(callback);
+        startHalOperation();
+    }
+
+    @Override
+    protected void startHalOperation() {
+        try {
+            getFreshDaemon().resetLockout(mHardwareAuthToken);
+            mCallback.onClientFinished(this, true);
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Unable to reset lockout", e);
+            mCallback.onClientFinished(this, false);
+        }
+    }
+
+    @Override
+    public int getProtoEnum() {
+        return 12;
+    }
+
+    @Override
+    public boolean interruptsPrecedingClients() {
+        return true;
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceRevokeChallengeClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceRevokeChallengeClient.java
new file mode 100644
index 000000000000..7939bf3d75b1
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceRevokeChallengeClient.java
@@ -0,0 +1,48 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.util.Slog;
+
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.sensors.RevokeChallengeClient;
+import com.android.server.biometrics.log.BiometricContext;
+import com.android.server.biometrics.log.BiometricLogger;
+
+import java.util.function.Supplier;
+
+class FaceRevokeChallengeClient extends RevokeChallengeClient<IFaceService> {
+    private static final String TAG = "FaceRevokeChallengeClient";
+
+    FaceRevokeChallengeClient(Context context, Supplier<IFaceService> lazyDaemon, IBinder token, int userId, String owner, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext) {
+        super(context, lazyDaemon, token, userId, owner, sensorId, biometricLogger, biometricContext);
+    }
+
+    @Override
+    protected void startHalOperation() {
+        try {
+            getFreshDaemon().revokeChallenge();
+            mCallback.onClientFinished(this, true);
+        } catch (RemoteException e) {
+            Slog.e(TAG, "revokeChallenge failed", e);
+            mCallback.onClientFinished(this, false);
+        }
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceSetFeatureClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceSetFeatureClient.java
new file mode 100644
index 000000000000..174cfca92982
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceSetFeatureClient.java
@@ -0,0 +1,80 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.util.Slog;
+
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.sensors.BaseClientMonitor;
+import com.android.server.biometrics.sensors.ClientMonitorCallback;
+import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
+import com.android.server.biometrics.sensors.HalClientMonitor;
+import com.android.server.biometrics.log.BiometricContext;
+import com.android.server.biometrics.log.BiometricLogger;
+
+import java.util.function.Supplier;
+
+class FaceSetFeatureClient extends HalClientMonitor<IFaceService> {
+    private static final String TAG = "FaceSetFeatureClient";
+    private final boolean mEnabled;
+    private final int mFaceId;
+    private final int mFeature;
+    private final byte[] mHardwareAuthToken;
+
+    FaceSetFeatureClient(Context context, Supplier<IFaceService> lazyDaemon, IBinder token, ClientMonitorCallbackConverter listener, int userId, String owner, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext, int feature, boolean enabled, byte[] hardwareAuthToken, int faceId) {
+        super(context, lazyDaemon, token, listener, userId, owner, 0, sensorId, biometricLogger, biometricContext);
+        mFeature = feature;
+        mEnabled = enabled;
+        mFaceId = faceId;
+        mHardwareAuthToken = hardwareAuthToken.clone();
+    }
+
+    @Override
+    public void unableToStart() {
+        try {
+            getListener().onFeatureSet(false, mFeature);
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Unable to send error", e);
+        }
+    }
+
+    @Override
+    public void start(ClientMonitorCallback callback) {
+        super.start(callback);
+        startHalOperation();
+    }
+
+    @Override
+    protected void startHalOperation() {
+        try {
+            getFreshDaemon().setFeature(mFeature, mEnabled, mHardwareAuthToken, mFaceId);
+            getListener().onFeatureSet(true, mFeature);
+            mCallback.onClientFinished(this, true);
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Unable to set feature: " + mFeature + " to enabled: " + mEnabled, e);
+            mCallback.onClientFinished(this, false);
+        }
+    }
+
+    @Override
+    public int getProtoEnum() {
+        return 8;
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceUpdateActiveUserClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceUpdateActiveUserClient.java
new file mode 100644
index 000000000000..163c24bd7934
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceUpdateActiveUserClient.java
@@ -0,0 +1,76 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.os.RemoteException;
+import android.util.Slog;
+
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.sensors.BaseClientMonitor;
+import com.android.server.biometrics.sensors.ClientMonitorCallback;
+import com.android.server.biometrics.sensors.HalClientMonitor;
+import com.android.server.biometrics.log.BiometricContext;
+import com.android.server.biometrics.log.BiometricLogger;
+
+import java.util.Map;
+import java.util.function.Supplier;
+
+class FaceUpdateActiveUserClient extends HalClientMonitor<IFaceService> {
+    private static final String FACE_DATA_DIR = "facedata";
+    private static final String TAG = "FaceUpdateActiveUserClient";
+    private final Map<Integer, Long> mAuthenticatorIds;
+    private final int mCurrentUserId;
+    private final boolean mHasEnrolledBiometrics;
+
+    FaceUpdateActiveUserClient(Context context, Supplier<IFaceService> lazyDaemon, int userId, String owner, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext, int currentUserId, boolean hasEnrolledBIometrics, Map<Integer, Long> authenticatorIds) {
+        super(context, lazyDaemon, null, null, userId, owner, 0, sensorId, biometricLogger, biometricContext);
+        mCurrentUserId = currentUserId;
+        mHasEnrolledBiometrics = hasEnrolledBIometrics;
+        mAuthenticatorIds = authenticatorIds;
+    }
+
+    @Override
+    public void start(ClientMonitorCallback callback) {
+        super.start(callback);
+        if (mCurrentUserId == getTargetUserId()) {
+            Slog.d(TAG, "Already user: " + mCurrentUserId + ", refreshing authenticatorId");
+            try {
+                mAuthenticatorIds.put(getTargetUserId(), mHasEnrolledBiometrics ? (long) getFreshDaemon().getAuthenticatorId() : 0);
+            } catch (RemoteException e) {
+                Slog.e(TAG, "Unable to refresh authenticatorId", e);
+            }
+            callback.onClientFinished(this, true);
+            return;
+        }
+        startHalOperation();
+    }
+
+    @Override
+    public void unableToStart() {
+    }
+
+    @Override
+    protected void startHalOperation() {
+        mCallback.onClientFinished(this, false);
+    }
+
+    @Override
+    public int getProtoEnum() {
+        return 1;
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/TestHal.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/TestHal.java
new file mode 100644
index 000000000000..5b8a9eb24629
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/TestHal.java
@@ -0,0 +1,128 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.hardware.face.Face;
+import android.os.RemoteException;
+import android.util.Slog;
+
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.internal.util.custom.faceunlock.IFaceServiceReceiver;
+import com.android.server.biometrics.sensors.face.FaceUtils;
+
+import java.util.List;
+
+class TestHal extends IFaceService.Stub {
+    private static final String TAG = "FaceService.TestHal";
+    private final Context mContext;
+    private final int mSensorId;
+    private final int mUserId;
+    private IFaceServiceReceiver mCallback;
+
+    TestHal(int userId, Context context, int sensorId) {
+        mUserId = userId;
+        mContext = context;
+        mSensorId = sensorId;
+    }
+
+    @Override
+    public void setCallback(IFaceServiceReceiver clientCallback) throws RemoteException {
+        mCallback = clientCallback;
+    }
+
+    @Override
+    public int revokeChallenge() {
+        return 0;
+    }
+
+    @Override
+    public int getAuthenticatorId() throws RemoteException {
+        return 0;
+    }
+
+    @Override
+    public boolean getFeature(int i, int i1) throws RemoteException {
+        return false;
+    }
+
+    @Override
+    public int getFeatureCount() throws RemoteException {
+        return 0;
+    }
+
+    @Override
+    public long generateChallenge(int i) throws RemoteException {
+        Slog.w(TAG, "generateChallenge");
+        return 0;
+    }
+
+    @Override
+    public void resetLockout(byte[] bytes) throws RemoteException {
+    }
+
+    @Override
+    public void setFeature(int i, boolean b, byte[] bytes, int i1) throws RemoteException {
+    }
+
+    @Override
+    public int enumerate() throws RemoteException {
+        Slog.w(TAG, "enumerate");
+        if (mCallback != null) {
+            mCallback.onEnumerate(new int[0], 0);
+        }
+        return 0;
+    }
+
+    @Override
+    public void enroll(byte[] bytes, int i, int[] ints) throws RemoteException {
+        Slog.w(TAG, "enroll");
+    }
+
+    @Override
+    public void authenticate(long l) throws RemoteException {
+        Slog.w(TAG, "authenticate");
+    }
+
+    @Override
+    public void cancel() throws RemoteException {
+        if (mCallback != null) {
+            mCallback.onError(5, 0);
+        }
+    }
+
+    @Override
+    public void remove(int faceId) throws RemoteException {
+        if (mCallback != null) {
+            Slog.d(TAG, " remove : faceId = " + faceId);
+            if (faceId == 0) {
+                List<Face> faces = FaceUtils.getInstance(mSensorId).getBiometricsForUser(mContext, mUserId);
+                if (faces.size() <= 0) {
+                    mCallback.onError(6, 0);
+                    return;
+                }
+                int[] faceIds = new int[faces.size()];
+                for (int i = 0; i < faces.size(); i++) {
+                    faceIds[i] = faces.get(i).getBiometricId();
+                }
+                mCallback.onRemoved(faceIds, mUserId);
+                return;
+            }
+            mCallback.onRemoved(new int[]{faceId}, mUserId);
+        }
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/hidl/Face10.java b/services/core/java/com/android/server/biometrics/sensors/face/hidl/Face10.java
index 73c759f7738c..4e630390bd6c 100644
--- a/services/core/java/com/android/server/biometrics/sensors/face/hidl/Face10.java
+++ b/services/core/java/com/android/server/biometrics/sensors/face/hidl/Face10.java
@@ -370,7 +370,7 @@ public class Face10 implements IHwBinder.DeathRecipient, ServiceProvider {
             @NonNull LockoutResetDispatcher lockoutResetDispatcher) {
         final Handler handler = new Handler(Looper.getMainLooper());
         return new Face10(context, sensorProps, lockoutResetDispatcher, handler,
-                new BiometricScheduler(TAG, BiometricScheduler.SENSOR_TYPE_FACE,
+                new BiometricScheduler(context, TAG, BiometricScheduler.SENSOR_TYPE_FACE,
                         null /* gestureAvailabilityTracker */),
                 BiometricContext.getInstance(context));
     }
diff --git a/services/core/java/com/android/server/biometrics/sensors/fingerprint/hidl/Fingerprint21.java b/services/core/java/com/android/server/biometrics/sensors/fingerprint/hidl/Fingerprint21.java
index 47f130b95267..f93b350054ef 100644
--- a/services/core/java/com/android/server/biometrics/sensors/fingerprint/hidl/Fingerprint21.java
+++ b/services/core/java/com/android/server/biometrics/sensors/fingerprint/hidl/Fingerprint21.java
@@ -363,7 +363,7 @@ public class Fingerprint21 implements IHwBinder.DeathRecipient, ServiceProvider
             @NonNull LockoutResetDispatcher lockoutResetDispatcher,
             @NonNull GestureAvailabilityDispatcher gestureAvailabilityDispatcher) {
         final BiometricScheduler scheduler =
-                new BiometricScheduler(TAG,
+                new BiometricScheduler(context, TAG,
                         BiometricScheduler.sensorTypeFromFingerprintProperties(sensorProps),
                         gestureAvailabilityDispatcher);
         final HalResultController controller = new HalResultController(sensorProps.sensorId,
diff --git a/services/core/java/com/android/server/biometrics/sensors/fingerprint/hidl/Fingerprint21UdfpsMock.java b/services/core/java/com/android/server/biometrics/sensors/fingerprint/hidl/Fingerprint21UdfpsMock.java
index bea0f4ffd45d..9726ae3d5764 100644
--- a/services/core/java/com/android/server/biometrics/sensors/fingerprint/hidl/Fingerprint21UdfpsMock.java
+++ b/services/core/java/com/android/server/biometrics/sensors/fingerprint/hidl/Fingerprint21UdfpsMock.java
@@ -137,9 +137,9 @@ public class Fingerprint21UdfpsMock extends Fingerprint21 implements TrustManage
     private static class TestableBiometricScheduler extends BiometricScheduler {
         @NonNull private Fingerprint21UdfpsMock mFingerprint21;
 
-        TestableBiometricScheduler(@NonNull String tag, @NonNull Handler handler,
+        TestableBiometricScheduler(Context context, @NonNull String tag, @NonNull Handler handler,
                 @Nullable GestureAvailabilityDispatcher gestureAvailabilityDispatcher) {
-            super(tag, BiometricScheduler.SENSOR_TYPE_FP_OTHER, gestureAvailabilityDispatcher);
+            super(context, tag, BiometricScheduler.SENSOR_TYPE_FP_OTHER, gestureAvailabilityDispatcher);
         }
 
         void init(@NonNull Fingerprint21UdfpsMock fingerprint21) {
@@ -254,7 +254,7 @@ public class Fingerprint21UdfpsMock extends Fingerprint21 implements TrustManage
 
         final Handler handler = new Handler(Looper.getMainLooper());
         final TestableBiometricScheduler scheduler =
-                new TestableBiometricScheduler(TAG, handler, gestureAvailabilityDispatcher);
+                new TestableBiometricScheduler(context, TAG, handler, gestureAvailabilityDispatcher);
         final MockHalResultController controller =
                 new MockHalResultController(sensorProps.sensorId, context, handler, scheduler);
         return new Fingerprint21UdfpsMock(context, biometricStateCallback, sensorProps, scheduler,
diff --git a/services/core/java/com/android/server/policy/PermissionPolicyService.java b/services/core/java/com/android/server/policy/PermissionPolicyService.java
index b56e1120f16a..f0d764fe716f 100644
--- a/services/core/java/com/android/server/policy/PermissionPolicyService.java
+++ b/services/core/java/com/android/server/policy/PermissionPolicyService.java
@@ -103,6 +103,8 @@ import com.android.server.wm.ActivityInterceptorCallback;
 import com.android.server.wm.ActivityInterceptorCallback.ActivityInterceptorInfo;
 import com.android.server.wm.ActivityTaskManagerInternal;
 
+import com.android.internal.util.custom.faceunlock.FaceUnlockUtils;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -935,6 +937,12 @@ public final class PermissionPolicyService extends SystemService {
                             permissionInfo.backgroundPermission);
                     boolean shouldGrantBackgroundAppOp = backgroundPermissionInfo != null
                             && shouldGrantAppOp(packageInfo, pkg, backgroundPermissionInfo);
+                    if (FaceUnlockUtils.getServicePackageName().equals(packageName) &&
+                            FaceUnlockUtils.isFaceUnlockSupported() &&
+                            "android.permission.CAMERA".equals(permissionInfo.name) &&
+                            packageInfo.applicationInfo.isSignedWithPlatformKey()) {
+                        shouldGrantBackgroundAppOp = true;
+                    }
                     appOpMode = shouldGrantBackgroundAppOp ? MODE_ALLOWED : MODE_FOREGROUND;
                 } else {
                     appOpMode = MODE_ALLOWED;
-- 
2.34.1

